shadow$provide.module$node_modules$$liveblocks$react$dist$chunk_3MM4G6XB = function(global, require, module, exports) {
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    var newObj = {};
    if (null != obj) {
      for (var key in obj) {
        Object.prototype.hasOwnProperty.call(obj, key) && (newObj[key] = obj[key]);
      }
    }
    newObj.default = obj;
    return newObj;
  }
  function _nullishCoalesce(lhs, rhsFn) {
    return null != lhs ? lhs : rhsFn();
  }
  function _optionalChain(ops) {
    let lastAccessLHS = void 0, value = ops[0], i = 1;
    for (; i < ops.length;) {
      const op = ops[i], fn = ops[i + 1];
      i += 2;
      if (("optionalAccess" === op || "optionalCall" === op) && null == value) {
        return;
      }
      if ("access" === op || "optionalAccess" === op) {
        lastAccessLHS = value, value = fn(value);
      } else if ("call" === op || "optionalCall" === op) {
        value = fn((...args) => value.call(lastAccessLHS, ...args)), lastAccessLHS = void 0;
      }
    }
    return value;
  }
  function useIsInsideRoom() {
    return null !== React.useContext(RoomContext);
  }
  function shallow2(a, b) {
    if (!_core.isPlainObject.call(void 0, a) || !_core.isPlainObject.call(void 0, b)) {
      return _core.shallow.call(void 0, a, b);
    }
    const keysA = Object.keys(a);
    return keysA.length !== Object.keys(b).length ? !1 : keysA.every(key => Object.prototype.hasOwnProperty.call(b, key) && _core.shallow.call(void 0, a[key], b[key]));
  }
  function useLatest(value) {
    const ref = _react.useRef.call(void 0, value);
    _react.useEffect.call(void 0, () => {
      ref.current = value;
    }, [value]);
    return ref;
  }
  function useInitial(value) {
    return _react.useReducer.call(void 0, noop, value)[0];
  }
  function useInitialUnlessFunction(latestValue) {
    const frozenValue = useInitial(latestValue);
    if ("function" === typeof frozenValue) {
      const ref = useLatest(latestValue);
      return _react.useCallback.call(void 0, (...args) => ref.current(...args), [ref]);
    }
    return frozenValue;
  }
  function autobind(self) {
    const seen = new Set();
    seen.add("constructor");
    let obj = self.constructor.prototype;
    do {
      for (const key of Reflect.ownKeys(obj)) {
        if (seen.has(key)) {
          continue;
        }
        const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);
        "function" === typeof _optionalChain([descriptor, "optionalAccess", _ => _.value]) && (seen.add(key), self[key] = self[key].bind(self));
      }
    } while ((obj = Reflect.getPrototypeOf(obj)) && obj !== Object.prototype);
  }
  function makeThreadsFilter(query) {
    return thread => (void 0 === query.resolved || thread.resolved === query.resolved) && matchesMetadata(thread, query);
  }
  function matchesMetadata(thread, q) {
    const metadata = thread.metadata;
    return void 0 === q.metadata || Object.entries(q.metadata).every(([key, op]) => {
      key = metadata[key];
      op = _core.isPlainObject.call(void 0, op) && "string" === typeof op.startsWith ? "string" === typeof key && key.startsWith(op.startsWith) : key === op;
      return op;
    });
  }
  function sanitizeThread(thread) {
    return thread.deletedAt && 0 < thread.comments.length ? {...thread, comments:[]} : thread.comments.some(c => !c.deletedAt) ? thread : {...thread, deletedAt:new Date(), comments:[]};
  }
  function makeRoomThreadsQueryKey(roomId, query) {
    return `${roomId}-${_core.stringify.call(void 0, _nullishCoalesce(query, () => ({})))}`;
  }
  function makeUserThreadsQueryKey(query) {
    return `USER_THREADS:${_core.stringify.call(void 0, _nullishCoalesce(query, () => ({})))}`;
  }
  function usify(promise) {
    if ("status" in promise) {
      return promise;
    }
    promise.status = "pending";
    promise.then(value => {
      promise.status = "fulfilled";
      promise.value = value;
    }, err => {
      promise.status = "rejected";
      promise.reason = err;
    });
    return promise;
  }
  function internalToExternalState(state, rawThreadsDB) {
    const threadsDB = rawThreadsDB.clone();
    rawThreadsDB = {...state.notificationsById};
    var JSCompiler_object_inline_settingsByRoomId_1632 = {...state.settingsByRoomId};
    for (const optimisticUpdate of state.optimisticUpdates) {
      switch(optimisticUpdate.type) {
        case "create-thread":
          threadsDB.upsert(optimisticUpdate.thread);
          break;
        case "edit-thread-metadata":
          var thread$jscomp$0 = threadsDB.get(optimisticUpdate.threadId);
          if (void 0 === thread$jscomp$0) {
            break;
          }
          if (thread$jscomp$0.updatedAt > optimisticUpdate.updatedAt) {
            break;
          }
          threadsDB.upsert({...thread$jscomp$0, updatedAt:optimisticUpdate.updatedAt, metadata:{...thread$jscomp$0.metadata, ...optimisticUpdate.metadata}});
          break;
        case "mark-thread-as-resolved":
          thread$jscomp$0 = threadsDB.get(optimisticUpdate.threadId);
          if (void 0 === thread$jscomp$0) {
            break;
          }
          threadsDB.upsert({...thread$jscomp$0, resolved:!0});
          break;
        case "mark-thread-as-unresolved":
          thread$jscomp$0 = threadsDB.get(optimisticUpdate.threadId);
          if (void 0 === thread$jscomp$0) {
            break;
          }
          threadsDB.upsert({...thread$jscomp$0, resolved:!1});
          break;
        case "create-comment":
          const thread = threadsDB.get(optimisticUpdate.comment.threadId);
          if (void 0 === thread) {
            break;
          }
          threadsDB.upsert(applyUpsertComment(thread, optimisticUpdate.comment));
          thread$jscomp$0 = Object.values(rawThreadsDB).find(notification => "thread" === notification.kind && notification.threadId === thread.id);
          if (void 0 === thread$jscomp$0) {
            break;
          }
          rawThreadsDB[thread$jscomp$0.id] = {...thread$jscomp$0, notifiedAt:optimisticUpdate.comment.createdAt, readAt:optimisticUpdate.comment.createdAt};
          break;
        case "edit-comment":
          thread$jscomp$0 = threadsDB.get(optimisticUpdate.comment.threadId);
          if (void 0 === thread$jscomp$0) {
            break;
          }
          threadsDB.upsert(applyUpsertComment(thread$jscomp$0, optimisticUpdate.comment));
          break;
        case "delete-comment":
          thread$jscomp$0 = threadsDB.get(optimisticUpdate.threadId);
          if (void 0 === thread$jscomp$0) {
            break;
          }
          threadsDB.upsert(applyDeleteComment(thread$jscomp$0, optimisticUpdate.commentId, optimisticUpdate.deletedAt));
          break;
        case "delete-thread":
          thread$jscomp$0 = threadsDB.get(optimisticUpdate.threadId);
          if (void 0 === thread$jscomp$0) {
            break;
          }
          threadsDB.upsert({...thread$jscomp$0, deletedAt:optimisticUpdate.deletedAt, updatedAt:optimisticUpdate.deletedAt, comments:[]});
          break;
        case "add-reaction":
          thread$jscomp$0 = threadsDB.get(optimisticUpdate.threadId);
          if (void 0 === thread$jscomp$0) {
            break;
          }
          threadsDB.upsert(applyAddReaction(thread$jscomp$0, optimisticUpdate.commentId, optimisticUpdate.reaction));
          break;
        case "remove-reaction":
          thread$jscomp$0 = threadsDB.get(optimisticUpdate.threadId);
          if (void 0 === thread$jscomp$0) {
            break;
          }
          threadsDB.upsert(applyRemoveReaction(thread$jscomp$0, optimisticUpdate.commentId, optimisticUpdate.emoji, optimisticUpdate.userId, optimisticUpdate.removedAt));
          break;
        case "mark-inbox-notification-as-read":
          thread$jscomp$0 = rawThreadsDB[optimisticUpdate.inboxNotificationId];
          if (void 0 === thread$jscomp$0) {
            break;
          }
          rawThreadsDB[optimisticUpdate.inboxNotificationId] = {...thread$jscomp$0, readAt:optimisticUpdate.readAt};
          break;
        case "mark-all-inbox-notifications-as-read":
          for (const id in rawThreadsDB) {
            thread$jscomp$0 = rawThreadsDB[id];
            if (void 0 === thread$jscomp$0) {
              break;
            }
            rawThreadsDB[id] = {...thread$jscomp$0, readAt:optimisticUpdate.readAt};
          }
          break;
        case "delete-inbox-notification":
          delete rawThreadsDB[optimisticUpdate.inboxNotificationId];
          break;
        case "delete-all-inbox-notifications":
          rawThreadsDB = {};
          break;
        case "update-notification-settings":
          thread$jscomp$0 = JSCompiler_object_inline_settingsByRoomId_1632[optimisticUpdate.roomId], void 0 !== thread$jscomp$0 && (JSCompiler_object_inline_settingsByRoomId_1632[optimisticUpdate.roomId] = {...thread$jscomp$0, ...optimisticUpdate.settings});
      }
    }
    return {cleanedNotifications:Object.values(rawThreadsDB).filter(ibn => "thread" === ibn.kind ? void 0 !== threadsDB.get(ibn.threadId) : !0).sort((a, b) => b.notifiedAt.getTime() - a.notifiedAt.getTime()), notificationsById:rawThreadsDB, settingsByRoomId:JSCompiler_object_inline_settingsByRoomId_1632, threadsDB, versionsByRoomId:state.versionsByRoomId};
  }
  function applyThreadDeltaUpdates(db, updates) {
    updates.newThreads.forEach(thread => db.upsertIfNewer(thread));
    updates.deletedThreads.forEach(({id, deletedAt}) => {
      db.getEvenIfDeleted(id) && db.delete(id, deletedAt);
    });
  }
  function applyNotificationsUpdates(existingInboxNotifications, updates) {
    const updatedInboxNotifications = {...existingInboxNotifications};
    updates.newInboxNotifications.forEach(notification => {
      const existingNotification = updatedInboxNotifications[notification.id];
      existingNotification && 1 === (existingNotification.notifiedAt > notification.notifiedAt ? 1 : existingNotification.notifiedAt < notification.notifiedAt ? -1 : existingNotification.readAt && notification.readAt ? existingNotification.readAt > notification.readAt ? 1 : existingNotification.readAt < notification.readAt ? -1 : 0 : existingNotification.readAt || notification.readAt ? existingNotification.readAt ? 1 : -1 : 0) || (updatedInboxNotifications[notification.id] = notification);
    });
    updates.deletedNotifications.forEach(({id}) => delete updatedInboxNotifications[id]);
    return updatedInboxNotifications;
  }
  function applyUpsertComment(thread, comment) {
    if (void 0 !== thread.deletedAt) {
      return thread;
    }
    if (comment.threadId !== thread.id) {
      return _core.console.warn(`Comment ${comment.id} does not belong to thread ${thread.id}`), thread;
    }
    var existingComment = thread.comments.find(existingComment2 => existingComment2.id === comment.id);
    return void 0 === existingComment ? (existingComment = new Date(Math.max(thread.updatedAt.getTime(), comment.createdAt.getTime())), {...thread, updatedAt:existingComment, comments:[...thread.comments, comment]}) : void 0 !== existingComment.deletedAt ? thread : void 0 === existingComment.editedAt || void 0 === comment.editedAt || existingComment.editedAt <= comment.editedAt ? (existingComment = thread.comments.map(existingComment2 => existingComment2.id === comment.id ? comment : existingComment2), 
    {...thread, updatedAt:new Date(Math.max(thread.updatedAt.getTime(), _optionalChain([comment, "access", _5 => _5.editedAt, "optionalAccess", _6 => _6.getTime, "call", _7 => _7()]) || comment.createdAt.getTime())), comments:existingComment}) : thread;
  }
  function applyDeleteComment(thread, commentId, deletedAt) {
    if (void 0 !== thread.deletedAt) {
      return thread;
    }
    var existingComment = thread.comments.find(comment => comment.id === commentId);
    if (void 0 === existingComment || void 0 !== existingComment.deletedAt) {
      return thread;
    }
    existingComment = thread.comments.map(comment => comment.id === commentId ? {...comment, deletedAt, body:void 0, attachments:[]} : comment);
    return existingComment.every(comment => void 0 !== comment.deletedAt) ? {...thread, deletedAt, updatedAt:deletedAt} : {...thread, updatedAt:deletedAt, comments:existingComment};
  }
  function applyAddReaction(thread, commentId, reaction) {
    if (void 0 !== thread.deletedAt) {
      return thread;
    }
    var existingComment = thread.comments.find(comment => comment.id === commentId);
    if (void 0 === existingComment || void 0 !== existingComment.deletedAt) {
      return thread;
    }
    existingComment = thread.comments.map(comment => comment.id === commentId ? {...comment, reactions:upsertReaction(comment.reactions, reaction)} : comment);
    return {...thread, updatedAt:new Date(Math.max(reaction.createdAt.getTime(), thread.updatedAt.getTime())), comments:existingComment};
  }
  function applyRemoveReaction(thread, commentId, emoji, userId, removedAt) {
    if (void 0 !== thread.deletedAt) {
      return thread;
    }
    var existingComment = thread.comments.find(comment => comment.id === commentId);
    if (void 0 === existingComment || void 0 !== existingComment.deletedAt) {
      return thread;
    }
    existingComment = thread.comments.map(comment => comment.id === commentId ? {...comment, reactions:comment.reactions.map(reaction => reaction.emoji === emoji ? {...reaction, users:reaction.users.filter(user => user.id !== userId)} : reaction).filter(reaction => 0 < reaction.users.length)} : comment);
    return {...thread, updatedAt:new Date(Math.max(removedAt.getTime(), thread.updatedAt.getTime())), comments:existingComment};
  }
  function upsertReaction(reactions, reaction) {
    const existingReaction = reactions.find(existingReaction2 => existingReaction2.emoji === reaction.emoji);
    return void 0 === existingReaction ? [...reactions, {emoji:reaction.emoji, createdAt:reaction.createdAt, users:[{id:reaction.userId}]}] : !1 === existingReaction.users.some(user => user.id === reaction.userId) ? reactions.map(existingReaction2 => existingReaction2.emoji === reaction.emoji ? {...existingReaction2, users:[...existingReaction2.users, {id:reaction.userId}]} : existingReaction2) : reactions;
  }
  function missingUserError(userId) {
    return Error(`resolveUsers didn't return anything for user '${userId}'`);
  }
  function missingRoomInfoError(roomId) {
    return Error(`resolveRoomsInfo didn't return anything for room '${roomId}'`);
  }
  function identity(x) {
    return x;
  }
  function selectorFor_useUnreadInboxNotificationsCount(result) {
    if (!result.inboxNotifications) {
      return result;
    }
    let count = 0;
    for (const notification of result.inboxNotifications) {
      (null === notification.readAt || notification.readAt < notification.notifiedAt) && count++;
    }
    return {isLoading:!1, count};
  }
  function selectorFor_useUser(state, userId) {
    return void 0 === state || _optionalChain([state, "optionalAccess", _8 => _8.isLoading]) ? _nullishCoalesce(state, () => ({isLoading:!0})) : state.error ? state : state.data ? {isLoading:!1, user:state.data} : {isLoading:!1, error:missingUserError(userId)};
  }
  function selectorFor_useRoomInfo(state, roomId) {
    return void 0 === state || _optionalChain([state, "optionalAccess", _9 => _9.isLoading]) ? _nullishCoalesce(state, () => ({isLoading:!0})) : state.error ? state : state.data ? {isLoading:!1, info:state.data} : {isLoading:!1, error:missingRoomInfoError(roomId)};
  }
  function getUmbrellaStoreForClient(client) {
    let store = _umbrellaStores.get(client);
    store || (store = new UmbrellaStore(client), _umbrellaStores.set(client, store));
    return store;
  }
  function getLiveblocksExtrasForClient(client) {
    let extras = _extras.get(client);
    extras || (extras = makeLiveblocksExtrasForClient(client), _extras.set(client, extras));
    return extras;
  }
  function makeLiveblocksExtrasForClient(client) {
    const store = getUmbrellaStoreForClient(client);
    client = _core.makePoller.call(void 0, async signal => {
      try {
        return await store.fetchNotificationsDeltaUpdate(signal);
      } catch (err) {
        throw console.warn(`Polling new inbox notifications failed: ${String(err)}`), err;
      }
    }, config.NOTIFICATIONS_POLL_INTERVAL, {maxStaleTimeMs:config.NOTIFICATIONS_MAX_STALE_TIME});
    const userThreadsPoller = _core.makePoller.call(void 0, async signal => {
      try {
        return await store.fetchUserThreadsDeltaUpdate(signal);
      } catch (err) {
        throw console.warn(`Polling new user threads failed: ${String(err)}`), err;
      }
    }, config.USER_THREADS_POLL_INTERVAL, {maxStaleTimeMs:config.USER_THREADS_MAX_STALE_TIME});
    return {store, notificationsPoller:client, userThreadsPoller};
  }
  function makeLiveblocksContextBundle(client) {
    function LiveblocksProvider2(props) {
      useEnsureNoLiveblocksProvider();
      return React.default.createElement(ClientContext.Provider, {value:client}, props.children);
    }
    const useInboxNotificationThread2 = inboxNotificationId => useInboxNotificationThread_withClient(client, inboxNotificationId), useMarkInboxNotificationAsRead2 = () => useMarkInboxNotificationAsRead_withClient(client), useMarkAllInboxNotificationsAsRead2 = () => useMarkAllInboxNotificationsAsRead_withClient(client), useDeleteInboxNotification2 = () => useDeleteInboxNotification_withClient(client), useDeleteAllInboxNotifications2 = () => useDeleteAllInboxNotifications_withClient(client), shared = 
    createSharedContext(client);
    return {LiveblocksProvider:LiveblocksProvider2, useInboxNotifications:() => useInboxNotifications_withClient(client, identity, _core.shallow), useUnreadInboxNotificationsCount:() => useInboxNotifications_withClient(client, selectorFor_useUnreadInboxNotificationsCount, _core.shallow), useMarkInboxNotificationAsRead:useMarkInboxNotificationAsRead2, useMarkAllInboxNotificationsAsRead:useMarkAllInboxNotificationsAsRead2, useDeleteInboxNotification:useDeleteInboxNotification2, useDeleteAllInboxNotifications:useDeleteAllInboxNotifications2, 
    useInboxNotificationThread:useInboxNotificationThread2, useUserThreads_experimental, ...shared.classic, suspense:{LiveblocksProvider:LiveblocksProvider2, useInboxNotifications:() => useInboxNotificationsSuspense_withClient(client), useUnreadInboxNotificationsCount:() => useUnreadInboxNotificationsCountSuspense_withClient(client), useMarkInboxNotificationAsRead:useMarkInboxNotificationAsRead2, useMarkAllInboxNotificationsAsRead:useMarkAllInboxNotificationsAsRead2, useDeleteInboxNotification:useDeleteInboxNotification2, 
    useDeleteAllInboxNotifications:useDeleteAllInboxNotifications2, useInboxNotificationThread:useInboxNotificationThread2, useUserThreads_experimental:useUserThreadsSuspense_experimental, ...shared.suspense}};
  }
  function useInboxNotifications_withClient(client, selector, isEqual) {
    const {store, notificationsPoller:poller} = getLiveblocksExtrasForClient(client);
    _react.useEffect.call(void 0, () => {
      store.waitUntilNotificationsLoaded();
    });
    _react.useEffect.call(void 0, () => {
      poller.inc();
      poller.pollNowIfStale();
      return () => {
        poller.dec();
      };
    }, [poller]);
    return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, store.subscribe, store.getInboxNotificationsLoadingState, store.getInboxNotificationsLoadingState, selector, isEqual);
  }
  function useInboxNotificationsSuspense_withClient(client) {
    const store = getLiveblocksExtrasForClient(client).store;
    use(store.waitUntilNotificationsLoaded());
    client = useInboxNotifications_withClient(client, identity, _core.shallow);
    _core.assert.call(void 0, !client.error, "Did not expect error");
    _core.assert.call(void 0, !client.isLoading, "Did not expect loading");
    return client;
  }
  function useUnreadInboxNotificationsCountSuspense_withClient(client) {
    const store = getLiveblocksExtrasForClient(client).store;
    use(store.waitUntilNotificationsLoaded());
    client = useInboxNotifications_withClient(client, selectorFor_useUnreadInboxNotificationsCount, _core.shallow);
    _core.assert.call(void 0, !client.isLoading, "Did not expect loading");
    _core.assert.call(void 0, !client.error, "Did not expect error");
    return client;
  }
  function useMarkInboxNotificationAsRead_withClient(client) {
    return _react.useCallback.call(void 0, inboxNotificationId => {
      const {store} = getLiveblocksExtrasForClient(client), readAt = new Date(), optimisticUpdateId = store.addOptimisticUpdate({type:"mark-inbox-notification-as-read", inboxNotificationId, readAt});
      client.markInboxNotificationAsRead(inboxNotificationId).then(() => {
        store.updateInboxNotification(inboxNotificationId, optimisticUpdateId, inboxNotification => ({...inboxNotification, readAt}));
      }, () => {
        store.removeOptimisticUpdate(optimisticUpdateId);
      });
    }, [client]);
  }
  function useMarkAllInboxNotificationsAsRead_withClient(client) {
    return _react.useCallback.call(void 0, () => {
      const {store} = getLiveblocksExtrasForClient(client), readAt = new Date(), optimisticUpdateId = store.addOptimisticUpdate({type:"mark-all-inbox-notifications-as-read", readAt});
      client.markAllInboxNotificationsAsRead().then(() => {
        store.updateAllInboxNotifications(optimisticUpdateId, inboxNotification => ({...inboxNotification, readAt}));
      }, () => {
        store.removeOptimisticUpdate(optimisticUpdateId);
      });
    }, [client]);
  }
  function useDeleteInboxNotification_withClient(client) {
    return _react.useCallback.call(void 0, inboxNotificationId => {
      const {store} = getLiveblocksExtrasForClient(client), optimisticUpdateId = store.addOptimisticUpdate({type:"delete-inbox-notification", inboxNotificationId, deletedAt:new Date()});
      client.deleteInboxNotification(inboxNotificationId).then(() => {
        store.deleteInboxNotification(inboxNotificationId, optimisticUpdateId);
      }, () => {
        store.removeOptimisticUpdate(optimisticUpdateId);
      });
    }, [client]);
  }
  function useDeleteAllInboxNotifications_withClient(client) {
    return _react.useCallback.call(void 0, () => {
      const {store} = getLiveblocksExtrasForClient(client), optimisticUpdateId = store.addOptimisticUpdate({type:"delete-all-inbox-notifications", deletedAt:new Date()});
      client.deleteAllInboxNotifications().then(() => {
        store.deleteAllInboxNotifications(optimisticUpdateId);
      }, () => {
        store.removeOptimisticUpdate(optimisticUpdateId);
      });
    }, [client]);
  }
  function useInboxNotificationThread_withClient(client, inboxNotificationId) {
    ({store:client} = getLiveblocksExtrasForClient(client));
    const getter = client.getFullState, selector = _react.useCallback.call(void 0, state => {
      const inboxNotification = _nullishCoalesce(state.notificationsById[inboxNotificationId], () => _core.raise.call(void 0, `Inbox notification with ID "${inboxNotificationId}" not found`));
      "thread" !== inboxNotification.kind && _core.raise.call(void 0, `Inbox notification with ID "${inboxNotificationId}" is not of kind "thread"`);
      return _nullishCoalesce(state.threadsDB.get(inboxNotification.threadId), () => _core.raise.call(void 0, `Thread with ID "${inboxNotification.threadId}" not found, this inbox notification might not be of kind "thread"`));
    }, [inboxNotificationId]);
    return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, client.subscribe, getter, getter, selector);
  }
  function useUser_withClient(client, userId) {
    const usersStore = client[_core.kInternal].usersStore;
    client = _react.useCallback.call(void 0, () => usersStore.getState(userId), [usersStore, userId]);
    const selector = _react.useCallback.call(void 0, state => selectorFor_useUser(state, userId), [userId]);
    client = _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, usersStore.subscribe, client, client, selector, _core.shallow);
    _react.useEffect.call(void 0, () => {
      usersStore.get(userId);
    }, [usersStore, userId, client]);
    return client;
  }
  function useUserSuspense_withClient(client, userId) {
    const usersStore = client[_core.kInternal].usersStore;
    client = _react.useCallback.call(void 0, () => usersStore.getState(userId), [usersStore, userId]);
    const userState = client();
    if (!userState || userState.isLoading) {
      throw usersStore.get(userId);
    }
    if (userState.error) {
      throw userState.error;
    }
    if (!userState.data) {
      throw missingUserError(userId);
    }
    client = _indexjs.useSyncExternalStore.call(void 0, usersStore.subscribe, client, client);
    _core.assert.call(void 0, void 0 !== client, "Unexpected missing state");
    _core.assert.call(void 0, !client.isLoading, "Unexpected loading state");
    _core.assert.call(void 0, !client.error, "Unexpected error state");
    return {isLoading:!1, user:client.data, error:void 0};
  }
  function useRoomInfo_withClient(client, roomId) {
    const roomsInfoStore = client[_core.kInternal].roomsInfoStore;
    client = _react.useCallback.call(void 0, () => roomsInfoStore.getState(roomId), [roomsInfoStore, roomId]);
    const selector = _react.useCallback.call(void 0, state => selectorFor_useRoomInfo(state, roomId), [roomId]);
    client = _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, roomsInfoStore.subscribe, client, client, selector, _core.shallow);
    _react.useEffect.call(void 0, () => {
      roomsInfoStore.get(roomId);
    }, [roomsInfoStore, roomId, client]);
    return client;
  }
  function useRoomInfoSuspense_withClient(client, roomId) {
    const roomsInfoStore = client[_core.kInternal].roomsInfoStore;
    client = _react.useCallback.call(void 0, () => roomsInfoStore.getState(roomId), [roomsInfoStore, roomId]);
    const roomInfoState = client();
    if (!roomInfoState || roomInfoState.isLoading) {
      throw roomsInfoStore.get(roomId);
    }
    if (roomInfoState.error) {
      throw roomInfoState.error;
    }
    if (!roomInfoState.data) {
      throw missingRoomInfoError(roomId);
    }
    client = _indexjs.useSyncExternalStore.call(void 0, roomsInfoStore.subscribe, client, client);
    _core.assert.call(void 0, void 0 !== client, "Unexpected missing state");
    _core.assert.call(void 0, !client.isLoading, "Unexpected loading state");
    _core.assert.call(void 0, !client.error, "Unexpected error state");
    _core.assert.call(void 0, void 0 !== client.data, "Unexpected missing room info data");
    return {isLoading:!1, info:client.data, error:void 0};
  }
  function createSharedContext(client) {
    const useClient2 = () => client;
    return {classic:{useClient:useClient2, useUser:userId => useUser_withClient(client, userId), useRoomInfo:roomId => useRoomInfo_withClient(client, roomId), useIsInsideRoom}, suspense:{useClient:useClient2, useUser:userId => useUserSuspense_withClient(client, userId), useRoomInfo:roomId => useRoomInfoSuspense_withClient(client, roomId), useIsInsideRoom}};
  }
  function useEnsureNoLiveblocksProvider(options) {
    const existing = _react.useContext.call(void 0, ClientContext);
    if (!_optionalChain([options, "optionalAccess", _10 => _10.allowNesting]) && null !== existing) {
      throw Error("You cannot nest multiple LiveblocksProvider instances in the same React tree.");
    }
  }
  function useClient() {
    return _nullishCoalesce(_react.useContext.call(void 0, ClientContext), () => _core.raise.call(void 0, "LiveblocksProvider is missing from the React tree."));
  }
  function LiveblocksProviderWithClient(props) {
    useEnsureNoLiveblocksProvider(props);
    return React.default.createElement(ClientContext.Provider, {value:props.client}, props.children);
  }
  function useUserThreads_experimental(options = {query:{metadata:{}}}) {
    var client = useClient();
    const {store, userThreadsPoller:poller} = getLiveblocksExtrasForClient(client);
    _react.useEffect.call(void 0, () => {
      store.waitUntilUserThreadsLoaded(options.query);
    });
    _react.useEffect.call(void 0, () => {
      poller.inc();
      poller.pollNowIfStale();
      return () => {
        poller.dec();
      };
    }, [poller]);
    client = _react.useCallback.call(void 0, () => store.getUserThreadsLoadingState(options.query), [store, options.query]);
    return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, store.subscribe, client, client, identity, shallow2);
  }
  function useUserThreadsSuspense_experimental(options = {query:{metadata:{}}}) {
    var client = useClient();
    ({store:client} = getLiveblocksExtrasForClient(client));
    use(client.waitUntilUserThreadsLoaded(options.query));
    options = useUserThreads_experimental(options);
    _core.assert.call(void 0, !options.error, "Did not expect error");
    _core.assert.call(void 0, !options.isLoading, "Did not expect loading");
    return options;
  }
  function handleScrollToCommentOnLoad(shouldScrollOnLoad, state) {
    if (!1 !== shouldScrollOnLoad && state.threads && "undefined" !== typeof window) {
      var commentId = window.location.hash.slice(1);
      commentId.startsWith("cm_") && (shouldScrollOnLoad = document.getElementById(commentId), null !== shouldScrollOnLoad && state.threads.flatMap(thread => thread.comments).some(comment2 => comment2.id === commentId) && shouldScrollOnLoad.scrollIntoView());
    }
  }
  function useScrollToCommentOnLoadEffect(shouldScrollOnLoad, state) {
    React3.useEffect(() => {
      handleScrollToCommentOnLoad(shouldScrollOnLoad, state);
    }, [state.isLoading]);
  }
  function useSyncExternalStore2(s, gs, gss) {
    return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, s, gs, gss, identity2);
  }
  function alwaysEmptyList() {
    return STABLE_EMPTY_LIST;
  }
  function alwaysNull() {
    return null;
  }
  function selectorFor_useOthersConnectionIds(others) {
    return others.map(user => user.connectionId);
  }
  function makeMutationContext(room) {
    return {get storage() {
      const mutableRoot = room.getStorageSnapshot();
      if (null === mutableRoot) {
        throw Error("This mutation cannot be used until storage has been loaded");
      }
      return mutableRoot;
    }, get self() {
      const self = room.getSelf();
      if (null === self) {
        throw Error("This mutation cannot be used until connected to the Liveblocks room");
      }
      return self;
    }, get others() {
      const others = room.getOthers();
      if (null === room.getSelf()) {
        throw Error("This mutation cannot be used until connected to the Liveblocks room");
      }
      return others;
    }, setMyPresence:room.updatePresence};
  }
  function getCurrentUserId(room) {
    room = room.getSelf();
    return null === room || void 0 === room.id ? "anonymous" : room.id;
  }
  function handleApiError(err) {
    const message = `Request failed with status ${err.status}: ${err.message}`;
    "FORBIDDEN" === _optionalChain([err, "access", _11 => _11.details, "optionalAccess", _12 => _12.error]) && (err = [message, err.details.suggestion, err.details.docs].filter(Boolean).join("\n"), _core.console.error(err));
    return Error(message);
  }
  function getRoomExtrasForClient(client) {
    let extras = _extras2.get(client);
    extras || (extras = makeRoomExtrasForClient(client), _extras2.set(client, extras));
    return extras;
  }
  function makeRoomExtrasForClient(client) {
    const store = getUmbrellaStoreForClient(client), commentsErrorEventSource = _core.makeEventSource.call(void 0), threadsPollersByRoomId = new Map(), versionsPollersByRoomId = new Map(), roomNotificationSettingsPollersByRoomId = new Map();
    return {store, commentsErrorEventSource:commentsErrorEventSource.observable, onMutationFailure:function(innerError, optimisticUpdateId, createPublicError) {
      store.removeOptimisticUpdate(optimisticUpdateId);
      if (innerError instanceof _core.HttpError) {
        innerError = handleApiError(innerError), commentsErrorEventSource.notify(createPublicError(innerError));
      } else {
        if (innerError instanceof _core.HttpError) {
          handleApiError(innerError);
        } else {
          throw innerError;
        }
      }
    }, getOrCreateThreadsPollerForRoomId:function(roomId) {
      let poller = threadsPollersByRoomId.get(roomId);
      poller || (poller = _core.makePoller.call(void 0, async signal => {
        try {
          return await store.fetchRoomThreadsDeltaUpdate(roomId, signal);
        } catch (err) {
          throw _core.console.warn(`Polling new threads for '${roomId}' failed: ${String(err)}`), err;
        }
      }, config.ROOM_THREADS_POLL_INTERVAL, {maxStaleTimeMs:config.ROOM_THREADS_MAX_STALE_TIME}), threadsPollersByRoomId.set(roomId, poller));
      return poller;
    }, getOrCreateVersionsPollerForRoomId:function(roomId) {
      let poller = versionsPollersByRoomId.get(roomId);
      poller || (poller = _core.makePoller.call(void 0, async signal => {
        try {
          return await store.fetchRoomVersionsDeltaUpdate(roomId, signal);
        } catch (err) {
          throw _core.console.warn(`Polling new history versions for '${roomId}' failed: ${String(err)}`), err;
        }
      }, config.HISTORY_VERSIONS_POLL_INTERVAL, {maxStaleTimeMs:config.HISTORY_VERSIONS_MAX_STALE_TIME}), versionsPollersByRoomId.set(roomId, poller));
      return poller;
    }, getOrCreateNotificationsSettingsPollerForRoomId:function(roomId) {
      let poller = roomNotificationSettingsPollersByRoomId.get(roomId);
      poller || (poller = _core.makePoller.call(void 0, async signal => {
        try {
          return await store.refreshRoomNotificationSettings(roomId, signal);
        } catch (err) {
          throw _core.console.warn(`Polling notification settings for '${roomId}' failed: ${String(err)}`), err;
        }
      }, config.NOTIFICATION_SETTINGS_POLL_INTERVAL, {maxStaleTimeMs:config.NOTIFICATION_SETTINGS_MAX_STALE_TIME}), roomNotificationSettingsPollersByRoomId.set(roomId, poller));
      return poller;
    }};
  }
  function makeRoomContextBundle(client) {
    function RoomProvider_withImplicitLiveblocksProvider(props) {
      return React4.createElement(LiveblocksProviderWithClient, {client, allowNesting:!0}, React4.createElement(RoomProvider, {...props}));
    }
    const shared = createSharedContext(client);
    return Object.defineProperty({RoomContext, RoomProvider:RoomProvider_withImplicitLiveblocksProvider, useRoom, useStatus, useStorageStatus, useBatch, useBroadcastEvent, useOthersListener, useLostConnectionListener, useErrorListener, useEventListener, useHistory, useUndo, useRedo, useCanRedo, useCanUndo, useStorageRoot, useStorage, useSelf, useMyPresence, useUpdateMyPresence, useOthers, useOthersMapped, useOthersConnectionIds, useOther, useMutation, useThreads, useCreateThread, useDeleteThread, 
    useEditThreadMetadata, useMarkThreadAsResolved, useMarkThreadAsUnresolved, useCreateComment, useEditComment, useDeleteComment, useAddReaction, useRemoveReaction, useMarkThreadAsRead, useThreadSubscription, useAttachmentUrl, useHistoryVersions, useHistoryVersionData, useRoomNotificationSettings, useUpdateRoomNotificationSettings, ...shared.classic, suspense:{RoomContext, RoomProvider:RoomProvider_withImplicitLiveblocksProvider, useRoom, useStatus, useStorageStatus:useStorageStatusSuspense, useBatch, 
    useBroadcastEvent, useOthersListener, useLostConnectionListener, useErrorListener, useEventListener, useHistory, useUndo, useRedo, useCanRedo, useCanUndo, useStorageRoot, useStorage:useStorageSuspense, useSelf:useSelfSuspense, useMyPresence, useUpdateMyPresence, useOthers:useOthersSuspense, useOthersMapped:useOthersMappedSuspense, useOthersConnectionIds:useOthersConnectionIdsSuspense, useOther:useOtherSuspense, useMutation, useThreads:useThreadsSuspense, useCreateThread, useDeleteThread, useEditThreadMetadata, 
    useMarkThreadAsResolved, useMarkThreadAsUnresolved, useCreateComment, useEditComment, useDeleteComment, useAddReaction, useRemoveReaction, useMarkThreadAsRead, useThreadSubscription, useAttachmentUrl:useAttachmentUrlSuspense, useHistoryVersions:useHistoryVersionsSuspense, useRoomNotificationSettings:useRoomNotificationSettingsSuspense, useUpdateRoomNotificationSettings, ...shared.suspense}, useCommentsErrorListener}, _core.kInternal, {enumerable:!1});
  }
  function RoomProvider(props) {
    const client = useClient(), [cache] = React4.useState(() => new Map()), stableEnterRoom = React4.useCallback((roomId, options) => {
      const cached = cache.get(roomId);
      if (cached) {
        return cached;
      }
      options = client.enterRoom(roomId, options);
      const origLeave = options.leave;
      options.leave = () => {
        origLeave();
        cache.delete(roomId);
      };
      cache.set(roomId, options);
      return options;
    }, [client, cache]);
    return React4.createElement(RoomProviderInner, {...props, stableEnterRoom});
  }
  function RoomProviderInner(props) {
    const client = useClient(), {id:roomId, stableEnterRoom} = props;
    if (!roomId) {
      throw Error("RoomProvider id property is required. For more information: https://liveblocks.io/docs/errors/liveblocks-react/RoomProvider-id-property-is-required");
    }
    if ("string" !== typeof roomId) {
      throw Error("RoomProvider id property should be a string.");
    }
    const majorReactVersion = parseInt(React4.version) || 1, oldReactVersion = 18 > majorReactVersion;
    _core.errorIf.call(void 0, oldReactVersion && void 0 === props.unstable_batchedUpdates, `We noticed you\u2019re using React ${majorReactVersion}. Please pass unstable_batchedUpdates at the RoomProvider level until you\u2019re ready to upgrade to React 18:

    import { unstable_batchedUpdates } from "react-dom";  // or "react-native"

    <RoomProvider id=${JSON.stringify(roomId)} ... unstable_batchedUpdates={unstable_batchedUpdates}>
      ...
    </RoomProvider>

Why? Please see https://liveblocks.io/docs/platform/troubleshooting#stale-props-zombie-child for more information`);
    _core.deprecateIf.call(void 0, !oldReactVersion && void 0 !== props.unstable_batchedUpdates, "You don’t need to pass unstable_batchedUpdates to RoomProvider anymore, since you’re on React 18+ already.");
    const frozenProps = useInitial({initialPresence:props.initialPresence, initialStorage:props.initialStorage, unstable_batchedUpdates:props.unstable_batchedUpdates, autoConnect:_nullishCoalesce(props.autoConnect, () => "undefined" !== typeof window)}), [{room}, setRoomLeavePair] = React4.useState(() => stableEnterRoom(roomId, {...frozenProps, autoConnect:!1}));
    React4.useEffect(() => {
      async function handleCommentEvent(message) {
        if (message.type === _core.ServerMsgCode.THREAD_DELETED) {
          store.deleteThread(message.threadId, null);
        } else {
          var info = await room.getThread(message.threadId);
          if (info.thread) {
            var {thread, inboxNotification} = info;
            info = store.getFullState().threadsDB.getEvenIfDeleted(message.threadId);
            switch(message.type) {
              case _core.ServerMsgCode.COMMENT_EDITED:
              case _core.ServerMsgCode.THREAD_METADATA_UPDATED:
              case _core.ServerMsgCode.THREAD_UPDATED:
              case _core.ServerMsgCode.COMMENT_REACTION_ADDED:
              case _core.ServerMsgCode.COMMENT_REACTION_REMOVED:
              case _core.ServerMsgCode.COMMENT_DELETED:
                if (!info) {
                  break;
                }
                store.updateThreadAndNotification(thread, inboxNotification);
                break;
              case _core.ServerMsgCode.COMMENT_CREATED:
                store.updateThreadAndNotification(thread, inboxNotification);
            }
          } else {
            store.deleteThread(message.threadId, null);
          }
        }
      }
      const {store} = getRoomExtrasForClient(client);
      return room.events.comments.subscribe(message => void handleCommentEvent(message));
    }, [client, room]);
    React4.useEffect(() => {
      const pair = stableEnterRoom(roomId, frozenProps);
      setRoomLeavePair(pair);
      const {room:room2, leave} = pair;
      frozenProps.autoConnect && room2.connect();
      return () => {
        leave();
      };
    }, [roomId, frozenProps, stableEnterRoom]);
    return React4.createElement(RoomContext.Provider, {value:room}, props.children);
  }
  function useRoom() {
    const room = React.useContext(RoomContext);
    if (null === room) {
      throw Error("RoomProvider is missing from the React tree.");
    }
    return room;
  }
  function useStatus() {
    const room = useRoom();
    return useSyncExternalStore2(room.events.status.subscribe, room.getStatus, room.getStatus);
  }
  function useStorageStatus(options) {
    return useInitial(_nullishCoalesce(_optionalChain([options, "optionalAccess", _13 => _13.smooth]), () => !1)) ? useStorageStatusSmooth() : useStorageStatusImmediate();
  }
  function useStorageStatusImmediate() {
    const room = useRoom();
    return useSyncExternalStore2(room.events.storageStatus.subscribe, room.getStorageStatus, room.getStorageStatus);
  }
  function useStorageStatusSmooth() {
    const room = useRoom(), [status, setStatus] = React4.useState(room.getStorageStatus), oldStatus = useLatest(room.getStorageStatus());
    React4.useEffect(() => {
      let timeoutId;
      const unsub = room.events.storageStatus.subscribe(newStatus => {
        "synchronizing" === oldStatus.current && "synchronized" === newStatus ? timeoutId = setTimeout(() => setStatus(newStatus), 1e3) : (clearTimeout(timeoutId), setStatus(newStatus));
      });
      return () => {
        clearTimeout(timeoutId);
        unsub();
      };
    }, [room, oldStatus]);
    return status;
  }
  function useBatch() {
    return useRoom().batch;
  }
  function useBroadcastEvent() {
    const room = useRoom();
    return React4.useCallback((event, options = {shouldQueueEventIfNotReady:!1}) => {
      room.broadcastEvent(event, options);
    }, [room]);
  }
  function useOthersListener(callback) {
    const room = useRoom(), savedCallback = useLatest(callback);
    React4.useEffect(() => room.events.others.subscribe(event => savedCallback.current(event)), [room, savedCallback]);
  }
  function useLostConnectionListener(callback) {
    const room = useRoom(), savedCallback = useLatest(callback);
    React4.useEffect(() => room.events.lostConnection.subscribe(event => savedCallback.current(event)), [room, savedCallback]);
  }
  function useErrorListener(callback) {
    const room = useRoom(), savedCallback = useLatest(callback);
    React4.useEffect(() => room.events.error.subscribe(e => savedCallback.current(e)), [room, savedCallback]);
  }
  function useEventListener(callback) {
    const room = useRoom(), savedCallback = useLatest(callback);
    React4.useEffect(() => room.events.customEvent.subscribe(eventData => {
      savedCallback.current(eventData);
    }), [room, savedCallback]);
  }
  function useHistory() {
    return useRoom().history;
  }
  function useUndo() {
    return useHistory().undo;
  }
  function useRedo() {
    return useHistory().redo;
  }
  function useCanUndo() {
    const room = useRoom(), canUndo = room.history.canUndo;
    return useSyncExternalStore2(room.events.history.subscribe, canUndo, canUndo);
  }
  function useCanRedo() {
    const room = useRoom(), canRedo = room.history.canRedo;
    return useSyncExternalStore2(room.events.history.subscribe, canRedo, canRedo);
  }
  function useSelf(maybeSelector, isEqual) {
    var room = useRoom();
    const subscribe = room.events.self.subscribe;
    room = room.getSelf;
    const selector = _nullishCoalesce(maybeSelector, () => identity2);
    maybeSelector = React4.useCallback(me => null !== me ? selector(me) : null, [selector]);
    return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, subscribe, room, alwaysNull, maybeSelector, isEqual);
  }
  function useMyPresence() {
    const room = useRoom(), getSnapshot = room.getPresence;
    return [useSyncExternalStore2(room.events.myPresence.subscribe, getSnapshot, getSnapshot), room.updatePresence];
  }
  function useUpdateMyPresence() {
    return useRoom().updatePresence;
  }
  function useOthers(selector, isEqual) {
    const room = useRoom();
    return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, room.events.others.subscribe, room.getOthers, alwaysEmptyList, _nullishCoalesce(selector, () => identity2), isEqual);
  }
  function useOthersMapped(itemSelector, itemIsEqual) {
    const wrappedSelector = React4.useCallback(others => others.map(other => [other.connectionId, itemSelector(other)]), [itemSelector]), wrappedIsEqual = React4.useCallback((a, b) => {
      const eq = _nullishCoalesce(itemIsEqual, () => Object.is);
      return a.length === b.length && a.every((atuple, index) => {
        index = b[index];
        return atuple[0] === index[0] && eq(atuple[1], index[1]);
      });
    }, [itemIsEqual]);
    return useOthers(wrappedSelector, wrappedIsEqual);
  }
  function useOthersConnectionIds() {
    return useOthers(selectorFor_useOthersConnectionIds, _client2.shallow);
  }
  function useOther(connectionId, selector, isEqual) {
    var wrappedSelector = React4.useCallback(others => {
      others = others.find(other3 => other3.connectionId === connectionId);
      return void 0 !== others ? selector(others) : NOT_FOUND;
    }, [connectionId, selector]);
    const wrappedIsEqual = React4.useCallback((prev, curr) => prev === NOT_FOUND || curr === NOT_FOUND ? prev === curr : _nullishCoalesce(isEqual, () => Object.is)(prev, curr), [isEqual]);
    wrappedSelector = useOthers(wrappedSelector, wrappedIsEqual);
    if (wrappedSelector === NOT_FOUND) {
      throw Error(`No such other user with connection id ${connectionId} exists`);
    }
    return wrappedSelector;
  }
  function useMutableStorageRoot() {
    const room = useRoom();
    return useSyncExternalStore2(room.events.storageDidLoad.subscribeOnce, room.getStorageSnapshot, alwaysNull);
  }
  function useStorageRoot() {
    return [useMutableStorageRoot()];
  }
  function useStorage(selector, isEqual) {
    const room = useRoom(), rootOrNull = useMutableStorageRoot(), wrappedSelector = React4.useCallback(rootOrNull2 => null !== rootOrNull2 ? selector(rootOrNull2) : null, [selector]), subscribe = React4.useCallback(onStoreChange => null !== rootOrNull ? room.subscribe(rootOrNull, onStoreChange, {isDeep:!0}) : noop3, [room, rootOrNull]), getSnapshot = React4.useCallback(() => null === rootOrNull ? null : rootOrNull.toImmutable(), [rootOrNull]);
    return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, subscribe, getSnapshot, alwaysNull, wrappedSelector, isEqual);
  }
  function useMutation(callback, deps) {
    const room = useRoom();
    return React4.useMemo(() => (...args) => room.batch(() => callback(makeMutationContext(room), ...args)), [room, ...deps]);
  }
  function useThreads(options = {query:{metadata:{}}}) {
    const {scrollOnLoad = !0} = options;
    var client = useClient();
    const room = useRoom(), {store, getOrCreateThreadsPollerForRoomId} = getRoomExtrasForClient(client), poller = getOrCreateThreadsPollerForRoomId(room.id);
    React4.useEffect(() => {
      store.waitUntilRoomThreadsLoaded(room.id, options.query);
    });
    React4.useEffect(() => {
      poller.inc();
      poller.pollNowIfStale();
      return () => poller.dec();
    }, [poller]);
    client = React4.useCallback(() => store.getRoomThreadsLoadingState(room.id, options.query), [store, room.id, options.query]);
    client = _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, store.subscribe, client, client, identity2, shallow2);
    useScrollToCommentOnLoadEffect(scrollOnLoad, client);
    return client;
  }
  function useCommentsErrorListener(callback) {
    const client = useClient(), savedCallback = useLatest(callback), {commentsErrorEventSource} = getRoomExtrasForClient(client);
    React4.useEffect(() => commentsErrorEventSource.subscribe(savedCallback.current), [savedCallback, commentsErrorEventSource]);
  }
  function useCreateThread() {
    const client = useClient(), room = useRoom();
    return React4.useCallback(options => {
      const body = options.body, metadata = _nullishCoalesce(options.metadata, () => ({}));
      options = options.attachments;
      const threadId = _core.createThreadId.call(void 0), commentId = _core.createCommentId.call(void 0);
      var createdAt = new Date();
      const newComment = {id:commentId, threadId, roomId:room.id, createdAt, type:"comment", userId:getCurrentUserId(room), body, reactions:[], attachments:_nullishCoalesce(options, () => [])};
      createdAt = {id:threadId, type:"thread", createdAt, updatedAt:createdAt, roomId:room.id, metadata, comments:[newComment], resolved:!1};
      const {store, onMutationFailure} = getRoomExtrasForClient(client), optimisticUpdateId = store.addOptimisticUpdate({type:"create-thread", thread:createdAt, roomId:room.id});
      options = _optionalChain([options, "optionalAccess", _14 => _14.map, "call", _15 => _15(attachment => attachment.id)]);
      room.createThread({threadId, commentId, body, metadata, attachmentIds:options}).then(thread => {
        store.createThread(optimisticUpdateId, thread);
      }, err => onMutationFailure(err, optimisticUpdateId, err2 => new CreateThreadError(err2, {roomId:room.id, threadId, commentId, body, metadata})));
      return createdAt;
    }, [client, room]);
  }
  function useDeleteThread() {
    const client = useClient(), room = useRoom();
    return React4.useCallback(threadId => {
      const {store, onMutationFailure} = getRoomExtrasForClient(client), userId = getCurrentUserId(room), existing = store.getFullState().threadsDB.get(threadId);
      if (_optionalChain([existing, "optionalAccess", _16 => _16.comments, "optionalAccess", _17 => _17[0], "optionalAccess", _18 => _18.userId]) !== userId) {
        throw Error("Only the thread creator can delete the thread");
      }
      const optimisticUpdateId = store.addOptimisticUpdate({type:"delete-thread", roomId:room.id, threadId, deletedAt:new Date()});
      room.deleteThread(threadId).then(() => {
        store.deleteThread(threadId, optimisticUpdateId);
      }, err => onMutationFailure(err, optimisticUpdateId, err2 => new DeleteThreadError(err2, {roomId:room.id, threadId})));
    }, [client, room]);
  }
  function useEditThreadMetadata() {
    const client = useClient(), room = useRoom();
    return React4.useCallback(options => {
      if (options.metadata) {
        var threadId = options.threadId, metadata = options.metadata, updatedAt = new Date(), {store, onMutationFailure} = getRoomExtrasForClient(client), optimisticUpdateId = store.addOptimisticUpdate({type:"edit-thread-metadata", metadata, threadId, updatedAt});
        room.editThreadMetadata({threadId, metadata}).then(metadata2 => store.patchThread(threadId, optimisticUpdateId, {metadata:metadata2}, updatedAt), err => onMutationFailure(err, optimisticUpdateId, error => new EditThreadMetadataError(error, {roomId:room.id, threadId, metadata})));
      }
    }, [client, room]);
  }
  function useCreateComment() {
    const client = useClient(), room = useRoom();
    return React4.useCallback(({threadId, body, attachments}) => {
      const commentId = _core.createCommentId.call(void 0), comment = {id:commentId, threadId, roomId:room.id, type:"comment", createdAt:new Date(), userId:getCurrentUserId(room), body, reactions:[], attachments:_nullishCoalesce(attachments, () => [])}, {store, onMutationFailure} = getRoomExtrasForClient(client), optimisticUpdateId = store.addOptimisticUpdate({type:"create-comment", comment});
      attachments = _optionalChain([attachments, "optionalAccess", _19 => _19.map, "call", _20 => _20(attachment => attachment.id)]);
      room.createComment({threadId, commentId, body, attachmentIds:attachments}).then(newComment => {
        store.createComment(newComment, optimisticUpdateId);
      }, err => onMutationFailure(err, optimisticUpdateId, err2 => new CreateCommentError(err2, {roomId:room.id, threadId, commentId, body})));
      return comment;
    }, [client, room]);
  }
  function useEditComment() {
    const client = useClient(), room = useRoom();
    return React4.useCallback(({threadId, commentId, body, attachments}) => {
      const editedAt = new Date(), {store, onMutationFailure} = getRoomExtrasForClient(client);
      var existing = store.getFullState().threadsDB.getEvenIfDeleted(threadId);
      if (void 0 === existing) {
        _core.console.warn(`Internal unexpected behavior. Cannot edit comment in thread "${threadId}" because the thread does not exist in the cache.`);
      } else {
        if (existing = existing.comments.find(comment2 => comment2.id === commentId), void 0 === existing || void 0 !== existing.deletedAt) {
          _core.console.warn(`Internal unexpected behavior. Cannot edit comment "${commentId}" in thread "${threadId}" because the comment does not exist in the cache.`);
        } else {
          var optimisticUpdateId = store.addOptimisticUpdate({type:"edit-comment", comment:{...existing, editedAt, body, attachments:_nullishCoalesce(attachments, () => [])}});
          attachments = _optionalChain([attachments, "optionalAccess", _21 => _21.map, "call", _22 => _22(attachment => attachment.id)]);
          room.editComment({threadId, commentId, body, attachmentIds:attachments}).then(editedComment => {
            store.editComment(threadId, optimisticUpdateId, editedComment);
          }, err => onMutationFailure(err, optimisticUpdateId, error => new EditCommentError(error, {roomId:room.id, threadId, commentId, body})));
        }
      }
    }, [client, room]);
  }
  function useDeleteComment() {
    const client = useClient(), room = useRoom();
    return React4.useCallback(({threadId, commentId}) => {
      const deletedAt = new Date(), {store, onMutationFailure} = getRoomExtrasForClient(client), optimisticUpdateId = store.addOptimisticUpdate({type:"delete-comment", threadId, commentId, deletedAt, roomId:room.id});
      room.deleteComment({threadId, commentId}).then(() => {
        store.deleteComment(threadId, optimisticUpdateId, commentId, deletedAt);
      }, err => onMutationFailure(err, optimisticUpdateId, error => new DeleteCommentError(error, {roomId:room.id, threadId, commentId})));
    }, [client, room]);
  }
  function useAddReaction() {
    const client = useClient(), room = useRoom();
    return React4.useCallback(({threadId, commentId, emoji}) => {
      const createdAt = new Date(), userId = getCurrentUserId(room), {store, onMutationFailure} = getRoomExtrasForClient(client), optimisticUpdateId = store.addOptimisticUpdate({type:"add-reaction", threadId, commentId, reaction:{emoji, userId, createdAt}});
      room.addReaction({threadId, commentId, emoji}).then(addedReaction => {
        store.addReaction(threadId, optimisticUpdateId, commentId, addedReaction, createdAt);
      }, err => onMutationFailure(err, optimisticUpdateId, error => new AddReactionError(error, {roomId:room.id, threadId, commentId, emoji})));
    }, [client, room]);
  }
  function useRemoveReaction() {
    const client = useClient(), room = useRoom();
    return React4.useCallback(({threadId, commentId, emoji}) => {
      const userId = getCurrentUserId(room), removedAt = new Date(), {store, onMutationFailure} = getRoomExtrasForClient(client), optimisticUpdateId = store.addOptimisticUpdate({type:"remove-reaction", threadId, commentId, emoji, userId, removedAt});
      room.removeReaction({threadId, commentId, emoji}).then(() => {
        store.removeReaction(threadId, optimisticUpdateId, commentId, emoji, userId, removedAt);
      }, err => onMutationFailure(err, optimisticUpdateId, error => new RemoveReactionError(error, {roomId:room.id, threadId, commentId, emoji})));
    }, [client, room]);
  }
  function useMarkThreadAsRead() {
    const client = useClient(), room = useRoom();
    return React4.useCallback(threadId => {
      const {store, onMutationFailure} = getRoomExtrasForClient(client), inboxNotification = Object.values(store.getFullState().notificationsById).find(inboxNotification2 => "thread" === inboxNotification2.kind && inboxNotification2.threadId === threadId);
      if (inboxNotification) {
        var now = new Date(), optimisticUpdateId = store.addOptimisticUpdate({type:"mark-inbox-notification-as-read", inboxNotificationId:inboxNotification.id, readAt:now});
        room.markInboxNotificationAsRead(inboxNotification.id).then(() => {
          store.updateInboxNotification(inboxNotification.id, optimisticUpdateId, inboxNotification2 => ({...inboxNotification2, readAt:now}));
        }, err => {
          onMutationFailure(err, optimisticUpdateId, error => new MarkInboxNotificationAsReadError(error, {inboxNotificationId:inboxNotification.id}));
        });
      }
    }, [client, room]);
  }
  function useMarkThreadAsResolved() {
    const client = useClient(), room = useRoom();
    return React4.useCallback(threadId => {
      const updatedAt = new Date(), {store, onMutationFailure} = getRoomExtrasForClient(client), optimisticUpdateId = store.addOptimisticUpdate({type:"mark-thread-as-resolved", threadId, updatedAt});
      room.markThreadAsResolved(threadId).then(() => {
        store.patchThread(threadId, optimisticUpdateId, {resolved:!0}, updatedAt);
      }, err => onMutationFailure(err, optimisticUpdateId, error => new MarkThreadAsResolvedError(error, {roomId:room.id, threadId})));
    }, [client, room]);
  }
  function useMarkThreadAsUnresolved() {
    const client = useClient(), room = useRoom();
    return React4.useCallback(threadId => {
      const updatedAt = new Date(), {store, onMutationFailure} = getRoomExtrasForClient(client), optimisticUpdateId = store.addOptimisticUpdate({type:"mark-thread-as-unresolved", threadId, updatedAt});
      room.markThreadAsUnresolved(threadId).then(() => {
        store.patchThread(threadId, optimisticUpdateId, {resolved:!1}, updatedAt);
      }, err => onMutationFailure(err, optimisticUpdateId, error => new MarkThreadAsUnresolvedError(error, {roomId:room.id, threadId})));
    }, [client, room]);
  }
  function useThreadSubscription(threadId) {
    var client = useClient();
    ({store:client} = getRoomExtrasForClient(client));
    const selector = React4.useCallback(state => {
      const notification = state.cleanedNotifications.find(inboxNotification => "thread" === inboxNotification.kind && inboxNotification.threadId === threadId);
      state = state.threadsDB.get(threadId);
      return void 0 === notification || void 0 === state ? {status:"not-subscribed"} : {status:"subscribed", unreadSince:notification.readAt};
    }, [threadId]);
    return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, client.subscribe, client.getFullState, client.getFullState, selector);
  }
  function useRoomNotificationSettings() {
    const updateRoomNotificationSettings = useUpdateRoomNotificationSettings();
    var client = useClient();
    const room = useRoom(), {store, getOrCreateNotificationsSettingsPollerForRoomId} = getRoomExtrasForClient(client), poller = getOrCreateNotificationsSettingsPollerForRoomId(room.id);
    React4.useEffect(() => {
      store.waitUntilRoomNotificationSettingsLoaded(room.id);
    });
    React4.useEffect(() => {
      poller.inc();
      poller.pollNowIfStale();
      return () => {
        poller.dec();
      };
    }, [poller]);
    client = React4.useCallback(() => store.getNotificationSettingsLoadingState(room.id), [store, room.id]);
    const settings = _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, store.subscribe, client, client, identity2, shallow2);
    return React4.useMemo(() => [settings, updateRoomNotificationSettings], [settings, updateRoomNotificationSettings]);
  }
  function useRoomNotificationSettingsSuspense() {
    var client = useClient();
    client = getRoomExtrasForClient(client).store;
    const room = useRoom();
    use(client.waitUntilRoomNotificationSettingsLoaded(room.id));
    const [settings, updateRoomNotificationSettings] = useRoomNotificationSettings();
    _core.assert.call(void 0, !settings.error, "Did not expect error");
    _core.assert.call(void 0, !settings.isLoading, "Did not expect loading");
    return React4.useMemo(() => [settings, updateRoomNotificationSettings], [settings, updateRoomNotificationSettings]);
  }
  function useHistoryVersionData(versionId) {
    const [state, setState] = React4.useState({isLoading:!0}), room = useRoom();
    React4.useEffect(() => {
      setState({isLoading:!0});
      (async() => {
        try {
          const buffer = await (await room[_core.kInternal].getTextVersion(versionId)).arrayBuffer(), data = new Uint8Array(buffer);
          setState({isLoading:!1, data});
        } catch (error) {
          setState({isLoading:!1, error:error instanceof Error ? error : Error("An unknown error occurred while loading this version")});
        }
      })();
    }, [room, versionId]);
    return state;
  }
  function useHistoryVersions() {
    var client = useClient();
    const room = useRoom(), {store, getOrCreateVersionsPollerForRoomId} = getRoomExtrasForClient(client), poller = getOrCreateVersionsPollerForRoomId(room.id);
    React4.useEffect(() => {
      poller.inc();
      poller.pollNowIfStale();
      return () => poller.dec();
    }, [poller]);
    client = React4.useCallback(() => store.getRoomVersionsLoadingState(room.id), [store, room.id]);
    React4.useEffect(() => {
      store.waitUntilRoomVersionsLoaded(room.id);
    });
    return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, store.subscribe, client, client, identity2, shallow2);
  }
  function useHistoryVersionsSuspense() {
    var client = useClient(), room = useRoom();
    client = getRoomExtrasForClient(client).store;
    use(client.waitUntilRoomVersionsLoaded(room.id));
    room = useHistoryVersions();
    _core.assert.call(void 0, !room.error, "Did not expect error");
    _core.assert.call(void 0, !room.isLoading, "Did not expect loading");
    return room;
  }
  function useUpdateRoomNotificationSettings() {
    const client = useClient(), room = useRoom();
    return React4.useCallback(settings => {
      const {store, onMutationFailure} = getRoomExtrasForClient(client), optimisticUpdateId = store.addOptimisticUpdate({type:"update-notification-settings", roomId:room.id, settings});
      room.updateNotificationSettings(settings).then(settings2 => {
        store.updateRoomNotificationSettings_confirmOptimisticUpdate(room.id, optimisticUpdateId, settings2);
      }, err => onMutationFailure(err, optimisticUpdateId, error => new UpdateNotificationSettingsError(error, {roomId:room.id})));
    }, [client, room]);
  }
  function ensureNotServerSide() {
    if ("undefined" === typeof window) {
      throw Error("You cannot use the Suspense version of this hook on the server side. Make sure to only call them on the client side.\nFor tips, see https://liveblocks.io/docs/api-reference/liveblocks-react#suspense-avoid-ssr");
    }
  }
  function useSuspendUntilPresenceReady() {
    ensureNotServerSide();
    const room = useRoom();
    use(room.waitUntilPresenceReady());
  }
  function useSelfSuspense(selector, isEqual) {
    useSuspendUntilPresenceReady();
    return useSelf(selector, isEqual);
  }
  function useOthersSuspense(selector, isEqual) {
    useSuspendUntilPresenceReady();
    return useOthers(selector, isEqual);
  }
  function useOthersConnectionIdsSuspense() {
    useSuspendUntilPresenceReady();
    return useOthersConnectionIds();
  }
  function useOthersMappedSuspense(itemSelector, itemIsEqual) {
    useSuspendUntilPresenceReady();
    return useOthersMapped(itemSelector, itemIsEqual);
  }
  function useOtherSuspense(connectionId, selector, isEqual) {
    useSuspendUntilPresenceReady();
    return useOther(connectionId, selector, isEqual);
  }
  function useSuspendUntilStorageReady() {
    ensureNotServerSide();
    const room = useRoom();
    use(room.waitUntilStorageReady());
  }
  function useStorageSuspense(selector, isEqual) {
    useSuspendUntilStorageReady();
    return useStorage(selector, isEqual);
  }
  function useStorageStatusSuspense(options) {
    useSuspendUntilStorageReady();
    return useStorageStatus(options);
  }
  function useThreadsSuspense(options = {query:{metadata:{}}}) {
    var client = useClient();
    const room = useRoom();
    ({store:client} = getRoomExtrasForClient(client));
    use(client.waitUntilRoomThreadsLoaded(room.id, options.query));
    options = useThreads(options);
    _core.assert.call(void 0, !options.error, "Did not expect error");
    _core.assert.call(void 0, !options.isLoading, "Did not expect loading");
    return options;
  }
  function selectorFor_useAttachmentUrl(state) {
    if (void 0 === state || _optionalChain([state, "optionalAccess", _23 => _23.isLoading])) {
      return _nullishCoalesce(state, () => ({isLoading:!0}));
    }
    if (state.error) {
      return state;
    }
    _core.assert.call(void 0, void 0 !== state.data, "Unexpected missing attachment URL");
    return {isLoading:!1, url:state.data};
  }
  function useAttachmentUrl(attachmentId) {
    var room = useRoom();
    const {attachmentUrlsStore} = room[_core.kInternal];
    room = React4.useCallback(() => attachmentUrlsStore.getState(attachmentId), [attachmentUrlsStore, attachmentId]);
    React4.useEffect(() => {
      attachmentUrlsStore.get(attachmentId);
    }, [attachmentUrlsStore, attachmentId]);
    return _withselectorjs.useSyncExternalStoreWithSelector.call(void 0, attachmentUrlsStore.subscribe, room, room, selectorFor_useAttachmentUrl, _client2.shallow);
  }
  function useAttachmentUrlSuspense(attachmentId) {
    var room = useRoom();
    const {attachmentUrlsStore} = room[_core.kInternal];
    room = React4.useCallback(() => attachmentUrlsStore.getState(attachmentId), [attachmentUrlsStore, attachmentId]);
    const attachmentUrlState = room();
    if (!attachmentUrlState || attachmentUrlState.isLoading) {
      throw attachmentUrlsStore.get(attachmentId);
    }
    if (attachmentUrlState.error) {
      throw attachmentUrlState.error;
    }
    room = useSyncExternalStore2(attachmentUrlsStore.subscribe, room, room);
    _core.assert.call(void 0, void 0 !== room, "Unexpected missing state");
    _core.assert.call(void 0, !room.isLoading, "Unexpected loading state");
    _core.assert.call(void 0, !room.error, "Unexpected error state");
    return {isLoading:!1, url:room.data, error:void 0};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  var _react = require("module$node_modules$react$index"), React = _interopRequireWildcard(_react), React4 = _interopRequireWildcard(_react), React3 = _interopRequireWildcard(_react), RoomContext = React.createContext(null), _core = require("module$node_modules$$liveblocks$core$dist$index"), _indexjs = require("module$node_modules$use_sync_external_store$shim$index"), _withselectorjs = require("module$node_modules$use_sync_external_store$shim$with_selector"), config = {NOTIFICATIONS_POLL_INTERVAL:6E4, 
  NOTIFICATIONS_MAX_STALE_TIME:5E3, ROOM_THREADS_POLL_INTERVAL:3E5, ROOM_THREADS_MAX_STALE_TIME:5E3, USER_THREADS_POLL_INTERVAL:6E4, USER_THREADS_MAX_STALE_TIME:5E3, HISTORY_VERSIONS_POLL_INTERVAL:6E4, HISTORY_VERSIONS_MAX_STALE_TIME:5E3, NOTIFICATION_SETTINGS_POLL_INTERVAL:6E4, NOTIFICATION_SETTINGS_MAX_STALE_TIME:5E3}, noop = state => state, use = promise => {
    if ("pending" === promise.status) {
      throw promise;
    }
    if ("fulfilled" === promise.status) {
      return promise.value;
    }
    if ("rejected" === promise.status) {
      throw promise.reason;
    }
    promise.status = "pending";
    promise.then(v => {
      promise.status = "fulfilled";
      promise.value = v;
    }, e => {
      promise.status = "rejected";
      promise.reason = e;
    });
    throw promise;
  };
  const node_modules$$liveblocks$react$dist$chunk_3MM4G6XB$classdecl$var5 = class {
    constructor() {
      this._asc = _core.SortedList.from([], (t1, t2) => {
        const d1 = t1.createdAt, d2 = t2.createdAt;
        return d1 < d2 ? !0 : d1 === d2 ? t1.id < t2.id : !1;
      });
      this._desc = _core.SortedList.from([], (t1, t2) => {
        const d2 = t2.updatedAt, d1 = t1.updatedAt;
        return d2 < d1 ? !0 : d2 === d1 ? t2.id < t1.id : !1;
      });
      this._byId = new Map();
      this._version = 0;
    }
    clone() {
      const newPool = new node_modules$$liveblocks$react$dist$chunk_3MM4G6XB$classdecl$var5();
      newPool._byId = new Map(this._byId);
      newPool._asc = this._asc.clone();
      newPool._desc = this._desc.clone();
      newPool._version = this._version;
      return newPool;
    }
    get version() {
      return this._version;
    }
    get(threadId) {
      threadId = this.getEvenIfDeleted(threadId);
      return _optionalChain([threadId, "optionalAccess", _2 => _2.deletedAt]) ? void 0 : threadId;
    }
    getEvenIfDeleted(threadId) {
      return this._byId.get(threadId);
    }
    upsert(thread) {
      thread = sanitizeThread(thread);
      const id = thread.id, toRemove = this._byId.get(id);
      if (toRemove) {
        if (toRemove.deletedAt) {
          return;
        }
        this._asc.remove(toRemove);
        this._desc.remove(toRemove);
      }
      thread.deletedAt || (this._asc.add(thread), this._desc.add(thread));
      this._byId.set(id, thread);
      this.touch();
    }
    upsertIfNewer(thread) {
      const existing = this.get(thread.id);
      (!existing || thread.updatedAt >= existing.updatedAt) && this.upsert(thread);
    }
    delete(threadId, deletedAt) {
      (threadId = this._byId.get(threadId)) && !threadId.deletedAt && this.upsert({...threadId, deletedAt, updatedAt:deletedAt});
    }
    findMany(roomId, query, direction) {
      direction = "desc" === direction ? this._desc : this._asc;
      const crit = [];
      void 0 !== roomId && crit.push(t => t.roomId === roomId);
      crit.push(makeThreadsFilter(query));
      return Array.from(direction.filter(t => crit.every(pred => pred(t))));
    }
    touch() {
      ++this._version;
    }
  };
  var ThreadDB = node_modules$$liveblocks$react$dist$chunk_3MM4G6XB$classdecl$var5, noop2 = Promise.resolve(), ASYNC_LOADING = Object.freeze({isLoading:!0}), PaginatedResource = class {
    constructor(fetchPage) {
      this._paginationState = this._cachedPromise = null;
      this._fetchPage = fetchPage;
      this._eventSource = _core.makeEventSource.call(void 0);
      this._pendingFetchMore = null;
      this.observable = this._eventSource.observable;
      autobind(this);
    }
    patchPaginationState(patch) {
      const state = this._paginationState;
      null !== state && (this._paginationState = {...state, ...patch}, this._eventSource.notify());
    }
    async _fetchMore() {
      const state = this._paginationState;
      if (_optionalChain([state, "optionalAccess", _3 => _3.cursor])) {
        this.patchPaginationState({isFetchingMore:!0});
        try {
          const nextCursor = await this._fetchPage(state.cursor);
          this.patchPaginationState({cursor:nextCursor, fetchMoreError:void 0, isFetchingMore:!1});
        } catch (err) {
          this.patchPaginationState({isFetchingMore:!1, fetchMoreError:err});
        }
      }
    }
    fetchMore() {
      if (null === _optionalChain([this._paginationState, "optionalAccess", _4 => _4.cursor])) {
        return noop2;
      }
      this._pendingFetchMore || (this._pendingFetchMore = this._fetchMore().finally(() => {
        this._pendingFetchMore = null;
      }));
      return this._pendingFetchMore;
    }
    get() {
      var usable = this._cachedPromise;
      if (null === usable || "pending" === usable.status) {
        return ASYNC_LOADING;
      }
      if ("rejected" === usable.status) {
        return {isLoading:!1, error:usable.reason};
      }
      usable = this._paginationState;
      return {isLoading:!1, data:{fetchMore:this.fetchMore, isFetchingMore:usable.isFetchingMore, fetchMoreError:usable.fetchMoreError, hasFetchedAll:null === usable.cursor}};
    }
    waitUntilLoaded() {
      if (this._cachedPromise) {
        return this._cachedPromise;
      }
      var initialFetcher = _core.autoRetry.call(void 0, () => this._fetchPage(void 0), 5, [5e3, 5e3, 1e4, 15e3]);
      initialFetcher = usify(initialFetcher.then(cursor => {
        this._paginationState = {cursor, isFetchingMore:!1, fetchMoreError:void 0};
      }));
      initialFetcher.then(() => this._eventSource.notify(), () => {
        this._eventSource.notify();
        setTimeout(() => {
          this._cachedPromise = null;
          this._eventSource.notify();
        }, 5e3);
      });
      return this._cachedPromise = initialFetcher;
    }
  }, SinglePageResource = class {
    constructor(fetchPage) {
      this._cachedPromise = null;
      this._fetchPage = fetchPage;
      this._eventSource = _core.makeEventSource.call(void 0);
      this.observable = this._eventSource.observable;
      autobind(this);
    }
    get() {
      const usable = this._cachedPromise;
      return null === usable || "pending" === usable.status ? ASYNC_LOADING : "rejected" === usable.status ? {isLoading:!1, error:usable.reason} : {isLoading:!1, data:void 0};
    }
    waitUntilLoaded() {
      if (this._cachedPromise) {
        return this._cachedPromise;
      }
      var initialFetcher = _core.autoRetry.call(void 0, () => this._fetchPage(), 5, [5e3, 5e3, 1e4, 15e3]);
      initialFetcher = usify(initialFetcher);
      initialFetcher.then(() => this._eventSource.notify(), () => {
        this._eventSource.notify();
        setTimeout(() => {
          this._cachedPromise = null;
          this._eventSource.notify();
        }, 5e3);
      });
      return this._cachedPromise = initialFetcher;
    }
  }, UmbrellaStore = class {
    constructor(client) {
      this._prevVersion = -1;
      this._notificationsLastRequestedAt = this._stateCached = this._prevState = null;
      this._roomThreadsLastRequestedAtByRoom = new Map();
      this._roomThreads = new Map();
      this._userThreadsLastRequestedAt = null;
      this._userThreads = new Map();
      this._roomVersions = new Map();
      this._roomVersionsLastRequestedAtByRoom = new Map();
      this._roomNotificationSettings = new Map();
      this._client = client[_core.kInternal].as();
      this._notifications = new PaginatedResource(async cursor => {
        cursor = await this._client.getInboxNotifications({cursor});
        this.updateThreadsAndNotifications(cursor.threads, cursor.inboxNotifications);
        null === this._notificationsLastRequestedAt && (this._notificationsLastRequestedAt = cursor.requestedAt);
        return cursor.nextCursor;
      });
      this._notifications.observable.subscribe(() => this._store.set(store => ({...store})));
      this._rawThreadsDB = new ThreadDB();
      this._store = _core.createStore.call(void 0, {optimisticUpdates:[], notificationsById:{}, settingsByRoomId:{}, versionsByRoomId:{}});
      autobind(this);
    }
    get() {
      const rawState = this._store.get();
      if (this._prevVersion !== this._rawThreadsDB.version || this._prevState !== rawState || null === this._stateCached) {
        this._stateCached = internalToExternalState(rawState, this._rawThreadsDB), this._prevState = rawState, this._prevVersion = this._rawThreadsDB.version;
      }
      return this._stateCached;
    }
    batch(callback) {
      return this._store.batch(callback);
    }
    getFullState() {
      return this.get();
    }
    getRoomThreadsLoadingState(roomId, query) {
      var queryKey = makeRoomThreadsQueryKey(roomId, query);
      queryKey = this._roomThreads.get(queryKey);
      if (void 0 === queryKey) {
        return ASYNC_LOADING;
      }
      queryKey = queryKey.get();
      if (queryKey.isLoading || queryKey.error) {
        return queryKey;
      }
      roomId = this.getFullState().threadsDB.findMany(roomId, _nullishCoalesce(query, () => ({})), "asc");
      query = queryKey.data;
      return {isLoading:!1, threads:roomId, hasFetchedAll:query.hasFetchedAll, isFetchingMore:query.isFetchingMore, fetchMoreError:query.fetchMoreError, fetchMore:query.fetchMore};
    }
    getUserThreadsLoadingState(query) {
      var queryKey = makeUserThreadsQueryKey(query);
      queryKey = this._userThreads.get(queryKey);
      if (void 0 === queryKey) {
        return ASYNC_LOADING;
      }
      queryKey = queryKey.get();
      if (queryKey.isLoading || queryKey.error) {
        return queryKey;
      }
      query = this.getFullState().threadsDB.findMany(void 0, _nullishCoalesce(query, () => ({})), "desc");
      queryKey = queryKey.data;
      return {isLoading:!1, threads:query, hasFetchedAll:queryKey.hasFetchedAll, isFetchingMore:queryKey.isFetchingMore, fetchMoreError:queryKey.fetchMoreError, fetchMore:queryKey.fetchMore};
    }
    getInboxNotificationsLoadingState() {
      var asyncResult = this._notifications.get();
      if (asyncResult.isLoading || asyncResult.error) {
        return asyncResult;
      }
      asyncResult = asyncResult.data;
      return {isLoading:!1, inboxNotifications:this.getFullState().cleanedNotifications, hasFetchedAll:asyncResult.hasFetchedAll, isFetchingMore:asyncResult.isFetchingMore, fetchMoreError:asyncResult.fetchMoreError, fetchMore:asyncResult.fetchMore};
    }
    getNotificationSettingsLoadingState(roomId) {
      var resource = this._roomNotificationSettings.get(`${roomId}:NOTIFICATION_SETTINGS`);
      if (void 0 === resource) {
        return ASYNC_LOADING;
      }
      resource = resource.get();
      return resource.isLoading || resource.error ? resource : {isLoading:!1, settings:_core.nn.call(void 0, this.get().settingsByRoomId[roomId])};
    }
    getRoomVersionsLoadingState(roomId) {
      var resource = this._roomVersions.get(`${roomId}-VERSIONS`);
      if (void 0 === resource) {
        return ASYNC_LOADING;
      }
      resource = resource.get();
      return resource.isLoading || resource.error ? resource : {isLoading:!1, versions:Object.values(_nullishCoalesce(this.get().versionsByRoomId[roomId], () => ({})))};
    }
    _hasOptimisticUpdates() {
      return 0 < this._store.get().optimisticUpdates.length;
    }
    subscribe(callback) {
      return this._store.subscribe(callback);
    }
    mutateThreadsDB(mutate) {
      const db = this._rawThreadsDB, old = db.version;
      mutate(db);
      old !== db.version && this._store.set(state => ({...state}));
    }
    updateInboxNotificationsCache(mapFn) {
      this._store.set(state => {
        const inboxNotifications = mapFn(state.notificationsById);
        return inboxNotifications !== state.notificationsById ? {...state, notificationsById:inboxNotifications} : state;
      });
    }
    setNotificationSettings(roomId, settings) {
      this._store.set(state => ({...state, settingsByRoomId:{...state.settingsByRoomId, [roomId]:settings}}));
    }
    updateRoomVersions(roomId, versions) {
      this._store.set(state => {
        const versionsById = Object.fromEntries(versions.map(version2 => [version2.id, version2]));
        return {...state, versionsByRoomId:{...state.versionsByRoomId, [roomId]:{..._nullishCoalesce(state.versionsByRoomId[roomId], () => ({})), ...versionsById}}};
      });
    }
    updateOptimisticUpdatesCache(mapFn) {
      this._store.set(state => ({...state, optimisticUpdates:mapFn(state.optimisticUpdates)}));
    }
    force_set(callback) {
      return this._store.set(callback);
    }
    updateInboxNotification(inboxNotificationId, optimisticUpdateId, callback) {
      this._store.batch(() => {
        this.removeOptimisticUpdate(optimisticUpdateId);
        this.updateInboxNotificationsCache(cache => {
          const existing = cache[inboxNotificationId];
          return existing ? {...cache, [inboxNotificationId]:callback(existing)} : cache;
        });
      });
    }
    updateAllInboxNotifications(optimisticUpdateId, mapFn) {
      this._store.batch(() => {
        this.removeOptimisticUpdate(optimisticUpdateId);
        this.updateInboxNotificationsCache(cache => _core.mapValues.call(void 0, cache, mapFn));
      });
    }
    deleteInboxNotification(inboxNotificationId, optimisticUpdateId) {
      this._store.batch(() => {
        this.removeOptimisticUpdate(optimisticUpdateId);
        this.updateInboxNotificationsCache(cache => {
          const {[inboxNotificationId]:removed, ...newCache} = cache;
          return void 0 === removed ? cache : newCache;
        });
      });
    }
    deleteAllInboxNotifications(optimisticUpdateId) {
      this._store.batch(() => {
        this.removeOptimisticUpdate(optimisticUpdateId);
        this.updateInboxNotificationsCache(() => ({}));
      });
    }
    createThread(optimisticUpdateId, thread) {
      this._store.batch(() => {
        this.removeOptimisticUpdate(optimisticUpdateId);
        this.mutateThreadsDB(db => db.upsert(thread));
      });
    }
    updateThread(threadId, optimisticUpdateId, callback, updatedAt) {
      this._store.batch(() => {
        null !== optimisticUpdateId && this.removeOptimisticUpdate(optimisticUpdateId);
        this.mutateThreadsDB(db => {
          const existing = db.get(threadId);
          existing && (updatedAt && existing.updatedAt > updatedAt || db.upsert(callback(existing)));
        });
      });
    }
    patchThread(threadId, optimisticUpdateId, patch, updatedAt) {
      return this.updateThread(threadId, optimisticUpdateId, thread => ({...thread, ..._core.compactObject.call(void 0, patch)}), updatedAt);
    }
    addReaction(threadId, optimisticUpdateId, commentId, reaction, createdAt) {
      this.updateThread(threadId, optimisticUpdateId, thread => applyAddReaction(thread, commentId, reaction), createdAt);
    }
    removeReaction(threadId, optimisticUpdateId, commentId, emoji, userId, removedAt) {
      this.updateThread(threadId, optimisticUpdateId, thread => applyRemoveReaction(thread, commentId, emoji, userId, removedAt), removedAt);
    }
    deleteThread(threadId, optimisticUpdateId) {
      return this.updateThread(threadId, optimisticUpdateId, thread => ({...thread, updatedAt:new Date(), deletedAt:new Date()}));
    }
    createComment(newComment, optimisticUpdateId) {
      this._store.batch(() => {
        this.removeOptimisticUpdate(optimisticUpdateId);
        const existingThread = this._rawThreadsDB.get(newComment.threadId);
        existingThread && (this.mutateThreadsDB(db => db.upsert(applyUpsertComment(existingThread, newComment))), this.updateInboxNotificationsCache(cache => {
          const existingNotification = Object.values(cache).find(notification => "thread" === notification.kind && notification.threadId === newComment.threadId);
          return existingNotification ? {...cache, [existingNotification.id]:{...existingNotification, notifiedAt:newComment.createdAt, readAt:newComment.createdAt}} : cache;
        }));
      });
    }
    editComment(threadId, optimisticUpdateId, editedComment) {
      return this.updateThread(threadId, optimisticUpdateId, thread => applyUpsertComment(thread, editedComment));
    }
    deleteComment(threadId, optimisticUpdateId, commentId, deletedAt) {
      return this.updateThread(threadId, optimisticUpdateId, thread => applyDeleteComment(thread, commentId, deletedAt), deletedAt);
    }
    updateThreadAndNotification(thread, inboxNotification) {
      this._store.batch(() => {
        this.mutateThreadsDB(db => db.upsertIfNewer(thread));
        void 0 !== inboxNotification && this.updateInboxNotificationsCache(cache => ({...cache, [inboxNotification.id]:inboxNotification}));
      });
    }
    updateThreadsAndNotifications(threads, inboxNotifications, deletedThreads = [], deletedInboxNotifications = []) {
      this._store.batch(() => {
        this.mutateThreadsDB(db => applyThreadDeltaUpdates(db, {newThreads:threads, deletedThreads}));
        this.updateInboxNotificationsCache(cache => applyNotificationsUpdates(cache, {newInboxNotifications:inboxNotifications, deletedNotifications:deletedInboxNotifications}));
      });
    }
    updateRoomNotificationSettings_confirmOptimisticUpdate(roomId, optimisticUpdateId, settings) {
      this._store.batch(() => {
        this.removeOptimisticUpdate(optimisticUpdateId);
        this.setNotificationSettings(roomId, settings);
      });
    }
    addOptimisticUpdate(optimisticUpdate) {
      const id = _core.nanoid.call(void 0), newUpdate = {...optimisticUpdate, id};
      this.updateOptimisticUpdatesCache(cache => [...cache, newUpdate]);
      return id;
    }
    removeOptimisticUpdate(optimisticUpdateId) {
      this.updateOptimisticUpdatesCache(cache => cache.filter(ou => ou.id !== optimisticUpdateId));
    }
    async fetchNotificationsDeltaUpdate(signal) {
      const lastRequestedAt = this._notificationsLastRequestedAt;
      null !== lastRequestedAt && (signal = await this._client.getInboxNotificationsSince({since:lastRequestedAt, signal}), lastRequestedAt < signal.requestedAt && (this._notificationsLastRequestedAt = signal.requestedAt), this.updateThreadsAndNotifications(signal.threads.updated, signal.inboxNotifications.updated, signal.threads.deleted, signal.inboxNotifications.deleted));
    }
    waitUntilNotificationsLoaded() {
      return this._notifications.waitUntilLoaded();
    }
    waitUntilRoomThreadsLoaded(roomId, query) {
      const threadsFetcher = async cursor => {
        var room = this._client.getRoom(roomId);
        if (null === room) {
          throw new (0, _core.HttpError)(`Room '${roomId}' is not available on client`, 479);
        }
        cursor = await room.getThreads({cursor, query});
        this.updateThreadsAndNotifications(cursor.threads, cursor.inboxNotifications);
        room = this._roomThreadsLastRequestedAtByRoom.get(roomId);
        (void 0 === room || room > cursor.requestedAt) && this._roomThreadsLastRequestedAtByRoom.set(roomId, cursor.requestedAt);
        return cursor.nextCursor;
      }, queryKey = makeRoomThreadsQueryKey(roomId, query);
      let paginatedResource = this._roomThreads.get(queryKey);
      void 0 === paginatedResource && (paginatedResource = new PaginatedResource(threadsFetcher));
      paginatedResource.observable.subscribe(() => this._store.set(store => ({...store})));
      this._roomThreads.set(queryKey, paginatedResource);
      return paginatedResource.waitUntilLoaded();
    }
    async fetchRoomThreadsDeltaUpdate(roomId, signal) {
      const lastRequestedAt = this._roomThreadsLastRequestedAtByRoom.get(roomId);
      void 0 !== lastRequestedAt && (signal = await _core.nn.call(void 0, this._client.getRoom(roomId), `Room with id ${roomId} is not available on client`).getThreadsSince({since:lastRequestedAt, signal}), this.updateThreadsAndNotifications(signal.threads.updated, signal.inboxNotifications.updated, signal.threads.deleted, signal.inboxNotifications.deleted), lastRequestedAt < signal.requestedAt && this._roomThreadsLastRequestedAtByRoom.set(roomId, signal.requestedAt));
    }
    waitUntilUserThreadsLoaded(query) {
      const queryKey = makeUserThreadsQueryKey(query), threadsFetcher = async cursor => {
        cursor = await this._client[_core.kInternal].getUserThreads_experimental({cursor, query});
        this.updateThreadsAndNotifications(cursor.threads, cursor.inboxNotifications);
        null === this._userThreadsLastRequestedAt && (this._userThreadsLastRequestedAt = cursor.requestedAt);
        return cursor.nextCursor;
      };
      let paginatedResource = this._userThreads.get(queryKey);
      void 0 === paginatedResource && (paginatedResource = new PaginatedResource(threadsFetcher));
      paginatedResource.observable.subscribe(() => this._store.set(store => ({...store})));
      this._userThreads.set(queryKey, paginatedResource);
      return paginatedResource.waitUntilLoaded();
    }
    async fetchUserThreadsDeltaUpdate(signal) {
      const lastRequestedAt = this._userThreadsLastRequestedAt;
      null !== lastRequestedAt && (signal = await this._client[_core.kInternal].getUserThreadsSince_experimental({since:lastRequestedAt, signal}), lastRequestedAt < signal.requestedAt && (this._notificationsLastRequestedAt = signal.requestedAt), this.updateThreadsAndNotifications(signal.threads.updated, signal.inboxNotifications.updated, signal.threads.deleted, signal.inboxNotifications.deleted));
    }
    waitUntilRoomVersionsLoaded(roomId) {
      const queryKey = `${roomId}-VERSIONS`;
      let resource = this._roomVersions.get(queryKey);
      void 0 === resource && (resource = new SinglePageResource(async() => {
        var room = this._client.getRoom(roomId);
        if (null === room) {
          throw new (0, _core.HttpError)(`Room '${roomId}' is not available on client`, 479);
        }
        room = await room[_core.kInternal].listTextVersions();
        this.updateRoomVersions(roomId, room.versions);
        const lastRequestedAt = this._roomVersionsLastRequestedAtByRoom.get(roomId);
        (void 0 === lastRequestedAt || lastRequestedAt > room.requestedAt) && this._roomVersionsLastRequestedAtByRoom.set(roomId, room.requestedAt);
      }));
      resource.observable.subscribe(() => this._store.set(store => ({...store})));
      this._roomVersions.set(queryKey, resource);
      return resource.waitUntilLoaded();
    }
    async fetchRoomVersionsDeltaUpdate(roomId, signal) {
      const lastRequestedAt = this._roomVersionsLastRequestedAtByRoom.get(roomId);
      void 0 !== lastRequestedAt && (signal = await _core.nn.call(void 0, this._client.getRoom(roomId), `Room with id ${roomId} is not available on client`)[_core.kInternal].listTextVersionsSince({since:lastRequestedAt, signal}), this.updateRoomVersions(roomId, signal.versions), lastRequestedAt < signal.requestedAt && this._roomVersionsLastRequestedAtByRoom.set(roomId, signal.requestedAt));
    }
    waitUntilRoomNotificationSettingsLoaded(roomId) {
      const queryKey = `${roomId}:NOTIFICATION_SETTINGS`;
      let resource = this._roomNotificationSettings.get(queryKey);
      void 0 === resource && (resource = new SinglePageResource(async() => {
        var room = this._client.getRoom(roomId);
        if (null === room) {
          throw new (0, _core.HttpError)(`Room '${roomId}' is not available on client`, 479);
        }
        room = await room.getNotificationSettings();
        this.setNotificationSettings(roomId, room);
      }));
      resource.observable.subscribe(() => this._store.set(store => ({...store})));
      this._roomNotificationSettings.set(queryKey, resource);
      return resource.waitUntilLoaded();
    }
    async refreshRoomNotificationSettings(roomId, signal) {
      signal = await _core.nn.call(void 0, this._client.getRoom(roomId), `Room with id ${roomId} is not available on client`).getNotificationSettings({signal});
      this.setNotificationSettings(roomId, signal);
    }
  }, ClientContext = _react.createContext.call(void 0, null), _umbrellaStores = new WeakMap(), _extras = new WeakMap(), _bundles = new WeakMap(), _useUserThreads_experimental = useUserThreads_experimental, _useUserThreadsSuspense_experimental = useUserThreadsSuspense_experimental, CreateThreadError = class extends Error {
    constructor(cause, context) {
      super("Create thread failed.");
      this.cause = cause;
      this.context = context;
      this.name = "CreateThreadError";
    }
  }, DeleteThreadError = class extends Error {
    constructor(cause, context) {
      super("Delete thread failed.");
      this.cause = cause;
      this.context = context;
      this.name = "DeleteThreadError";
    }
  }, EditThreadMetadataError = class extends Error {
    constructor(cause, context) {
      super("Edit thread metadata failed.");
      this.cause = cause;
      this.context = context;
      this.name = "EditThreadMetadataError";
    }
  }, MarkThreadAsResolvedError = class extends Error {
    constructor(cause, context) {
      super("Mark thread as resolved failed.");
      this.cause = cause;
      this.context = context;
      this.name = "MarkThreadAsResolvedError";
    }
  }, MarkThreadAsUnresolvedError = class extends Error {
    constructor(cause, context) {
      super("Mark thread as unresolved failed.");
      this.cause = cause;
      this.context = context;
      this.name = "MarkThreadAsUnresolvedError";
    }
  }, CreateCommentError = class extends Error {
    constructor(cause, context) {
      super("Create comment failed.");
      this.cause = cause;
      this.context = context;
      this.name = "CreateCommentError";
    }
  }, EditCommentError = class extends Error {
    constructor(cause, context) {
      super("Edit comment failed.");
      this.cause = cause;
      this.context = context;
      this.name = "EditCommentError";
    }
  }, DeleteCommentError = class extends Error {
    constructor(cause, context) {
      super("Delete comment failed.");
      this.cause = cause;
      this.context = context;
      this.name = "DeleteCommentError";
    }
  }, AddReactionError = class extends Error {
    constructor(cause, context) {
      super("Add reaction failed.");
      this.cause = cause;
      this.context = context;
      this.name = "AddReactionError";
    }
  }, RemoveReactionError = class extends Error {
    constructor(cause, context) {
      super("Remove reaction failed.");
      this.cause = cause;
      this.context = context;
      this.name = "RemoveReactionError";
    }
  }, MarkInboxNotificationAsReadError = class extends Error {
    constructor(cause, context) {
      super("Mark inbox notification as read failed.");
      this.cause = cause;
      this.context = context;
      this.name = "MarkInboxNotificationAsReadError";
    }
  }, UpdateNotificationSettingsError = class extends Error {
    constructor(cause, context) {
      super("Update notification settings failed.");
      this.cause = cause;
      this.context = context;
      this.name = "UpdateNotificationSettingsError";
    }
  }, _client2 = require("module$node_modules$$liveblocks$client$dist$index"), noop3 = () => {
  }, identity2 = x => x, STABLE_EMPTY_LIST = Object.freeze([]), _extras2 = new WeakMap(), _bundles2 = new WeakMap(), NOT_FOUND = Symbol(), _RoomProvider = RoomProvider, _useBroadcastEvent = useBroadcastEvent, _useOthersListener = useOthersListener, _useRoom = useRoom, _useAddReaction = useAddReaction, _useMutation = useMutation, _useCreateThread = useCreateThread, _useDeleteThread = useDeleteThread, _useEditThreadMetadata = useEditThreadMetadata, _useEventListener = useEventListener, _useMyPresence = 
  useMyPresence, _useOthersMapped = useOthersMapped, _useOthersMappedSuspense = useOthersMappedSuspense, _useThreads = useThreads, _useThreadsSuspense = useThreadsSuspense, _useRoomNotificationSettings = useRoomNotificationSettings, _useRoomNotificationSettingsSuspense = useRoomNotificationSettingsSuspense, _useHistoryVersions = useHistoryVersions, _useHistoryVersionsSuspense = useHistoryVersionsSuspense, _useOther = useOther, _useOtherSuspense = useOtherSuspense, _useStorage = useStorage, _useStorageSuspense = 
  useStorageSuspense, _useStorageRoot = useStorageRoot, _useUpdateMyPresence = useUpdateMyPresence;
  exports.RoomContext = RoomContext;
  exports.ClientContext = ClientContext;
  exports.getUmbrellaStoreForClient = getUmbrellaStoreForClient;
  exports.useClient = useClient;
  exports.LiveblocksProvider = function(props) {
    const {children, ...o} = props, options = {publicApiKey:useInitial(o.publicApiKey), throttle:useInitial(o.throttle), lostConnectionTimeout:useInitial(o.lostConnectionTimeout), backgroundKeepAliveTimeout:useInitial(o.backgroundKeepAliveTimeout), polyfills:useInitial(o.polyfills), unstable_fallbackToHTTP:useInitial(o.unstable_fallbackToHTTP), unstable_streamData:useInitial(o.unstable_streamData), authEndpoint:useInitialUnlessFunction(o.authEndpoint), resolveMentionSuggestions:useInitialUnlessFunction(o.resolveMentionSuggestions), 
    resolveUsers:useInitialUnlessFunction(o.resolveUsers), resolveRoomsInfo:useInitialUnlessFunction(o.resolveRoomsInfo), baseUrl:useInitial(o.baseUrl), enableDebugLogging:useInitial(o.enableDebugLogging)};
    props = _react.useMemo.call(void 0, () => _core.createClient.call(void 0, options), []);
    return React.default.createElement(LiveblocksProviderWithClient, {client:props}, children);
  };
  exports.createLiveblocksContext = function(client) {
    let bundle = _bundles.get(client);
    bundle || (bundle = makeLiveblocksContextBundle(client), _bundles.set(client, bundle));
    return bundle;
  };
  exports.useInboxNotifications = function() {
    return useInboxNotifications_withClient(useClient(), identity, _core.shallow);
  };
  exports.useInboxNotificationsSuspense = function() {
    return useInboxNotificationsSuspense_withClient(useClient());
  };
  exports.useMarkAllInboxNotificationsAsRead = function() {
    return useMarkAllInboxNotificationsAsRead_withClient(useClient());
  };
  exports.useMarkInboxNotificationAsRead = function() {
    return useMarkInboxNotificationAsRead_withClient(useClient());
  };
  exports.useDeleteAllInboxNotifications = function() {
    return useDeleteAllInboxNotifications_withClient(useClient());
  };
  exports.useDeleteInboxNotification = function() {
    return useDeleteInboxNotification_withClient(useClient());
  };
  exports.useUnreadInboxNotificationsCount = function() {
    return useInboxNotifications_withClient(useClient(), selectorFor_useUnreadInboxNotificationsCount, _core.shallow);
  };
  exports.useUnreadInboxNotificationsCountSuspense = function() {
    return useUnreadInboxNotificationsCountSuspense_withClient(useClient());
  };
  exports.useRoomInfo = function(roomId) {
    return useRoomInfo_withClient(useClient(), roomId);
  };
  exports.useRoomInfoSuspense = function(roomId) {
    return useRoomInfoSuspense_withClient(useClient(), roomId);
  };
  exports._useInboxNotificationThread = function(inboxNotificationId) {
    return useInboxNotificationThread_withClient(useClient(), inboxNotificationId);
  };
  exports._useUser = function(userId) {
    const client = useClient();
    return useUser_withClient(client, userId);
  };
  exports._useUserSuspense = function(userId) {
    const client = useClient();
    return useUserSuspense_withClient(client, userId);
  };
  exports._useUserThreads_experimental = _useUserThreads_experimental;
  exports._useUserThreadsSuspense_experimental = _useUserThreadsSuspense_experimental;
  exports.CreateThreadError = CreateThreadError;
  exports.useStatus = useStatus;
  exports.useStorageStatus = useStorageStatus;
  exports.useBatch = useBatch;
  exports.useLostConnectionListener = useLostConnectionListener;
  exports.useErrorListener = useErrorListener;
  exports.useHistory = useHistory;
  exports.useUndo = useUndo;
  exports.useRedo = useRedo;
  exports.useCanUndo = useCanUndo;
  exports.useCanRedo = useCanRedo;
  exports.useOthersConnectionIds = useOthersConnectionIds;
  exports.useCommentsErrorListener = useCommentsErrorListener;
  exports.useCreateComment = useCreateComment;
  exports.useEditComment = useEditComment;
  exports.useDeleteComment = useDeleteComment;
  exports.useRemoveReaction = useRemoveReaction;
  exports.useMarkThreadAsRead = useMarkThreadAsRead;
  exports.useMarkThreadAsResolved = useMarkThreadAsResolved;
  exports.useMarkThreadAsUnresolved = useMarkThreadAsUnresolved;
  exports.useThreadSubscription = useThreadSubscription;
  exports.useHistoryVersionData = useHistoryVersionData;
  exports.useUpdateRoomNotificationSettings = useUpdateRoomNotificationSettings;
  exports.useOthersConnectionIdsSuspense = useOthersConnectionIdsSuspense;
  exports.useStorageStatusSuspense = useStorageStatusSuspense;
  exports.useAttachmentUrl = useAttachmentUrl;
  exports.useAttachmentUrlSuspense = useAttachmentUrlSuspense;
  exports.createRoomContext = function(client) {
    let bundle = _bundles2.get(client);
    bundle || (bundle = makeRoomContextBundle(client), _bundles2.set(client, bundle));
    return bundle;
  };
  exports._RoomProvider = _RoomProvider;
  exports._useBroadcastEvent = _useBroadcastEvent;
  exports._useOthersListener = _useOthersListener;
  exports._useRoom = _useRoom;
  exports._useIsInsideRoom = useIsInsideRoom;
  exports._useAddReaction = _useAddReaction;
  exports._useMutation = _useMutation;
  exports._useCreateThread = _useCreateThread;
  exports._useDeleteThread = _useDeleteThread;
  exports._useEditThreadMetadata = _useEditThreadMetadata;
  exports._useEventListener = _useEventListener;
  exports._useMyPresence = _useMyPresence;
  exports._useOthersMapped = _useOthersMapped;
  exports._useOthersMappedSuspense = _useOthersMappedSuspense;
  exports._useThreads = _useThreads;
  exports._useThreadsSuspense = _useThreadsSuspense;
  exports._useRoomNotificationSettings = _useRoomNotificationSettings;
  exports._useRoomNotificationSettingsSuspense = _useRoomNotificationSettingsSuspense;
  exports._useHistoryVersions = _useHistoryVersions;
  exports._useHistoryVersionsSuspense = _useHistoryVersionsSuspense;
  exports._useOther = _useOther;
  exports._useOthers = function(...args) {
    return useOthers(...args);
  };
  exports._useOtherSuspense = _useOtherSuspense;
  exports._useOthersSuspense = function(...args) {
    return useOthersSuspense(...args);
  };
  exports._useStorage = _useStorage;
  exports._useStorageSuspense = _useStorageSuspense;
  exports._useSelf = function(...args) {
    return useSelf(...args);
  };
  exports._useSelfSuspense = function(...args) {
    return useSelfSuspense(...args);
  };
  exports._useStorageRoot = _useStorageRoot;
  exports._useUpdateMyPresence = _useUpdateMyPresence;
};

//# sourceMappingURL=module$node_modules$$liveblocks$react$dist$chunk_3MM4G6XB.js.map
