shadow$provide.module$node_modules$$liveblocks$core$dist$index = function(global, require, module, exports) {
  function _nullishCoalesce(lhs, rhsFn) {
    return null != lhs ? lhs : rhsFn();
  }
  function _optionalChain(ops) {
    let lastAccessLHS = void 0, value = ops[0], i = 1;
    for (; i < ops.length;) {
      const op = ops[i], fn = ops[i + 1];
      i += 2;
      if (("optionalAccess" === op || "optionalCall" === op) && null == value) {
        return;
      }
      if ("access" === op || "optionalAccess" === op) {
        lastAccessLHS = value, value = fn(value);
      } else if ("call" === op || "optionalCall" === op) {
        value = fn((...args) => value.call(lastAccessLHS, ...args)), lastAccessLHS = void 0;
      }
    }
    return value;
  }
  function detectDupes(pkgName, pkgVersion, pkgFormat) {
    const pkgId = Symbol.for(pkgName);
    pkgFormat = pkgFormat ? `${pkgVersion || "dev"} (${pkgFormat})` : pkgVersion || "dev";
    if (!g[pkgId]) {
      g[pkgId] = pkgFormat;
    } else if (g[pkgId] !== pkgFormat) {
      throw pkgName = ["Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See https://liveblocks.io/docs/errors/dupes \n\nConflicts:", `- ${pkgName} ${g[pkgId]} (already loaded)`, `- ${pkgName} ${pkgFormat} (trying to load this now)`].join("\n"), Error(pkgName);
    }
    if (pkgVersion && "2.10.2" !== pkgVersion) {
      throw pkgName = ["Cross-linked versions of Liveblocks found, which will cause issues! See https://liveblocks.io/docs/errors/cross-linked \n\nConflicts:\n- @liveblocks/core is at 2.10.2", `- ${pkgName} is at ${pkgVersion}`, "\nAlways upgrade all Liveblocks packages to the same version number."].join("\n"), Error(pkgName);
    }
  }
  function assertNever(_value, errmsg) {
    throw Error(errmsg);
  }
  function assert(condition, errmsg) {
    if (!condition) {
      throw condition = Error(errmsg), condition.name = "Assertion failure", condition;
    }
  }
  function nn(value, errmsg = "Expected value to be non-nullable") {
    assert(null !== value && void 0 !== value, errmsg);
    return value;
  }
  function controlledPromise() {
    let resolve, reject;
    return [new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    }), resolve, reject];
  }
  function Promise_withResolvers() {
    const [promise, resolve, reject] = controlledPromise();
    return {promise, resolve, reject};
  }
  function makeEventSource() {
    function subscribe(callback) {
      _observers.add(callback);
      return () => _observers.delete(callback);
    }
    function subscribeOnce(callback) {
      _onetimeObservers.add(callback);
      return () => _onetimeObservers.delete(callback);
    }
    async function waitUntil(predicate) {
      let unsub;
      return (new Promise(res => {
        unsub = subscribe(event => {
          (void 0 === predicate || predicate(event)) && res(event);
        });
      })).finally(() => _optionalChain([unsub, "optionalCall", _2 => _2()]));
    }
    function notify(event) {
      _onetimeObservers.forEach(callback => callback(event));
      _onetimeObservers.clear();
      _observers.forEach(callback => callback(event));
    }
    const _onetimeObservers = new Set(), _observers = new Set();
    let _buffer = null;
    return {notify:function(event) {
      null !== _buffer ? _buffer.push(event) : notify(event);
    }, subscribe, subscribeOnce, _forceClear:function() {
      _onetimeObservers.clear();
      _observers.clear();
    }, count:function() {
      return _onetimeObservers.size + _observers.size;
    }, waitUntil, pause:function() {
      _buffer = [];
    }, unpause:function() {
      if (null !== _buffer) {
        for (const event of _buffer) {
          notify(event);
        }
        _buffer = null;
      }
    }, observable:{subscribe, subscribeOnce, waitUntil}};
  }
  function wrap(method) {
    return "undefined" === typeof window ? console[method] : (message, ...args) => console[method]("%cLiveblocks", "background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;", message, ...args);
  }
  function wrapWithTitle(method) {
    return "undefined" === typeof window ? console[method] : (title, message, ...args) => console[method](`%cLiveblocks%c ${title}`, "background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;", "font-weight:600", message, ...args);
  }
  function distance(state1, state2) {
    if (state1 === state2) {
      return [0, 0];
    }
    state1 = state1.split(".");
    state2 = state2.split(".");
    const minLen = Math.min(state1.length, state2.length);
    let shared = 0;
    for (; shared < minLen && state1[shared] === state2[shared]; shared++) {
    }
    return [state1.length - shared, state2.length - shared];
  }
  function patterns(targetState, levels) {
    const parts = targetState.split(".");
    if (1 > levels || levels > parts.length + 1) {
      throw Error("Invalid number of levels");
    }
    const result = [];
    levels > parts.length && result.push("*");
    for (levels = parts.length - levels + 1; levels < parts.length; levels++) {
      const slice = parts.slice(0, levels);
      0 < slice.length && result.push(slice.join(".") + ".*");
    }
    result.push(targetState);
    return result;
  }
  function raise(msg) {
    throw Error(msg);
  }
  function isPlainObject(blob) {
    return null !== blob && "object" === typeof blob && "[object Object]" === Object.prototype.toString.call(blob);
  }
  function tryParseJson(rawMessage) {
    try {
      return JSON.parse(rawMessage);
    } catch (e) {
    }
  }
  function deepClone(value) {
    return JSON.parse(JSON.stringify(value));
  }
  function b64decode(b64value) {
    try {
      const formattedValue = b64value.replace(/-/g, "+").replace(/_/g, "/");
      return decodeURIComponent(atob(formattedValue).split("").map(function(c) {
        return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(""));
    } catch (err) {
      return atob(b64value);
    }
  }
  function compact(items) {
    return items.filter(item => null !== item && void 0 !== item);
  }
  function compactObject(obj) {
    const newObj = {...obj};
    Object.keys(obj).forEach(k => {
      void 0 === newObj[k] && delete newObj[k];
    });
    return newObj;
  }
  function wait(millis) {
    return new Promise(res => setTimeout(res, millis));
  }
  async function withTimeout(promise, millis, errmsg) {
    let timerID;
    const timer$ = new Promise((_, reject) => {
      timerID = setTimeout(() => {
        reject(Error(errmsg));
      }, millis);
    });
    return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));
  }
  function memoizeOnSuccess(factoryFn) {
    let cached = null;
    return () => {
      null === cached && (cached = factoryFn().catch(err => {
        setTimeout(() => {
          cached = null;
        }, 5e3);
        throw err;
      }));
      return cached;
    };
  }
  function shouldDisconnect(code) {
    return 4999 === code || 4e3 <= code && 4100 > code;
  }
  function shouldRetryWithoutReauth(code) {
    return 1013 === code || 4200 <= code && 4300 > code;
  }
  function toNewConnectionStatus(machine) {
    const state = machine.currentState;
    switch(state) {
      case "@ok.connected":
      case "@ok.awaiting-pong":
        return "connected";
      case "@idle.initial":
        return "initial";
      case "@auth.busy":
      case "@auth.backoff":
      case "@connecting.busy":
      case "@connecting.backoff":
      case "@idle.zombie":
        return 0 < machine.context.successCount ? "reconnecting" : "connecting";
      case "@idle.failed":
        return "disconnected";
      default:
        return assertNever(state, "Unknown state");
    }
  }
  function nextBackoffDelay(currentDelay, delays) {
    return _nullishCoalesce(delays.find(delay => delay > currentDelay), () => delays[delays.length - 1]);
  }
  function increaseBackoffDelay(context) {
    context.patch({backoffDelay:nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)});
  }
  function increaseBackoffDelayAggressively(context) {
    context.patch({backoffDelay:nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)});
  }
  function resetSuccessCount(context) {
    context.patch({successCount:0});
  }
  function log(level, message) {
    const logger = 2 === level ? error2 : 1 === level ? warn : () => {
    };
    return () => {
      logger(message);
    };
  }
  function logPrematureErrorOrCloseEvent(e) {
    return ctx => {
      e instanceof Error ? warn(`${"Connection to Liveblocks websocket server"} could not be established. ${String(e)}`) : warn(e instanceof Error || "close" !== e.type ? "Connection to Liveblocks websocket server could not be established." : `${"Connection to Liveblocks websocket server"} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.`);
    };
  }
  function logCloseEvent(event) {
    const details = [`code: ${event.code}`];
    event.reason && details.push(`reason: ${event.reason}`);
    return ctx => {
      warn(`Connection to Liveblocks websocket server closed (${details.join(", ")}). Retrying in ${ctx.backoffDelay}ms.`);
    };
  }
  function enableTracing(machine) {
    function log2(...args) {
      warn(`${(((new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`, ...args);
    }
    const start = (new Date()).getTime(), unsubs = [machine.events.didReceiveEvent.subscribe(e => log2(`Event ${e.type}`)), machine.events.willTransition.subscribe(({from, to}) => log2("Transitioning", from, "â†’", to)), machine.events.didIgnoreEvent.subscribe(e => log2("Ignored event", e.type, e, "(current state won't handle it)"))];
    return () => {
      for (const unsub of unsubs) {
        unsub();
      }
    };
  }
  function defineConnectivityEvents(machine) {
    const statusDidChange = makeEventSource(), didConnect = makeEventSource(), didDisconnect = makeEventSource();
    let lastStatus = null;
    const unsubscribe = machine.events.didEnterState.subscribe(() => {
      const currStatus = toNewConnectionStatus(machine);
      currStatus !== lastStatus && statusDidChange.notify(currStatus);
      "connected" === lastStatus && "connected" !== currStatus ? didDisconnect.notify() : "connected" !== lastStatus && "connected" === currStatus && didConnect.notify();
      lastStatus = currStatus;
    });
    return {statusDidChange:statusDidChange.observable, didConnect:didConnect.observable, didDisconnect:didDisconnect.observable, unsubscribe};
  }
  function createConnectionStateMachine(delegates, options) {
    function fireErrorEvent(errmsg, errcode) {
      return () => {
        const err = new LiveblocksError(errmsg, errcode);
        onLiveblocksError.notify(err);
      };
    }
    function teardownSocket(socket) {
      socket && (socket.removeEventListener("error", onSocketError), socket.removeEventListener("close", onSocketClose), socket.removeEventListener("message", onSocketMessage), socket.close());
    }
    const onMessage = makeEventSource();
    onMessage.pause();
    const onLiveblocksError = makeEventSource(), machine = (new FSM({successCount:0, authValue:null, socket:null, backoffDelay:RESET_DELAY})).addState("@idle.initial").addState("@idle.failed").addState("@idle.zombie").addState("@auth.busy").addState("@auth.backoff").addState("@connecting.busy").addState("@connecting.backoff").addState("@ok.connected").addState("@ok.awaiting-pong");
    machine.addTransitions("*", {RECONNECT:{target:"@auth.backoff", effect:[increaseBackoffDelay, resetSuccessCount]}, DISCONNECT:"@idle.initial"});
    machine.onEnter("@idle.*", resetSuccessCount).addTransitions("@idle.*", {CONNECT:(_, ctx) => null !== ctx.authValue ? "@connecting.busy" : "@auth.busy"});
    machine.addTransitions("@auth.backoff", {NAVIGATOR_ONLINE:{target:"@auth.busy", effect:assign({backoffDelay:RESET_DELAY})}}).addTimedTransition("@auth.backoff", ctx => ctx.backoffDelay, "@auth.busy").onEnterAsync("@auth.busy", () => withTimeout(delegates.authenticate(), 1e4, "Timed out during auth"), okEvent => ({target:"@connecting.busy", effect:assign({authValue:okEvent.data})}), failedEvent => failedEvent.reason instanceof StopRetrying ? {target:"@idle.failed", effect:[log(2, failedEvent.reason.message), 
    fireErrorEvent(failedEvent.reason.message, -1)]} : {target:"@auth.backoff", effect:[increaseBackoffDelay, log(2, `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`)]});
    const onSocketError = event => machine.send({type:"EXPLICIT_SOCKET_ERROR", event}), onSocketClose = event => machine.send({type:"EXPLICIT_SOCKET_CLOSE", event}), onSocketMessage = event => "pong" === event.data ? machine.send({type:"PONG"}) : onMessage.notify(event);
    machine.addTransitions("@connecting.backoff", {NAVIGATOR_ONLINE:{target:"@connecting.busy", effect:assign({backoffDelay:RESET_DELAY})}}).addTimedTransition("@connecting.backoff", ctx => ctx.backoffDelay, "@connecting.busy").onEnterAsync("@connecting.busy", async(ctx, signal) => {
      let capturedPrematureEvent = null, unconfirmedSocket = null;
      const connect$ = new Promise((resolve, rej) => {
        function reject(event) {
          capturedPrematureEvent = event;
          socket.removeEventListener("message", onSocketMessage);
          rej(event);
        }
        function waitForActorId(event) {
          event = tryParseJson(event.data);
          104 === _optionalChain([event, "optionalAccess", _13 => _13.type]) && didReceiveActor();
        }
        if (null === ctx.authValue) {
          throw Error("No auth authValue");
        }
        const socket = delegates.createSocket(ctx.authValue);
        unconfirmedSocket = socket;
        const [actor$, didReceiveActor] = controlledPromise();
        options.waitForActorId || didReceiveActor();
        socket.addEventListener("message", onSocketMessage);
        options.waitForActorId && socket.addEventListener("message", waitForActorId);
        socket.addEventListener("error", reject);
        socket.addEventListener("close", reject);
        socket.addEventListener("open", () => {
          socket.addEventListener("error", onSocketError);
          socket.addEventListener("close", onSocketClose);
          const unsub = () => {
            socket.removeEventListener("error", reject);
            socket.removeEventListener("close", reject);
            socket.removeEventListener("message", waitForActorId);
          };
          actor$.then(() => {
            resolve([socket, unsub]);
          });
        });
      });
      return withTimeout(connect$, 1e4, "Timed out during websocket connection").then(([socket, unsub]) => {
        unsub();
        if (signal.aborted) {
          throw Error("Aborted");
        }
        if (capturedPrematureEvent) {
          throw capturedPrematureEvent;
        }
        return socket;
      }).catch(e => {
        teardownSocket(unconfirmedSocket);
        throw e;
      });
    }, okEvent => ({target:"@ok.connected", effect:assign({socket:okEvent.data, backoffDelay:RESET_DELAY})}), failure => {
      failure = failure.reason;
      if (failure instanceof StopRetrying) {
        return {target:"@idle.failed", effect:[log(2, failure.message), fireErrorEvent(failure.message, -1)]};
      }
      if (!(failure instanceof Error) && "close" === failure.type) {
        if (4109 === failure.code) {
          return "@auth.busy";
        }
        if (shouldRetryWithoutReauth(failure.code)) {
          return {target:"@connecting.backoff", effect:[increaseBackoffDelayAggressively, logPrematureErrorOrCloseEvent(failure)]};
        }
        if (shouldDisconnect(failure.code)) {
          return {target:"@idle.failed", effect:[log(2, failure.reason), fireErrorEvent(failure.reason, failure.code)]};
        }
      }
      return {target:"@auth.backoff", effect:[increaseBackoffDelay, logPrematureErrorOrCloseEvent(failure)]};
    });
    const sendHeartbeat = {target:"@ok.awaiting-pong", effect:ctx => {
      _optionalChain([ctx, "access", _14 => _14.socket, "optionalAccess", _15 => _15.send, "call", _16 => _16("ping")]);
    }};
    var maybeHeartbeat = () => "hidden" === _optionalChain(["undefined" !== typeof document ? document : void 0, "optionalAccess", _17 => _17.visibilityState]) && delegates.canZombie() ? "@idle.zombie" : sendHeartbeat;
    machine.addTimedTransition("@ok.connected", 3e4, maybeHeartbeat).addTransitions("@ok.connected", {NAVIGATOR_OFFLINE:maybeHeartbeat, WINDOW_GOT_FOCUS:sendHeartbeat});
    machine.addTransitions("@idle.zombie", {WINDOW_GOT_FOCUS:"@connecting.backoff"});
    machine.onEnter("@ok.*", ctx => {
      ctx.patch({successCount:ctx.successCount + 1});
      const timerID = setTimeout(onMessage.unpause, 0);
      return ctx2 => {
        teardownSocket(ctx2.socket);
        ctx2.patch({socket:null});
        clearTimeout(timerID);
        onMessage.pause();
      };
    }).addTransitions("@ok.awaiting-pong", {PONG:"@ok.connected"}).addTimedTransition("@ok.awaiting-pong", 2e3, {target:"@connecting.busy", effect:log(1, "Received no pong from server, assume implicit connection loss.")}).addTransitions("@ok.*", {EXPLICIT_SOCKET_ERROR:(_, context) => 1 === _optionalChain([context, "access", _18 => _18.socket, "optionalAccess", _19 => _19.readyState]) ? null : {target:"@connecting.backoff", effect:increaseBackoffDelay}, EXPLICIT_SOCKET_CLOSE:e => {
      if (shouldDisconnect(e.event.code)) {
        return {target:"@idle.failed", effect:[logPermanentClose, fireErrorEvent(e.event.reason, e.event.code)]};
      }
      var code = e.event.code;
      return 4100 <= code && 4200 > code ? 4109 === e.event.code ? "@auth.busy" : {target:"@auth.backoff", effect:[increaseBackoffDelay, logCloseEvent(e.event)]} : shouldRetryWithoutReauth(e.event.code) ? {target:"@connecting.backoff", effect:[increaseBackoffDelayAggressively, logCloseEvent(e.event)]} : {target:"@connecting.backoff", effect:[increaseBackoffDelay, logCloseEvent(e.event)]};
    }});
    if ("undefined" !== typeof document) {
      const doc = "undefined" !== typeof document ? document : void 0, win = "undefined" !== typeof window ? window : void 0, root = _nullishCoalesce(win, () => doc);
      machine.onEnter("*", ctx => {
        function onNetworkOffline() {
          machine.send({type:"NAVIGATOR_OFFLINE"});
        }
        function onNetworkBackOnline() {
          machine.send({type:"NAVIGATOR_ONLINE"});
        }
        function onVisibilityChange() {
          "visible" === _optionalChain([doc, "optionalAccess", _20 => _20.visibilityState]) && machine.send({type:"WINDOW_GOT_FOCUS"});
        }
        _optionalChain([win, "optionalAccess", _21 => _21.addEventListener, "call", _22 => _22("online", onNetworkBackOnline)]);
        _optionalChain([win, "optionalAccess", _23 => _23.addEventListener, "call", _24 => _24("offline", onNetworkOffline)]);
        _optionalChain([root, "optionalAccess", _25 => _25.addEventListener, "call", _26 => _26("visibilitychange", onVisibilityChange)]);
        return () => {
          _optionalChain([root, "optionalAccess", _27 => _27.removeEventListener, "call", _28 => _28("visibilitychange", onVisibilityChange)]);
          _optionalChain([win, "optionalAccess", _29 => _29.removeEventListener, "call", _30 => _30("online", onNetworkBackOnline)]);
          _optionalChain([win, "optionalAccess", _31 => _31.removeEventListener, "call", _32 => _32("offline", onNetworkOffline)]);
          teardownSocket(ctx.socket);
        };
      });
    }
    maybeHeartbeat = [];
    const {statusDidChange, didConnect, didDisconnect, unsubscribe} = defineConnectivityEvents(machine);
    maybeHeartbeat.push(unsubscribe);
    options.enableDebugLogging && maybeHeartbeat.push(enableTracing(machine));
    machine.start();
    return {machine, cleanups:maybeHeartbeat, events:{statusDidChange, didConnect, didDisconnect, onMessage:onMessage.observable, onLiveblocksError:onLiveblocksError.observable}};
  }
  function canComment(scopes) {
    return scopes.includes("comments:write") || scopes.includes("room:write");
  }
  function parseAuthToken(rawTokenString) {
    var tokenParts = rawTokenString.split(".");
    if (3 !== tokenParts.length) {
      throw Error("Authentication error: invalid JWT token");
    }
    tokenParts = tryParseJson(b64decode(tokenParts[1]));
    if (!tokenParts || !isPlainObject(tokenParts) || "acc" !== tokenParts.k && "id" !== tokenParts.k && "sec-legacy" !== tokenParts.k) {
      throw Error("Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback");
    }
    return {raw:rawTokenString, parsed:tokenParts};
  }
  function createAuthManager(authOptions) {
    function hasCorrespondingScopes(requestedScope, scopes) {
      return "comments:read" === requestedScope ? scopes.includes("comments:read") || scopes.includes("comments:write") || scopes.includes("room:read") || scopes.includes("room:write") : "room:read" === requestedScope ? scopes.includes("room:read") || scopes.includes("room:write") : !1;
    }
    function getCachedToken(requestOptions) {
      const now = Math.ceil(Date.now() / 1e3);
      for (let i = tokens.length - 1; 0 <= i; i--) {
        const token = tokens[i];
        if (expiryTimes[i] <= now) {
          tokens.splice(i, 1), expiryTimes.splice(i, 1);
        } else {
          if ("id" === token.parsed.k) {
            return token;
          }
          if ("acc" === token.parsed.k) {
            if (!requestOptions.roomId && 0 === Object.entries(token.parsed.perms).length) {
              return token;
            }
            for (const [resource, scopes] of Object.entries(token.parsed.perms)) {
              if (!requestOptions.roomId) {
                if (resource.includes("*") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {
                  return token;
                }
              } else if (resource.includes("*") && requestOptions.roomId.startsWith(resource.replace("*", "")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {
                return token;
              }
            }
          }
        }
      }
    }
    async function makeAuthRequest(options) {
      var fetcher = _nullishCoalesce(_optionalChain([authOptions, "access", _36 => _36.polyfills, "optionalAccess", _37 => _37.fetch]), () => "undefined" === typeof window ? void 0 : window.fetch);
      if ("private" === authentication.type) {
        if (void 0 === fetcher) {
          throw new StopRetrying("To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.");
        }
        options = await fetchAuthEndpoint(fetcher, authentication.url, {room:options.roomId});
        options = parseAuthToken(options.token);
        if (seenTokens.has(options.raw)) {
          throw new StopRetrying("The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.");
        }
        return options;
      }
      if ("custom" === authentication.type) {
        if ((options = await authentication.callback(options.roomId)) && "object" === typeof options) {
          if ("string" === typeof options.token) {
            return parseAuthToken(options.token);
          }
          if ("string" === typeof options.error) {
            fetcher = `Authentication failed: ${"reason" in options && "string" === typeof options.reason ? options.reason : "Forbidden"}`;
            if ("forbidden" === options.error) {
              throw new StopRetrying(fetcher);
            }
            throw Error(fetcher);
          }
        }
        throw Error('Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: "..." }');
      }
      throw Error("Unexpected authentication type. Must be private or custom.");
    }
    const authentication = prepareAuthentication(authOptions), seenTokens = new Set(), tokens = [], expiryTimes = [], requestPromises = new Map();
    return {reset:function() {
      seenTokens.clear();
      tokens.length = 0;
      expiryTimes.length = 0;
      requestPromises.clear();
    }, getAuthValue:async function(requestOptions) {
      if ("public" === authentication.type) {
        return {type:"public", publicApiKey:authentication.publicApiKey};
      }
      var cachedToken = getCachedToken(requestOptions);
      if (void 0 !== cachedToken) {
        return {type:"secret", token:cachedToken};
      }
      requestOptions.roomId ? (cachedToken = requestPromises.get(requestOptions.roomId), void 0 === cachedToken && (cachedToken = makeAuthRequest(requestOptions), requestPromises.set(requestOptions.roomId, cachedToken))) : (cachedToken = requestPromises.get("liveblocks-user-token"), void 0 === cachedToken && (cachedToken = makeAuthRequest(requestOptions), requestPromises.set("liveblocks-user-token", cachedToken)));
      try {
        const token = await cachedToken, expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - 30;
        seenTokens.add(token.raw);
        "sec-legacy" !== token.parsed.k && (tokens.push(token), expiryTimes.push(expiresAt));
        return {type:"secret", token};
      } finally {
        requestOptions.roomId ? requestPromises.delete(requestOptions.roomId) : requestPromises.delete("liveblocks-user-token");
      }
    }};
  }
  function prepareAuthentication(authOptions) {
    const {publicApiKey, authEndpoint} = authOptions;
    if (void 0 !== authEndpoint && void 0 !== publicApiKey) {
      throw Error("You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient");
    }
    if ("string" === typeof publicApiKey) {
      if (publicApiKey.startsWith("sk_")) {
        throw Error("Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey");
      }
      if (!publicApiKey.startsWith("pk_")) {
        throw Error("Invalid key. Please use the public key format: pk_\x3cpublic key\x3e. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey");
      }
      return {type:"public", publicApiKey};
    }
    if ("string" === typeof authEndpoint) {
      return {type:"private", url:authEndpoint};
    }
    if ("function" === typeof authEndpoint) {
      return {type:"custom", callback:authEndpoint};
    }
    if (void 0 !== authEndpoint) {
      throw Error("The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint");
    }
    throw Error("Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient");
  }
  async function fetchAuthEndpoint(fetch, endpoint, body) {
    fetch = await fetch(endpoint, {method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify(body)});
    if (!fetch.ok) {
      endpoint = `${(await fetch.text()).trim() || "reason not provided in auth response"} (${fetch.status} returned by POST ${endpoint})`;
      if (401 === fetch.status || 403 === fetch.status) {
        throw new StopRetrying(`Unauthorized: ${endpoint}`);
      }
      throw Error(`Failed to authenticate: ${endpoint}`);
    }
    let data;
    try {
      data = await fetch.json();
    } catch (er) {
      throw Error(`Expected a JSON response when doing a POST request on "${endpoint}". ${String(er)}`);
    }
    if (!isPlainObject(data) || "string" !== typeof data.token) {
      throw Error(`Expected a JSON response of the form \`{ token: "..." }\` when doing a POST request on "${endpoint}", but got ${JSON.stringify(data)}`);
    }
    ({token:endpoint} = data);
    return {token:endpoint};
  }
  function sendToPanel(message, options) {
    "undefined" !== typeof window && (message = {...message, source:"liveblocks-devtools-client"}, (_optionalChain([options, "optionalAccess", _38 => _38.force]) || _bridgeActive) && window.postMessage(message, "*"));
  }
  function setupDevTools(getAllRooms) {
    "undefined" === typeof window || _devtoolsSetupHasRun || (_devtoolsSetupHasRun = !0, onMessageFromPanel.subscribe(msg => {
      switch(msg.msg) {
        case "connect":
          _bridgeActive = !0;
          for (const roomId of getAllRooms()) {
            sendToPanel({msg:"room::available", roomId, clientVersion:"2.10.2"});
          }
      }
    }), sendToPanel({msg:"wake-up-devtools"}, {force:!0}));
  }
  function stopSyncStream(roomId) {
    const unsubs = _nullishCoalesce(unsubsByRoomId.get(roomId), () => []);
    unsubsByRoomId.delete(roomId);
    for (const unsub of unsubs) {
      unsub();
    }
  }
  function startSyncStream(room) {
    stopSyncStream(room.id);
    fullSync(room);
    unsubsByRoomId.set(room.id, [room.events.status.subscribe(() => {
      sendToPanel({msg:"room::sync::partial", roomId:room.id, status:room.getStatus()});
    }), room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)), room.events.storageBatch.subscribe(() => partialSyncStorage(room)), room.events.self.subscribe(() => {
      const me = room[kInternal].getSelf_forDevTools();
      me && sendToPanel({msg:"room::sync::partial", roomId:room.id, me});
    }), room.events.others.subscribe(() => {
      const others = room[kInternal].getOthers_forDevTools();
      others && sendToPanel({msg:"room::sync::partial", roomId:room.id, others});
    }), room.events.ydoc.subscribe(update => {
      sendToPanel({msg:"room::sync::ydoc", roomId:room.id, update});
    }), room.events.customEvent.subscribe(eventData => {
      sendToPanel({msg:"room::events::custom-event", roomId:room.id, event:{type:"CustomEvent", id:`event-${loadedAt}-${eventCounter++}`, key:"Event", connectionId:eventData.connectionId, payload:eventData.event}});
    })]);
  }
  function partialSyncStorage(room) {
    const root = room.getStorageSnapshot();
    root && sendToPanel({msg:"room::sync::partial", roomId:room.id, storage:root.toTreeNode("root").payload});
  }
  function fullSync(room) {
    const root = room.getStorageSnapshot(), me = room[kInternal].getSelf_forDevTools(), others = room[kInternal].getOthers_forDevTools();
    room.fetchYDoc("");
    sendToPanel({msg:"room::sync::full", roomId:room.id, status:room.getStatus(), storage:_nullishCoalesce(_optionalChain([root, "optionalAccess", _41 => _41.toTreeNode, "call", _42 => _42("root"), "access", _43 => _43.payload]), () => null), me, others});
  }
  function stopRoomChannelListener(roomId) {
    const listener = roomChannelListeners.get(roomId);
    roomChannelListeners.delete(roomId);
    listener && listener();
  }
  function linkDevTools(roomId, room) {
    "undefined" !== typeof window && (sendToPanel({msg:"room::available", roomId, clientVersion:"2.10.2"}), stopRoomChannelListener(roomId), roomChannelListeners.set(roomId, onMessageFromPanel.subscribe(msg => {
      switch(msg.msg) {
        case "room::subscribe":
          msg.roomId === roomId && startSyncStream(room);
          break;
        case "room::unsubscribe":
          msg.roomId === roomId && stopSyncStream(roomId);
      }
    })));
  }
  function stringify(object, ...args) {
    if ("object" !== typeof object || null === object || Array.isArray(object)) {
      return JSON.stringify(object, ...args);
    }
    const sortedObject = Object.keys(object).sort().reduce((sortedObject2, key) => {
      sortedObject2[key] = object[key];
      return sortedObject2;
    }, {});
    return JSON.stringify(sortedObject, ...args);
  }
  function createBatchStore(batch) {
    const cache = new Map(), eventSource2 = makeEventSource();
    return {...eventSource2.observable, get:async function(input) {
      const cacheKey = stringify(input);
      if (!cache.has(cacheKey)) {
        try {
          cache.set(cacheKey, {isLoading:!0});
          eventSource2.notify();
          const result = await batch.get(input);
          cache.set(cacheKey, {isLoading:!1, data:result});
          eventSource2.notify();
        } catch (error3) {
          cache.set(cacheKey, {isLoading:!1, error:error3}), eventSource2.notify();
        }
      }
    }, getState:function(input) {
      input = stringify(input);
      return cache.get(input);
    }, invalidate:function(inputs) {
      if (Array.isArray(inputs)) {
        for (const input of inputs) {
          cache.delete(stringify(input));
        }
      } else {
        cache.clear();
      }
      eventSource2.notify();
    }, _cacheKeys:function() {
      return [...cache.keys()];
    }};
  }
  function createStore(initialState) {
    function notify() {
      if (dirty) {
        dirty = !1;
        for (const subscriber of subscribers) {
          subscriber(state);
        }
      }
    }
    let notifyImmediately = !0, dirty = !1, state = initialState;
    const subscribers = new Set();
    return {get:function() {
      return state;
    }, set:function(callback) {
      const oldState = state;
      callback = callback(oldState);
      callback !== oldState && (state = callback, dirty = !0);
      notifyImmediately && notify();
    }, batch:function(cb) {
      if (!1 === notifyImmediately) {
        return cb();
      }
      notifyImmediately = !1;
      try {
        cb();
      } finally {
        notifyImmediately = !0, notify();
      }
    }, subscribe:function(callback) {
      subscribers.add(callback);
      return () => {
        subscribers.delete(callback);
      };
    }};
  }
  function convertToCommentData(data) {
    const editedAt = data.editedAt ? new Date(data.editedAt) : void 0, createdAt = new Date(data.createdAt), reactions = data.reactions.map(reaction => ({...reaction, createdAt:new Date(reaction.createdAt)}));
    return data.body ? {...data, reactions, createdAt, editedAt} : {...data, reactions, createdAt, editedAt, deletedAt:new Date(data.deletedAt)};
  }
  function convertToThreadData(data) {
    const createdAt = new Date(data.createdAt), updatedAt = new Date(data.updatedAt), comments = data.comments.map(comment => convertToCommentData(comment));
    return {...data, createdAt, updatedAt, comments};
  }
  function convertToCommentUserReaction(data) {
    return {...data, createdAt:new Date(data.createdAt)};
  }
  function convertToInboxNotificationData(data) {
    const notifiedAt = new Date(data.notifiedAt), readAt = data.readAt ? new Date(data.readAt) : null;
    if ("activities" in data) {
      const activities = data.activities.map(activity => ({...activity, createdAt:new Date(activity.createdAt)}));
      return {...data, notifiedAt, readAt, activities};
    }
    return {...data, notifiedAt, readAt};
  }
  function convertToThreadDeleteInfo(data) {
    return {...data, deletedAt:new Date(data.deletedAt)};
  }
  function convertToInboxNotificationDeleteInfo(data) {
    return {...data, deletedAt:new Date(data.deletedAt)};
  }
  async function autoRetry(promiseFn, maxTries, backoff, shouldStopRetrying = DONT_RETRY_4XX) {
    const fallbackBackoff = 0 < backoff.length ? backoff[backoff.length - 1] : 0;
    let attempt = 0;
    for (;;) {
      attempt++;
      try {
        return await promiseFn();
      } catch (err) {
        if (shouldStopRetrying(err)) {
          throw err;
        }
        if (attempt >= maxTries) {
          throw Error(`Failed after ${maxTries} attempts: ${String(err)}`);
        }
      }
      const delay = _nullishCoalesce(backoff[attempt - 1], () => fallbackBackoff);
      warn(`Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`);
      await wait(delay);
    }
  }
  function urljoin(baseUrl, path, params) {
    baseUrl = new URL(path, baseUrl);
    if (void 0 !== params) {
      if (!(params instanceof URLSearchParams)) {
        path = new URLSearchParams();
        for (const [key, value] of Object.entries(params)) {
          void 0 !== value && null !== value && path.set(key, value.toString());
        }
        params = path;
      }
      baseUrl.search = params.toString();
    }
    return baseUrl.toString();
  }
  function url(strings, ...values) {
    return strings.reduce((result, str, i) => result + encodeURIComponent(_nullishCoalesce(values[i - 1], () => "")) + str);
  }
  function getBearerTokenFromAuthValue(authValue) {
    return "public" === authValue.type ? authValue.publicApiKey : authValue.token.raw;
  }
  function createNotificationsApi({baseUrl, authManager, currentUserIdStore, fetchPolyfill}) {
    async function markInboxNotificationsAsRead(inboxNotificationIds) {
      await httpClient.post(url`/v2/c/inbox-notifications/read`, {inboxNotificationIds});
    }
    const httpClient = new HttpClient(baseUrl, fetchPolyfill, async function() {
      const authValue = await authManager.getAuthValue({requestedScope:"comments:read"});
      if ("secret" === authValue.type && "acc" === authValue.token.parsed.k) {
        const userId = authValue.token.parsed.uid;
        currentUserIdStore.set(() => userId);
      }
      return authValue;
    }), batchedMarkInboxNotificationsAsRead = new Batch(async batchedInboxNotificationIds => {
      batchedInboxNotificationIds = batchedInboxNotificationIds.flat();
      await markInboxNotificationsAsRead(batchedInboxNotificationIds);
      return batchedInboxNotificationIds;
    }, {delay:50});
    return {getInboxNotifications:async function(options) {
      options = await httpClient.get(url`/v2/c/inbox-notifications`, {cursor:_optionalChain([options, "optionalAccess", _46 => _46.cursor]), limit:50});
      return {inboxNotifications:options.inboxNotifications.map(convertToInboxNotificationData), threads:options.threads.map(convertToThreadData), nextCursor:options.meta.nextCursor, requestedAt:new Date(options.meta.requestedAt)};
    }, getInboxNotificationsSince:async function(options) {
      options = await httpClient.get(url`/v2/c/inbox-notifications/delta`, {since:options.since.toISOString()}, {signal:_optionalChain([options, "optionalAccess", _47 => _47.signal])});
      return {inboxNotifications:{updated:options.inboxNotifications.map(convertToInboxNotificationData), deleted:options.deletedInboxNotifications.map(convertToInboxNotificationDeleteInfo)}, threads:{updated:options.threads.map(convertToThreadData), deleted:options.deletedThreads.map(convertToThreadDeleteInfo)}, requestedAt:new Date(options.meta.requestedAt)};
    }, getUnreadInboxNotificationsCount:async function() {
      const {count} = await httpClient.get(url`/v2/c/inbox-notifications/count`);
      return count;
    }, markAllInboxNotificationsAsRead:async function() {
      await httpClient.post(url`/v2/c/inbox-notifications/read`, {inboxNotificationIds:"all"});
    }, markInboxNotificationAsRead:async function(inboxNotificationId) {
      await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);
    }, deleteAllInboxNotifications:async function() {
      await httpClient.delete(url`/v2/c/inbox-notifications`);
    }, deleteInboxNotification:async function(inboxNotificationId) {
      await httpClient.delete(url`/v2/c/inbox-notifications/${inboxNotificationId}`);
    }, getUserThreads_experimental:async function(options) {
      let query;
      _optionalChain([options, "optionalAccess", _48 => _48.query]) && (query = objectToQuery(options.query));
      options = await httpClient.get(url`/v2/c/threads`, {cursor:options.cursor, query, limit:50});
      return {threads:options.threads.map(convertToThreadData), inboxNotifications:options.inboxNotifications.map(convertToInboxNotificationData), nextCursor:options.meta.nextCursor, requestedAt:new Date(options.meta.requestedAt)};
    }, getUserThreadsSince_experimental:async function(options) {
      options = await httpClient.get(url`/v2/c/threads/delta`, {since:options.since.toISOString()}, {signal:options.signal});
      return {threads:{updated:options.threads.map(convertToThreadData), deleted:options.deletedThreads.map(convertToThreadDeleteInfo)}, inboxNotifications:{updated:options.inboxNotifications.map(convertToInboxNotificationData), deleted:options.deletedInboxNotifications.map(convertToInboxNotificationDeleteInfo)}, requestedAt:new Date(options.meta.requestedAt)};
    }};
  }
  function nthDigit(n) {
    const code = 32 + (0 > n ? 95 + n : n);
    if (32 > code || 126 < code) {
      throw Error(`Invalid n value: ${n}`);
    }
    return String.fromCharCode(code);
  }
  function makePosition(x, y) {
    if (void 0 !== x && void 0 !== y) {
      if (x < y) {
        y = _between(x, y);
      } else if (x > y) {
        y = _between(y, x);
      } else {
        throw Error("Cannot compute value between two equal positions");
      }
      return y;
    }
    if (void 0 !== x) {
      a: {
        for (y = 0; y <= x.length - 1; y++) {
          var code$jscomp$0 = x.charCodeAt(y);
          if (!(126 <= code$jscomp$0)) {
            y = x.substring(0, y) + String.fromCharCode(code$jscomp$0 + 1);
            break a;
          }
        }
        y = x + ONE;
      }
      return y;
    }
    if (void 0 !== y) {
      a: {
        x = y.length - 1;
        for (code$jscomp$0 = 0; code$jscomp$0 <= x; code$jscomp$0++) {
          const code = y.charCodeAt(code$jscomp$0);
          if (!(32 >= code)) {
            y = code$jscomp$0 === x ? 33 === code ? y.substring(0, code$jscomp$0) + ZERO_NINE : y.substring(0, code$jscomp$0) + String.fromCharCode(code - 1) : y.substring(0, code$jscomp$0 + 1);
            break a;
          }
        }
        y = ONE;
      }
    } else {
      y = ONE;
    }
    return y;
  }
  function _between(lo, hi) {
    var index = 0;
    const loLen = lo.length, hiLen = hi.length;
    for (;;) {
      var loCode = index < loLen ? lo.charCodeAt(index) : 32, hiCode = index < hiLen ? hi.charCodeAt(index) : 126;
      if (loCode === hiCode) {
        index++;
      } else {
        return 1 === hiCode - loCode ? (hiCode = index + 1, loCode = lo.substring(0, hiCode), loCode.length < hiCode && (loCode += ZERO.repeat(hiCode - loCode.length)), lo = lo.substring(hiCode), loCode + _between(lo, "")) : (index < lo.length ? lo.substring(0, index) : lo + ZERO.repeat(index - lo.length)) + String.fromCharCode(hiCode + loCode >> 1);
      }
    }
  }
  function isPos(str) {
    if ("" === str) {
      return !1;
    }
    const lastIdx = str.length - 1;
    var last = str.charCodeAt(lastIdx);
    if (33 > last || 126 < last) {
      return !1;
    }
    for (last = 0; last < lastIdx; last++) {
      const code = str.charCodeAt(last);
      if (32 > code || 126 < code) {
        return !1;
      }
    }
    return !0;
  }
  function asPos(str) {
    if (!isPos(str)) {
      const codes = [];
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        codes.push(32 > code ? 32 : 126 < code ? 126 : code);
      }
      for (; 0 < codes.length && 32 === codes[codes.length - 1];) {
        codes.length--;
      }
      str = 0 < codes.length ? String.fromCharCode(...codes) : ONE;
    }
    return str;
  }
  function HasParent(node, key, pos = asPos(key)) {
    return Object.freeze({type:"HasParent", node, key, pos});
  }
  function Orphaned(oldKey, oldPos = asPos(oldKey)) {
    return Object.freeze({type:"Orphaned", oldKey, oldPos});
  }
  function isRootCrdt(crdt) {
    return 0 === crdt.type && !isChildCrdt(crdt);
  }
  function isChildCrdt(crdt) {
    return void 0 !== crdt.parentId && void 0 !== crdt.parentKey;
  }
  function compareNodePosition(itemA, itemB) {
    itemA = itemA._parentPos;
    itemB = itemB._parentPos;
    return itemA === itemB ? 0 : itemA < itemB ? -1 : 1;
  }
  function makeUpdate(liveList, deltaUpdates) {
    return {node:liveList, type:"LiveList", updates:deltaUpdates};
  }
  function setDelta(index, item) {
    return {index, type:"set", item:item instanceof LiveRegister ? item.data : item};
  }
  function deleteDelta(index, deletedNode) {
    return {type:"delete", index, deletedItem:deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode};
  }
  function insertDelta(index, item) {
    return {index, type:"insert", item:item instanceof LiveRegister ? item.data : item};
  }
  function moveDelta(previousIndex, index, item) {
    return {type:"move", index, item:item instanceof LiveRegister ? item.data : item, previousIndex};
  }
  function HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {
    return ops.map((op, index) => 0 === index ? {...op, intent:"set", deletedId} : op);
  }
  function creationOpToLson(op) {
    switch(op.type) {
      case 8:
        return op.data;
      case 4:
        return new LiveObject(op.data);
      case 7:
        return new LiveMap();
      case 2:
        return new LiveList([]);
      default:
        return assertNever(op, "Unknown creation Op");
    }
  }
  function isSameNodeOrChildOf(node, parent) {
    return node === parent ? !0 : "HasParent" === node.parent.type ? isSameNodeOrChildOf(node.parent.node, parent) : !1;
  }
  function deserialize([id, crdt], parentToChildren, pool) {
    switch(crdt.type) {
      case 0:
        return LiveObject._deserialize([id, crdt], parentToChildren, pool);
      case 1:
        return LiveList._deserialize([id, crdt], parentToChildren, pool);
      case 2:
        return LiveMap._deserialize([id, crdt], parentToChildren, pool);
      case 3:
        return LiveRegister._deserialize([id, crdt], parentToChildren, pool);
      default:
        throw Error("Unexpected CRDT type");
    }
  }
  function deserializeToLson([id, crdt], parentToChildren, pool) {
    switch(crdt.type) {
      case 0:
        return LiveObject._deserialize([id, crdt], parentToChildren, pool);
      case 1:
        return LiveList._deserialize([id, crdt], parentToChildren, pool);
      case 2:
        return LiveMap._deserialize([id, crdt], parentToChildren, pool);
      case 3:
        return crdt.data;
      default:
        throw Error("Unexpected CRDT type");
    }
  }
  function isLiveStructure(value) {
    return value instanceof LiveList || value instanceof LiveMap || value instanceof LiveObject;
  }
  function isLiveNode(value) {
    return isLiveStructure(value) || value instanceof LiveRegister;
  }
  function cloneLson(value) {
    return void 0 === value ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);
  }
  function liveNodeToLson(obj) {
    return obj instanceof LiveRegister ? obj.data : obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject ? obj : assertNever(obj, "Unknown AbstractCrdt");
  }
  function lsonToLiveNode(value) {
    return value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList ? value : new LiveRegister(value);
  }
  function getTreesDiffOperations(currentItems, newItems) {
    const ops = [];
    currentItems.forEach((_, id) => {
      newItems.get(id) || ops.push({type:5, id});
    });
    newItems.forEach((crdt, id) => {
      const currentCrdt = currentItems.get(id);
      if (currentCrdt) {
        0 !== crdt.type || 0 === currentCrdt.type && JSON.stringify(crdt.data) === JSON.stringify(currentCrdt.data) || ops.push({type:3, id, data:crdt.data}), crdt.parentKey !== currentCrdt.parentKey && ops.push({type:1, id, parentKey:nn(crdt.parentKey, "Parent key must not be missing")});
      } else {
        switch(crdt.type) {
          case 3:
            ops.push({type:8, id, parentId:crdt.parentId, parentKey:crdt.parentKey, data:crdt.data});
            break;
          case 1:
            ops.push({type:2, id, parentId:crdt.parentId, parentKey:crdt.parentKey});
            break;
          case 0:
            if (void 0 === crdt.parentId || void 0 === crdt.parentKey) {
              throw Error("Internal error. Cannot serialize storage root into an operation");
            }
            ops.push({type:4, id, parentId:crdt.parentId, parentKey:crdt.parentKey, data:crdt.data});
            break;
          case 2:
            ops.push({type:7, id, parentId:crdt.parentId, parentKey:crdt.parentKey});
        }
      }
    });
    return ops;
  }
  function mergeStorageUpdates(first, second) {
    if (void 0 === first) {
      return second;
    }
    if ("LiveObject" === first.type && "LiveObject" === second.type) {
      first = first.updates;
      for (const [key, value] of Object.entries(second.updates)) {
        first[key] = value;
      }
      return {...second, updates:first};
    }
    if ("LiveMap" === first.type && "LiveMap" === second.type) {
      first = first.updates;
      for (const [key, value] of Object.entries(second.updates)) {
        first[key] = value;
      }
      return {...second, updates:first};
    }
    return "LiveList" === first.type && "LiveList" === second.type ? {...second, updates:first.updates.concat(second.updates)} : second;
  }
  function isPlain(value) {
    const type = typeof value;
    return void 0 === value || null === value || "string" === type || "boolean" === type || "number" === type || Array.isArray(value) || isPlainObject(value);
  }
  function findNonSerializableValue(value, path = "") {
    if (!isPlain) {
      return {path:path || "root", value};
    }
    if ("object" !== typeof value || null === value) {
      return !1;
    }
    for (const [key, nestedValue] of Object.entries(value)) {
      value = path ? path + "." + key : key;
      if (!isPlain(nestedValue)) {
        return {path:value, value:nestedValue};
      }
      if ("object" === typeof nestedValue && (value = findNonSerializableValue(nestedValue, value))) {
        return value;
      }
    }
    return !1;
  }
  function chunk(array, size) {
    const chunks = [];
    for (let i = 0, j = array.length; i < j; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
  function createThreadId() {
    return `${"th"}_${nanoid()}`;
  }
  function createCommentId() {
    return `${"cm"}_${nanoid()}`;
  }
  function captureStackTrace(msg, traceRoot) {
    msg = {name:msg};
    if ("function" === typeof Error.captureStackTrace) {
      return Error.captureStackTrace(msg, traceRoot), msg.stack;
    }
  }
  function isJsonScalar(data) {
    return null === data || "string" === typeof data || "number" === typeof data || "boolean" === typeof data;
  }
  function isJsonArray(data) {
    return Array.isArray(data);
  }
  function isJsonObject(data) {
    return !isJsonScalar(data) && !isJsonArray(data);
  }
  function objectToQuery(obj) {
    let filterList = [];
    const keyValuePairs = [], keyValuePairsWithOperator = [], indexedKeys = [];
    Object.entries(obj).forEach(([key, value]) => {
      if (!identifierRegex.test(key)) {
        throw Error("Key must only contain letters, numbers, _");
      }
      isSimpleValue(value) ? keyValuePairs.push([key, value]) : isValueWithOperator(value) ? keyValuePairsWithOperator.push([key, value]) : "object" !== typeof value || "startsWith" in value || indexedKeys.push([key, value]);
    });
    filterList = [...getFiltersFromKeyValuePairs(keyValuePairs), ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)];
    indexedKeys.forEach(([key, value]) => {
      const nKeyValuePairs = [], nKeyValuePairsWithOperator = [];
      Object.entries(value).forEach(([nestedKey, nestedValue]) => {
        if (!nestedKey || "" === nestedKey.toString().trim()) {
          throw Error("Key cannot be empty");
        }
        if (isSimpleValue(nestedValue)) {
          var JSCompiler_temp_const = nKeyValuePairs.push;
          nestedKey = nestedKey ? `${key}[${JSON.stringify(nestedKey)}]` : key;
          JSCompiler_temp_const.call(nKeyValuePairs, [nestedKey, nestedValue]);
        } else {
          isValueWithOperator(nestedValue) && (JSCompiler_temp_const = nKeyValuePairsWithOperator.push, nestedKey = nestedKey ? `${key}[${JSON.stringify(nestedKey)}]` : key, JSCompiler_temp_const.call(nKeyValuePairsWithOperator, [nestedKey, nestedValue]));
        }
      });
      filterList = [...filterList, ...getFiltersFromKeyValuePairs(nKeyValuePairs), ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)];
    });
    return filterList.map(({key, operator, value}) => {
      if ("string" === typeof value) {
        if (!value || "" === value.toString().trim()) {
          throw Error("Value cannot be empty");
        }
        value = JSON.stringify(value);
      } else {
        value = value.toString();
      }
      return `${key}${operator}${value}`;
    }).join(" AND ");
  }
  function merge(target, patch) {
    let updated = !1;
    const newValue = {...target};
    Object.keys(patch).forEach(k => {
      const val = patch[k];
      newValue[k] !== val && (void 0 === val ? delete newValue[k] : newValue[k] = val, updated = !0);
    });
    return updated ? newValue : target;
  }
  function makeIdFactory(connectionId) {
    let count = 0;
    return () => `${connectionId}:${count++}`;
  }
  function userToTreeNode(key, user) {
    return {type:"User", id:`${user.connectionId}`, key, payload:{connectionId:user.connectionId, id:user.id, info:user.info, presence:user.presence, isReadOnly:!user.canWrite}};
  }
  function installBackgroundTabSpy() {
    function onVisibilityChange() {
      "hidden" === _optionalChain([doc, "optionalAccess", _117 => _117.visibilityState]) ? inBackgroundSince.current = _nullishCoalesce(inBackgroundSince.current, () => Date.now()) : inBackgroundSince.current = null;
    }
    const doc = "undefined" !== typeof document ? document : void 0, inBackgroundSince = {current:null};
    _optionalChain([doc, "optionalAccess", _118 => _118.addEventListener, "call", _119 => _119("visibilitychange", onVisibilityChange)]);
    return [inBackgroundSince, () => {
      _optionalChain([doc, "optionalAccess", _120 => _120.removeEventListener, "call", _121 => _121("visibilitychange", onVisibilityChange)]);
    }];
  }
  function splitFileIntoParts(file) {
    const parts = [];
    let start = 0;
    for (; start < file.size;) {
      const end = Math.min(start + 5242880, file.size);
      parts.push({partNumber:parts.length + 1, part:file.slice(start, end)});
      start = end;
    }
    return parts;
  }
  function createRoom(options, config) {
    function sendMessages(messages) {
      const serializedPayload = JSON.stringify(messages), nonce = _optionalChain([context, "access", _130 => _130.dynamicSessionInfo, "access", _131 => _131.current, "optionalAccess", _132 => _132.nonce]);
      config.unstable_fallbackToHTTP && nonce && 1047552 < (new TextEncoder()).encode(serializedPayload).length ? (httpClient1.rawPost(url`/v2/c/rooms/${config.roomId}/send-message`, {nonce, messages}).then(resp => {
        resp.ok || 403 !== resp.status || managedSocket.reconnect();
      }), warn("Message was too large for websockets and sent over HTTP instead")) : managedSocket.send(serializedPayload);
    }
    function notifySelfChanged(batchedUpdatesWrapper) {
      const currSelf = self.current;
      null !== currSelf && currSelf !== _lastSelf && (batchedUpdatesWrapper(() => {
        eventHub.self.notify(currSelf);
      }), _lastSelf = currSelf);
    }
    function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {
      if (0 === message.items.length) {
        throw Error("Internal error: cannot load storage without items");
      }
      void 0 !== context.root ? updateRoot(message.items, batchedUpdatesWrapper) : context.root = LiveObject._fromItems(message.items, pool);
      message = _nullishCoalesce(_optionalChain([self, "access", _133 => _133.current, "optionalAccess", _134 => _134.canWrite]), () => !0);
      batchedUpdatesWrapper = context.undoStack.length;
      for (const key in context.initialStorage) {
        void 0 === context.root.get(key) && (message ? context.root.set(key, cloneLson(context.initialStorage[key])) : warn(`Attempted to populate missing storage key '${key}', but current user has no write access`));
      }
      context.undoStack.length = batchedUpdatesWrapper;
    }
    function updateRoot(items, batchedUpdatesWrapper) {
      if (void 0 !== context.root) {
        var currentItems = new Map();
        for (const [id, node] of context.nodes) {
          currentItems.set(id, node._serialize());
        }
        items = getTreesDiffOperations(currentItems, new Map(items));
        items = applyOps(items, !1);
        notify(items.updates, batchedUpdatesWrapper);
      }
    }
    function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {
      50 <= context.undoStack.length && context.undoStack.shift();
      context.undoStack.push(historyOps);
      onHistoryChange(batchedUpdatesWrapper);
    }
    function addToUndoStack(historyOps, batchedUpdatesWrapper) {
      null !== context.pausedHistory ? context.pausedHistory.unshift(...historyOps) : _addToRealUndoStack(historyOps, batchedUpdatesWrapper);
    }
    function notify(updates, batchedUpdatesWrapper) {
      const storageUpdates = updates.storageUpdates, othersUpdates = updates.others;
      batchedUpdatesWrapper(() => {
        if (void 0 !== othersUpdates && 0 < othersUpdates.length) {
          var others = context.others.current;
          for (const event of othersUpdates) {
            eventHub.others.notify({...event, others});
          }
        }
        _nullishCoalesce(updates.presence, () => !1) && (notifySelfChanged(doNotBatchUpdates), eventHub.myPresence.notify(context.myPresence.current));
        void 0 !== storageUpdates && 0 < storageUpdates.size && (others = Array.from(storageUpdates.values()), eventHub.storageBatch.notify(others));
        notifyStorageStatus();
      });
    }
    function getConnectionId() {
      const info = context.dynamicSessionInfo.current;
      if (info) {
        return info.actor;
      }
      throw Error("Internal. Tried to get connection id but connection was never open");
    }
    function applyOps(rawOps, isLocal) {
      var JSCompiler_object_inline_reverse_1628 = [], JSCompiler_object_inline_storageUpdates_1629 = new Map(), JSCompiler_object_inline_presence_1630 = !1;
      const createdNodeIds = new Set();
      rawOps = rawOps.map(op => "presence" === op.type || op.opId ? op : {...op, opId:pool.generateOpId()});
      for (const op of rawOps) {
        if ("presence" === op.type) {
          JSCompiler_object_inline_presence_1630 = {type:"presence", data:{}};
          for (const key in op.data) {
            JSCompiler_object_inline_presence_1630.data[key] = context.myPresence.current[key];
          }
          context.myPresence.patch(op.data);
          if (null === context.buffer.presenceUpdates) {
            context.buffer.presenceUpdates = {type:"partial", data:op.data};
          } else {
            for (const key in op.data) {
              context.buffer.presenceUpdates.data[key] = op.data[key];
            }
          }
          JSCompiler_object_inline_reverse_1628.unshift(JSCompiler_object_inline_presence_1630);
          JSCompiler_object_inline_presence_1630 = !0;
        } else {
          var source = void 0;
          isLocal ? source = 0 : (source = nn(op.opId), nn(context.opStackTraces).delete(source), source = context.unacknowledgedOps.delete(source) ? 2 : 1);
          source = applyOp(op, source);
          if (source.modified) {
            const nodeId = source.modified.node._id;
            nodeId && createdNodeIds.has(nodeId) || (JSCompiler_object_inline_storageUpdates_1629.set(nn(source.modified.node._id), mergeStorageUpdates(JSCompiler_object_inline_storageUpdates_1629.get(nn(source.modified.node._id)), source.modified)), JSCompiler_object_inline_reverse_1628.unshift(...source.reverse));
            2 !== op.type && 7 !== op.type && 4 !== op.type || createdNodeIds.add(nn(op.id));
          }
        }
      }
      return {ops:rawOps, reverse:JSCompiler_object_inline_reverse_1628, updates:{storageUpdates:JSCompiler_object_inline_storageUpdates_1629, presence:JSCompiler_object_inline_presence_1630}};
    }
    function applyOp(op, source) {
      if (5 === op.type && "ACK" === op.id) {
        return {modified:!1};
      }
      switch(op.type) {
        case 6:
        case 3:
        case 5:
          var node = context.nodes.get(op.id);
          return void 0 === node ? {modified:!1} : node._apply(op, 0 === source);
        case 1:
          return node = context.nodes.get(op.id), void 0 === node ? {modified:!1} : "HasParent" === node.parent.type && node.parent.node instanceof LiveList ? node.parent.node._setChildKey(asPos(op.parentKey), node, source) : {modified:!1};
        case 4:
        case 2:
        case 7:
        case 8:
          if (void 0 === op.parentId) {
            return {modified:!1};
          }
          node = context.nodes.get(op.parentId);
          return void 0 === node ? {modified:!1} : node._attachChild(op, source);
      }
    }
    function onUpdatePresenceMessage(message) {
      if (void 0 !== message.targetActor) {
        var oldUser = context.others.getUser(message.actor);
        context.others.setOther(message.actor, message.data);
        const newUser = context.others.getUser(message.actor);
        if (void 0 === oldUser && void 0 !== newUser) {
          return {type:"enter", user:newUser};
        }
      } else {
        context.others.patchOther(message.actor, message.data), message;
      }
      if (oldUser = context.others.getUser(message.actor)) {
        return {type:"update", updates:message.data, user:oldUser};
      }
    }
    function onUserLeftMessage(message) {
      const user = context.others.getUser(message.actor);
      return user ? (context.others.removeConnection(message.actor), {type:"leave", user}) : null;
    }
    function onRoomStateMessage(message, batchedUpdatesWrapper) {
      context.dynamicSessionInfo.set({actor:message.actor, nonce:message.nonce, scopes:message.scopes});
      context.idFactory = makeIdFactory(message.actor);
      notifySelfChanged(batchedUpdatesWrapper);
      for (const connectionId of context.others.connectionIds()) {
        void 0 === message.users[connectionId] && context.others.removeConnection(connectionId);
      }
      for (const key in message.users) {
        batchedUpdatesWrapper = message.users[key], context.others.setConnection(Number(key), batchedUpdatesWrapper.id, batchedUpdatesWrapper.info, batchedUpdatesWrapper.scopes);
      }
      return {type:"reset"};
    }
    function canUndo() {
      return 0 < context.undoStack.length;
    }
    function canRedo() {
      return 0 < context.redoStack.length;
    }
    function onHistoryChange(batchedUpdatesWrapper) {
      batchedUpdatesWrapper(() => {
        eventHub.history.notify({canUndo:canUndo(), canRedo:canRedo()});
      });
    }
    function onUserJoinedMessage(message) {
      context.others.setConnection(message.actor, message.id, message.info, message.scopes);
      context.buffer.messages.push({type:100, data:context.myPresence.current, targetActor:message.actor});
      flushNowOrSoon();
      return (message = context.others.getUser(message.actor)) ? {type:"enter", user:message} : void 0;
    }
    function parseServerMessages(text) {
      text = tryParseJson(text);
      return void 0 === text ? null : isJsonArray(text) ? compact(text.map(item => isJsonObject(item) ? item : null)) : compact([isJsonObject(text) ? text : null]);
    }
    function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {
      if (0 !== offlineOps.size) {
        var messages = [];
        offlineOps = Array.from(offlineOps.values());
        offlineOps = applyOps(offlineOps, !0);
        messages.push({type:201, ops:offlineOps.ops});
        notify(offlineOps.updates, batchedUpdatesWrapper);
        sendMessages(messages);
      }
    }
    function flushNowOrSoon() {
      var storageOps = context.buffer.storageOperations;
      if (0 < storageOps.length) {
        for (var op of storageOps) {
          context.unacknowledgedOps.set(nn(op.opId), op);
        }
        notifyStorageStatus();
      }
      if ("connected" !== managedSocket.getStatus()) {
        context.buffer.storageOperations = [];
      } else {
        if (storageOps = Date.now(), op = storageOps - context.buffer.lastFlushedAt, op >= config.throttleDelay) {
          op = [];
          context.buffer.presenceUpdates && op.push("full" === context.buffer.presenceUpdates.type ? {type:100, targetActor:-1, data:context.buffer.presenceUpdates.data} : {type:100, data:context.buffer.presenceUpdates.data});
          for (JSCompiler_inline_result of context.buffer.messages) {
            op.push(JSCompiler_inline_result);
          }
          0 < context.buffer.storageOperations.length && op.push({type:201, ops:context.buffer.storageOperations});
          var JSCompiler_inline_result = op;
          0 !== JSCompiler_inline_result.length && (sendMessages(JSCompiler_inline_result), context.buffer = {flushTimerID:void 0, lastFlushedAt:storageOps, messages:[], storageOperations:[], presenceUpdates:null});
        } else {
          clearTimeout(context.buffer.flushTimerID), context.buffer.flushTimerID = setTimeout(flushNowOrSoon, config.throttleDelay - op);
        }
      }
    }
    function dispatchOps(ops) {
      const {storageOperations} = context.buffer;
      for (const op of ops) {
        storageOperations.push(op);
      }
      flushNowOrSoon();
    }
    function processInitialStorage(message) {
      const unacknowledgedOps = new Map(context.unacknowledgedOps);
      createOrUpdateRootFromMessage(message, doNotBatchUpdates);
      applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);
      _optionalChain([_resolveStoragePromise, "optionalCall", _140 => _140()]);
      notifyStorageStatus();
      eventHub.storageDidLoad.notify();
    }
    async function streamStorage() {
      if (managedSocket.authValue) {
        var items = await (await httpClient1.rawGet(url`/v2/c/rooms/${config.roomId}/storage`)).json();
        processInitialStorage({type:200, items});
      }
    }
    function refreshStorage(options2) {
      const messages = context.buffer.messages;
      config.unstable_streamData ? streamStorage() : messages.some(msg => 200 === msg.type) || messages.push({type:200});
      options2.flush && flushNowOrSoon();
    }
    function startLoadingStorage() {
      null === _getStorage$ && (refreshStorage({flush:!0}), _getStorage$ = new Promise(resolve => {
        _resolveStoragePromise = resolve;
      }), notifyStorageStatus());
      return _getStorage$;
    }
    function getStorageSnapshot() {
      const root = context.root;
      if (void 0 !== root) {
        return root;
      }
      startLoadingStorage();
      return null;
    }
    async function getStorage() {
      if (void 0 !== context.root) {
        return Promise.resolve({root:context.root});
      }
      await startLoadingStorage();
      return {root:nn(context.root)};
    }
    function getStorageStatus() {
      return void 0 === context.root ? null === _getStorage$ ? "not-loaded" : "loading" : 0 === context.unacknowledgedOps.size ? "synchronized" : "synchronizing";
    }
    function notifyStorageStatus() {
      const storageStatus = getStorageStatus();
      _lastStorageStatus !== storageStatus && (_lastStorageStatus = storageStatus, eventHub.storageStatus.notify(storageStatus));
    }
    function isPresenceReady() {
      return null !== self.current;
    }
    function isStorageReady() {
      return null !== getStorageSnapshot();
    }
    async function getAttachmentUrls(attachmentIds) {
      ({urls:attachmentIds} = await httpClient2.post(url`/v2/c/rooms/${config.roomId}/attachments/presigned-urls`, {attachmentIds}));
      return attachmentIds;
    }
    async function fetchNotificationsJson(endpoint, options2) {
      return await httpClient2.get(endpoint, void 0, options2);
    }
    async function markInboxNotificationsAsRead(inboxNotificationIds) {
      await fetchNotificationsJson(url`/v2/c/rooms/${config.roomId}/inbox-notifications/read`, {method:"POST", body:JSON.stringify({inboxNotificationIds})});
    }
    var initialPresence = options.initialPresence;
    options = options.initialStorage;
    const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy(), delegates = {...config.delegates, canZombie() {
      return void 0 !== config.backgroundKeepAliveTimeout && null !== inBackgroundSince.current && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && "synchronizing" !== getStorageStatus();
    }}, managedSocket = new ManagedSocket(delegates, config.enableDebugLogging), context = {buffer:{flushTimerID:void 0, lastFlushedAt:0, presenceUpdates:{type:"full", data:initialPresence}, messages:[], storageOperations:[]}, staticSessionInfo:new ValueRef(null), dynamicSessionInfo:new ValueRef(null), myPresence:new PatchableRef(initialPresence), others:new OthersRef(), initialStorage:options, idFactory:null, provider:void 0, onProviderUpdate:makeEventSource(), clock:0, opClock:0, nodes:new Map(), 
    root:void 0, undoStack:[], redoStack:[], pausedHistory:null, activeBatch:null, unacknowledgedOps:new Map(), opStackTraces:new Map()}, doNotBatchUpdates = cb => cb(), batchUpdates = _nullishCoalesce(config.unstable_batchedUpdates, () => doNotBatchUpdates);
    let lastTokenKey, _connectionLossTimerId, _hasLostConnection = !1;
    managedSocket.events.onMessage.subscribe(function(event) {
      if ("string" === typeof event.data) {
        var messages = parseServerMessages(event.data);
        if (null !== messages && 0 !== messages.length) {
          var updates = {storageUpdates:new Map(), others:[]};
          batchUpdates(() => {
            for (const message of messages) {
              switch(message.type) {
                case 101:
                  var userJoinedUpdate = onUserJoinedMessage(message);
                  userJoinedUpdate && updates.others.push(userJoinedUpdate);
                  break;
                case 100:
                  (userJoinedUpdate = onUpdatePresenceMessage(message)) && updates.others.push(userJoinedUpdate);
                  break;
                case 103:
                  userJoinedUpdate = context.others.current;
                  eventHub.customEvent.notify({connectionId:message.actor, user:0 > message.actor ? null : _nullishCoalesce(userJoinedUpdate.find(u => u.connectionId === message.actor), () => null), event:message.event});
                  break;
                case 102:
                  (userJoinedUpdate = onUserLeftMessage(message)) && updates.others.push(userJoinedUpdate);
                  break;
                case 300:
                  eventHub.ydoc.notify(message);
                  break;
                case 104:
                  updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));
                  break;
                case 200:
                  processInitialStorage(message);
                  break;
                case 201:
                  userJoinedUpdate = applyOps(message.ops, !1);
                  for (const [key, value] of userJoinedUpdate.updates.storageUpdates) {
                    updates.storageUpdates.set(key, mergeStorageUpdates(updates.storageUpdates.get(key), value));
                  }
                  break;
                case 299:
                  errorWithTitle("Storage mutation rejection error", message.reason);
                  userJoinedUpdate = new Set();
                  for (const opId of message.opIds) {
                    const trace = _optionalChain([context, "access", _137 => _137.opStackTraces, "optionalAccess", _138 => _138.get, "call", _139 => _139(opId)]);
                    trace && userJoinedUpdate.add(trace);
                  }
                  0 < userJoinedUpdate.size && warnWithTitle("The following function calls caused the rejected storage mutations:", `

${Array.from(userJoinedUpdate).join("\n\n")}`);
                  throw Error(`Storage mutations rejected by server: ${message.reason}`);
                case 400:
                case 407:
                case 401:
                case 408:
                case 405:
                case 406:
                case 402:
                case 403:
                case 404:
                  eventHub.comments.notify(message);
              }
            }
            notify(updates, doNotBatchUpdates);
          });
        }
      }
    });
    managedSocket.events.statusDidChange.subscribe(function(newStatus) {
      var authValue = managedSocket.authValue;
      if (null !== authValue) {
        const tokenKey = getBearerTokenFromAuthValue(authValue);
        tokenKey !== lastTokenKey && (lastTokenKey = tokenKey, "secret" === authValue.type ? (authValue = authValue.token.parsed, context.staticSessionInfo.set({userId:"sec-legacy" === authValue.k ? authValue.id : authValue.uid, userInfo:"sec-legacy" === authValue.k ? authValue.info : authValue.ui})) : context.staticSessionInfo.set({userId:void 0, userInfo:void 0}));
      }
      batchUpdates(() => {
        eventHub.status.notify(newStatus);
        notifySelfChanged(doNotBatchUpdates);
      });
    });
    managedSocket.events.statusDidChange.subscribe(function(newStatus) {
      "reconnecting" === newStatus ? _connectionLossTimerId = setTimeout(() => {
        batchUpdates(() => {
          eventHub.lostConnection.notify("lost");
          _hasLostConnection = !0;
          context.others.clearOthers();
          notify({others:[{type:"reset"}]}, doNotBatchUpdates);
        });
      }, config.lostConnectionTimeout) : (clearTimeout(_connectionLossTimerId), _hasLostConnection && ("disconnected" === newStatus ? batchUpdates(() => {
        eventHub.lostConnection.notify("failed");
      }) : batchUpdates(() => {
        eventHub.lostConnection.notify("restored");
      }), _hasLostConnection = !1));
    });
    managedSocket.events.didConnect.subscribe(function() {
      context.buffer.presenceUpdates = {type:"full", data:{...context.myPresence.current}};
      null !== _getStorage$ && refreshStorage({flush:!1});
      flushNowOrSoon();
    });
    managedSocket.events.didDisconnect.subscribe(function() {
      clearTimeout(context.buffer.flushTimerID);
    });
    managedSocket.events.onLiveblocksError.subscribe(err => {
      batchUpdates(() => {
        error2(`Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`);
        eventHub.error.notify(err);
      });
    });
    const pool = {roomId:config.roomId, getNode:id => context.nodes.get(id), addNode:(id, node) => void context.nodes.set(id, node), deleteNode:id => void context.nodes.delete(id), generateId:() => `${getConnectionId()}:${context.clock++}`, generateOpId:() => `${getConnectionId()}:${context.opClock++}`, dispatch(ops, reverse, storageUpdates) {
      const activeBatch = context.activeBatch, stackTrace = captureStackTrace("Storage mutation", this.dispatch);
      if (stackTrace) {
        for (const op of ops) {
          op.opId && nn(context.opStackTraces).set(op.opId, stackTrace);
        }
      }
      if (activeBatch) {
        for (const op of ops) {
          activeBatch.ops.push(op);
        }
        for (const [key, value] of storageUpdates) {
          activeBatch.updates.storageUpdates.set(key, mergeStorageUpdates(activeBatch.updates.storageUpdates.get(key), value));
        }
        activeBatch.reverseOps.unshift(...reverse);
      } else {
        batchUpdates(() => {
          addToUndoStack(reverse, doNotBatchUpdates);
          context.redoStack.length = 0;
          dispatchOps(ops);
          notify({storageUpdates}, doNotBatchUpdates);
        });
      }
    }, assertStorageIsWritable:() => {
      const scopes = _optionalChain([context, "access", _122 => _122.dynamicSessionInfo, "access", _123 => _123.current, "optionalAccess", _124 => _124.scopes]);
      if (void 0 !== scopes && !scopes.includes("room:write")) {
        throw Error("Cannot write to storage with a read only user, please ensure the user has write permissions");
      }
    }}, eventHub = {status:makeEventSource(), lostConnection:makeEventSource(), customEvent:makeEventSource(), self:makeEventSource(), myPresence:makeEventSource(), others:makeEventSource(), error:makeEventSource(), storageBatch:makeEventSource(), history:makeEventSource(), storageDidLoad:makeEventSource(), storageStatus:makeEventSource(), ydoc:makeEventSource(), comments:makeEventSource()};
    initialPresence = _optionalChain([config, "access", _125 => _125.polyfills, "optionalAccess", _126 => _126.fetch]) || _optionalChain([globalThis, "access", _127 => _127.fetch, "optionalAccess", _128 => _128.bind, "call", _129 => _129(globalThis)]);
    const httpClient1 = new HttpClient(config.baseUrl, initialPresence, () => Promise.resolve(_nullishCoalesce(managedSocket.authValue, () => raise("Not authorized")))), httpClient2 = new HttpClient(config.baseUrl, initialPresence, () => delegates.authenticate()), self = new DerivedRef(context.staticSessionInfo, context.dynamicSessionInfo, context.myPresence, (staticSession, dynamicSession, myPresence) => {
      if (null === staticSession || null === dynamicSession) {
        return null;
      }
      const canWrite = dynamicSession.scopes.includes("room:write");
      return {connectionId:dynamicSession.actor, id:staticSession.userId, info:staticSession.userInfo, presence:myPresence, canWrite, canComment:canComment(dynamicSession.scopes)};
    });
    let _lastSelf;
    const selfAsTreeNode = new DerivedRef(self, me => null !== me ? userToTreeNode("Me", me) : null);
    let _getStorage$ = null, _resolveStoragePromise = null, _lastStorageStatus = getStorageStatus();
    const others_forDevTools = new DerivedRef(context.others, others => others.map((other, index) => userToTreeNode(`Other ${index}`, other))), events = {status:eventHub.status.observable, lostConnection:eventHub.lostConnection.observable, customEvent:eventHub.customEvent.observable, others:eventHub.others.observable, self:eventHub.self.observable, myPresence:eventHub.myPresence.observable, error:eventHub.error.observable, storage:eventHub.storageBatch.observable, storageBatch:eventHub.storageBatch.observable, 
    history:eventHub.history.observable, storageDidLoad:eventHub.storageDidLoad.observable, storageStatus:eventHub.storageStatus.observable, ydoc:eventHub.ydoc.observable, comments:eventHub.comments.observable}, batchedGetAttachmentUrls = new Batch(async batchedAttachmentIds => {
      batchedAttachmentIds = batchedAttachmentIds.flat();
      return (await getAttachmentUrls(batchedAttachmentIds)).map(url2 => _nullishCoalesce(url2, () => Error("There was an error while getting this attachment's URL")));
    }, {delay:50});
    initialPresence = createBatchStore(batchedGetAttachmentUrls);
    const batchedMarkInboxNotificationsAsRead = new Batch(async batchedInboxNotificationIds => {
      batchedInboxNotificationIds = batchedInboxNotificationIds.flat();
      await markInboxNotificationsAsRead(batchedInboxNotificationIds);
      return batchedInboxNotificationIds;
    }, {delay:50});
    return Object.defineProperty({[kInternal]:{get presenceBuffer() {
      return deepClone(_nullishCoalesce(_optionalChain([context, "access", _152 => _152.buffer, "access", _153 => _153.presenceUpdates, "optionalAccess", _154 => _154.data]), () => null));
    }, get undoStack() {
      return deepClone(context.undoStack);
    }, get nodeCount() {
      return context.nodes.size;
    }, getProvider() {
      return context.provider;
    }, setProvider(provider) {
      context.provider = provider;
      context.onProviderUpdate.notify();
    }, onProviderUpdate:context.onProviderUpdate.observable, reportTextEditor:async function(type, rootKey) {
      await httpClient2.rawPost(url`/v2/c/rooms/${config.roomId}/text-metadata`, {type, rootKey});
    }, createTextMention:async function(userId, mentionId) {
      await httpClient1.rawPost(url`/v2/c/rooms/${config.roomId}/text-mentions`, {userId, mentionId});
    }, deleteTextMention:async function(mentionId) {
      await httpClient1.rawDelete(url`/v2/c/rooms/${config.roomId}/text-mentions/${mentionId}`);
    }, listTextVersions:async function() {
      const result = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/versions`);
      return {versions:result.versions.map(({createdAt, ...version}) => ({createdAt:new Date(createdAt), ...version})), requestedAt:new Date(result.meta.requestedAt)};
    }, listTextVersionsSince:async function(options2) {
      options2 = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/versions/delta`, {since:options2.since.toISOString()}, {signal:options2.signal});
      return {versions:options2.versions.map(({createdAt, ...version}) => ({createdAt:new Date(createdAt), ...version})), requestedAt:new Date(options2.meta.requestedAt)};
    }, getTextVersion:async function(versionId) {
      return httpClient2.rawGet(url`/v2/c/rooms/${config.roomId}/y-version/${versionId}`);
    }, createTextVersion:async function() {
      await httpClient2.rawPost(url`/v2/c/rooms/${config.roomId}/version`);
    }, getSelf_forDevTools:() => selfAsTreeNode.current, getOthers_forDevTools:() => others_forDevTools.current, simulate:{explicitClose:event => managedSocket._privateSendMachineEvent({type:"EXPLICIT_SOCKET_CLOSE", event}), rawSend:data => managedSocket.send(data)}, attachmentUrlsStore:initialPresence}, id:config.roomId, subscribe:makeClassicSubscribeFn(events), connect:() => managedSocket.connect(), reconnect:() => managedSocket.reconnect(), disconnect:() => managedSocket.disconnect(), destroy:() => 
    {
      uninstallBgTabSpy();
      managedSocket.destroy();
    }, updatePresence:function(patch, options2) {
      const oldValues = {};
      null === context.buffer.presenceUpdates && (context.buffer.presenceUpdates = {type:"partial", data:{}});
      for (const key in patch) {
        const overrideValue = patch[key];
        void 0 !== overrideValue && (context.buffer.presenceUpdates.data[key] = overrideValue, oldValues[key] = context.myPresence.current[key]);
      }
      context.myPresence.patch(patch);
      context.activeBatch ? (_optionalChain([options2, "optionalAccess", _135 => _135.addToHistory]) && context.activeBatch.reverseOps.unshift({type:"presence", data:oldValues}), context.activeBatch.updates.presence = !0) : (flushNowOrSoon(), batchUpdates(() => {
        _optionalChain([options2, "optionalAccess", _136 => _136.addToHistory]) && addToUndoStack([{type:"presence", data:oldValues}], doNotBatchUpdates);
        notify({presence:!0}, doNotBatchUpdates);
      }));
    }, updateYDoc:function(update, guid) {
      update = {type:301, update, guid};
      context.buffer.messages.push(update);
      eventHub.ydoc.notify(update);
      flushNowOrSoon();
    }, broadcastEvent:function(event, options2 = {shouldQueueEventIfNotReady:!1}) {
      if ("connected" === managedSocket.getStatus() || options2.shouldQueueEventIfNotReady) {
        context.buffer.messages.push({type:103, event}), flushNowOrSoon();
      }
    }, batch:function(callback) {
      if (context.activeBatch) {
        return callback();
      }
      let returnValue = void 0;
      batchUpdates(() => {
        context.activeBatch = {ops:[], updates:{storageUpdates:new Map(), presence:!1, others:[]}, reverseOps:[]};
        try {
          returnValue = callback();
        } finally {
          const currentBatch = context.activeBatch;
          context.activeBatch = null;
          0 < currentBatch.reverseOps.length && addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);
          0 < currentBatch.ops.length && (context.redoStack.length = 0);
          0 < currentBatch.ops.length && dispatchOps(currentBatch.ops);
          notify(currentBatch.updates, doNotBatchUpdates);
          flushNowOrSoon();
        }
      });
      return returnValue;
    }, history:{undo:function() {
      if (context.activeBatch) {
        throw Error("undo is not allowed during a batch");
      }
      const historyOps = context.undoStack.pop();
      if (void 0 !== historyOps) {
        context.pausedHistory = null;
        var result = applyOps(historyOps, !0);
        batchUpdates(() => {
          notify(result.updates, doNotBatchUpdates);
          context.redoStack.push(result.reverse);
          onHistoryChange(doNotBatchUpdates);
        });
        for (const op of result.ops) {
          "presence" !== op.type && context.buffer.storageOperations.push(op);
        }
        flushNowOrSoon();
      }
    }, redo:function() {
      if (context.activeBatch) {
        throw Error("redo is not allowed during a batch");
      }
      const historyOps = context.redoStack.pop();
      if (void 0 !== historyOps) {
        context.pausedHistory = null;
        var result = applyOps(historyOps, !0);
        batchUpdates(() => {
          notify(result.updates, doNotBatchUpdates);
          context.undoStack.push(result.reverse);
          onHistoryChange(doNotBatchUpdates);
        });
        for (const op of result.ops) {
          "presence" !== op.type && context.buffer.storageOperations.push(op);
        }
        flushNowOrSoon();
      }
    }, canUndo, canRedo, clear:function() {
      context.undoStack.length = 0;
      context.redoStack.length = 0;
    }, pause:function() {
      null === context.pausedHistory && (context.pausedHistory = []);
    }, resume:function() {
      const historyOps = context.pausedHistory;
      context.pausedHistory = null;
      null !== historyOps && 0 < historyOps.length && _addToRealUndoStack(historyOps, batchUpdates);
    }}, fetchYDoc:function(vector, guid) {
      context.buffer.messages.find(m => 300 === m.type && m.vector === vector && m.guid === guid) || context.buffer.messages.push({type:300, vector, guid});
      flushNowOrSoon();
    }, getStorage, getStorageSnapshot, getStorageStatus, isPresenceReady, isStorageReady, waitUntilPresenceReady:memoizeOnSuccess(async function() {
      for (; !isPresenceReady();) {
        const {promise, resolve} = Promise_withResolvers(), unsub1 = events.self.subscribeOnce(resolve), unsub2 = events.status.subscribeOnce(resolve);
        await promise;
        unsub1();
        unsub2();
      }
    }), waitUntilStorageReady:memoizeOnSuccess(async function() {
      for (; !isStorageReady();) {
        await getStorage();
      }
    }), events, getStatus:() => managedSocket.getStatus(), getSelf:() => self.current, getPresence:() => context.myPresence.current, getOthers:() => context.others.current, getThreads:async function(options2) {
      let query;
      _optionalChain([options2, "optionalAccess", _144 => _144.query]) && (query = objectToQuery(options2.query));
      options2 = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/threads`, {cursor:_optionalChain([options2, "optionalAccess", _145 => _145.cursor]), query, limit:50});
      return {threads:options2.data.map(convertToThreadData), inboxNotifications:options2.inboxNotifications.map(convertToInboxNotificationData), nextCursor:options2.meta.nextCursor, requestedAt:new Date(options2.meta.requestedAt)};
    }, getThreadsSince:async function(options2) {
      options2 = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/threads/delta`, {since:_optionalChain([options2, "optionalAccess", _141 => _141.since, "optionalAccess", _142 => _142.toISOString, "call", _143 => _143()])}, {signal:options2.signal});
      return {threads:{updated:options2.data.map(convertToThreadData), deleted:options2.deletedThreads.map(convertToThreadDeleteInfo)}, inboxNotifications:{updated:options2.inboxNotifications.map(convertToInboxNotificationData), deleted:options2.deletedInboxNotifications.map(convertToInboxNotificationDeleteInfo)}, requestedAt:new Date(options2.meta.requestedAt)};
    }, getThread:async function(threadId) {
      const response = await httpClient2.rawGet(url`/v2/c/rooms/${config.roomId}/thread-with-notification/${threadId}`);
      if (response.ok) {
        return threadId = await response.json(), {thread:convertToThreadData(threadId.thread), inboxNotification:threadId.inboxNotification ? convertToInboxNotificationData(threadId.inboxNotification) : void 0};
      }
      if (404 === response.status) {
        return {thread:void 0, inboxNotification:void 0};
      }
      throw Error(`There was an error while getting thread ${threadId}.`);
    }, createThread:async function({metadata, body, commentId = createCommentId(), threadId = createThreadId(), attachmentIds}) {
      metadata = await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads`, {id:threadId, comment:{id:commentId, body, attachmentIds}, metadata});
      return convertToThreadData(metadata);
    }, deleteThread:async function(threadId) {
      await httpClient2.delete(url`/v2/c/rooms/${config.roomId}/threads/${threadId}`);
    }, editThreadMetadata:async function({metadata, threadId}) {
      return await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/metadata`, metadata);
    }, markThreadAsResolved:async function(threadId) {
      await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-resolved`);
    }, markThreadAsUnresolved:async function(threadId) {
      await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-unresolved`);
    }, createComment:async function({threadId, commentId = createCommentId(), body, attachmentIds}) {
      threadId = await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments`, {id:commentId, body, attachmentIds});
      return convertToCommentData(threadId);
    }, editComment:async function({threadId, commentId, body, attachmentIds}) {
      threadId = await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`, {body, attachmentIds});
      return convertToCommentData(threadId);
    }, deleteComment:async function({threadId, commentId}) {
      await httpClient2.delete(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`);
    }, addReaction:async function({threadId, commentId, emoji}) {
      threadId = await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions`, {emoji});
      return convertToCommentUserReaction(threadId);
    }, removeReaction:async function({threadId, commentId, emoji}) {
      await httpClient2.delete(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions/${emoji}`);
    }, prepareAttachment:function(file) {
      return {type:"localAttachment", status:"idle", id:`${"at"}_${nanoid()}`, name:file.name, size:file.size, mimeType:file.type, file};
    }, uploadAttachment:async function(attachment, options2 = {}) {
      const abortSignal = options2.signal, abortError = abortSignal ? new DOMException(`Upload of attachment ${attachment.id} was aborted.`, "AbortError") : void 0;
      if (_optionalChain([abortSignal, "optionalAccess", _146 => _146.aborted])) {
        throw abortError;
      }
      options2 = err => {
        if (_optionalChain([abortSignal, "optionalAccess", _147 => _147.aborted])) {
          throw abortError;
        }
        if (err instanceof HttpError && 413 === err.status) {
          throw err;
        }
        return !1;
      };
      if (5242880 >= attachment.size) {
        return autoRetry(() => httpClient2.putBlob(url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`, attachment.file, {fileSize:attachment.size}, {signal:abortSignal}), 10, RETRY_DELAYS, options2);
      }
      let uploadId;
      const uploadedParts = [], createMultiPartUpload = await autoRetry(() => httpClient2.post(url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`, void 0, {signal:abortSignal}, {fileSize:attachment.size}), 10, RETRY_DELAYS, options2);
      try {
        uploadId = createMultiPartUpload.uploadId;
        var parts = splitFileIntoParts(attachment.file);
        if (_optionalChain([abortSignal, "optionalAccess", _148 => _148.aborted])) {
          throw abortError;
        }
        const batches = chunk(parts, 5);
        for (const parts2 of batches) {
          parts = [];
          for (const {part, partNumber} of parts2) {
            parts.push(autoRetry(() => httpClient2.putBlob(url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`, part, void 0, {signal:abortSignal}), 10, RETRY_DELAYS, options2));
          }
          uploadedParts.push(...(await Promise.all(parts)));
        }
        if (_optionalChain([abortSignal, "optionalAccess", _149 => _149.aborted])) {
          throw abortError;
        }
        const sortedUploadedParts = uploadedParts.sort((a, b) => a.partNumber - b.partNumber);
        return httpClient2.post(url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`, {parts:sortedUploadedParts}, {signal:abortSignal});
      } catch (error3) {
        if (uploadId && _optionalChain([error3, "optionalAccess", _150 => _150.name]) && ("AbortError" === error3.name || "TimeoutError" === error3.name)) {
          try {
            await httpClient2.rawDelete(url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}`);
          } catch (error4) {
          }
        }
        throw error3;
      }
    }, getAttachmentUrl:function(attachmentId) {
      return batchedGetAttachmentUrls.get(attachmentId);
    }, getNotificationSettings:function(options2) {
      return fetchNotificationsJson(url`/v2/c/rooms/${config.roomId}/notification-settings`, {signal:_optionalChain([options2, "optionalAccess", _151 => _151.signal])});
    }, updateNotificationSettings:function(settings) {
      return fetchNotificationsJson(url`/v2/c/rooms/${config.roomId}/notification-settings`, {method:"POST", body:JSON.stringify(settings)});
    }, markInboxNotificationAsRead:async function(inboxNotificationId) {
      await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);
    }}, kInternal, {enumerable:!1});
  }
  function makeClassicSubscribeFn(events) {
    function subscribeToLiveStructureDeeply(node, callback) {
      return events.storageBatch.subscribe(updates => {
        updates = updates.filter(update => isSameNodeOrChildOf(update.node, node));
        0 < updates.length && callback(updates);
      });
    }
    function subscribeToLiveStructureShallowly(node, callback) {
      return events.storageBatch.subscribe(updates => {
        for (const update of updates) {
          update.node._id === node._id && callback(update.node);
        }
      });
    }
    return function(first, second, options) {
      if ("string" === typeof first && ("my-presence" === first || "others" === first || "event" === first || "error" === first || "history" === first || "status" === first || "storage-status" === first || "lost-connection" === first || "connection" === first || "comments" === first)) {
        if ("function" !== typeof second) {
          throw Error("Second argument must be a callback function");
        }
        switch(first) {
          case "event":
            return events.customEvent.subscribe(second);
          case "my-presence":
            return events.myPresence.subscribe(second);
          case "others":
            return events.others.subscribe(event => {
              const {others, ...internalEvent} = event;
              return second(others, internalEvent);
            });
          case "error":
            return events.error.subscribe(second);
          case "status":
            return events.status.subscribe(second);
          case "lost-connection":
            return events.lostConnection.subscribe(second);
          case "history":
            return events.history.subscribe(second);
          case "storage-status":
            return events.storageStatus.subscribe(second);
          case "comments":
            return events.comments.subscribe(second);
          default:
            return assertNever(first, `"${String(first)}" is not a valid event name`);
        }
      }
      if (void 0 === second || "function" === typeof first) {
        if ("function" === typeof first) {
          return events.storageBatch.subscribe(first);
        }
        throw Error("Please specify a listener callback");
      }
      if (isLiveNode(first)) {
        return _optionalChain([options, "optionalAccess", _155 => _155.isDeep]) ? subscribeToLiveStructureDeeply(first, second) : subscribeToLiveStructureShallowly(first, second);
      }
      throw Error(`${String(first)} is not a value that can be subscribed to.`);
    };
  }
  function makeAuthDelegateForRoom(roomId, authManager) {
    return async() => authManager.getAuthValue({requestedScope:"room:read", roomId});
  }
  function makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {
    return authValue => {
      const ws = _nullishCoalesce(WebSocketPolyfill, () => "undefined" === typeof WebSocket ? void 0 : WebSocket);
      if (void 0 === ws) {
        throw new StopRetrying("To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.");
      }
      const url2 = new URL(baseUrl);
      url2.protocol = "http:" === url2.protocol ? "ws" : "wss";
      url2.pathname = "/v7";
      url2.searchParams.set("roomId", roomId);
      if ("secret" === authValue.type) {
        url2.searchParams.set("tok", authValue.token.raw);
      } else if ("public" === authValue.type) {
        url2.searchParams.set("pubkey", authValue.publicApiKey);
      } else {
        return assertNever(authValue, "Unhandled case");
      }
      url2.searchParams.set("version", "2.10.2");
      return new ws(url2.toString());
    };
  }
  function getBaseUrl(baseUrl) {
    return "string" === typeof baseUrl && baseUrl.startsWith("http") ? baseUrl : "https://api.liveblocks.io";
  }
  function checkBounds(option, value, min, max, recommendedMin) {
    if ("number" !== typeof value || value < min || void 0 !== max && value > max) {
      throw Error(void 0 !== max ? `${option} should be between ${_nullishCoalesce(recommendedMin, () => min)} and ${max}.` : `${option} should be at least ${_nullishCoalesce(recommendedMin, () => min)}.`);
    }
    return value;
  }
  function getBackgroundKeepAliveTimeout(value) {
    if (void 0 !== value) {
      return checkBounds("backgroundKeepAliveTimeout", value, 15e3);
    }
  }
  function createDevelopmentWarning(condition, ...args) {
    let hasWarned = !1;
    return () => {
      !hasWarned && ("function" === typeof condition ? condition() : condition) && (warn(...args), hasWarned = !0);
    };
  }
  function isCommentBodyText(element) {
    return !("type" in element) && "text" in element && "string" === typeof element.text;
  }
  function isCommentBodyMention(element) {
    return "type" in element && "mention" === element.type;
  }
  function isCommentBodyLink(element) {
    return "type" in element && "link" === element.type;
  }
  function traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {
    if (body && _optionalChain([body, "optionalAccess", _171 => _171.content])) {
      var element = "string" === typeof elementOrVisitor ? elementOrVisitor : void 0, type = element ? commentBodyElementsTypes[element] : "all";
      element = element ? commentBodyElementsGuards[element] : () => !0;
      elementOrVisitor = "function" === typeof elementOrVisitor ? elementOrVisitor : possiblyVisitor;
      for (const block of body.content) {
        if (("all" === type || "block" === type) && element(block) && _optionalChain([elementOrVisitor, "optionalCall", _172 => _172(block)]), "all" === type || "inline" === type) {
          for (const inline of block.children) {
            element(inline) && _optionalChain([elementOrVisitor, "optionalCall", _173 => _173(inline)]);
          }
        }
      }
    }
  }
  function getMentionedIdsFromCommentBody(body) {
    const mentionedIds = new Set();
    traverseCommentBody(body, "mention", mention => mentionedIds.add(mention.id));
    return Array.from(mentionedIds);
  }
  async function resolveUsersInCommentBody(body, resolveUsers) {
    const resolvedUsers = new Map();
    if (!resolveUsers) {
      return resolvedUsers;
    }
    body = getMentionedIdsFromCommentBody(body);
    resolveUsers = await resolveUsers({userIds:body});
    for (const [index, userId] of body.entries()) {
      (body = _optionalChain([resolveUsers, "optionalAccess", _174 => _174[index]])) && resolvedUsers.set(userId, body);
    }
    return resolvedUsers;
  }
  function joinHtml(strings) {
    return 0 >= strings.length ? new HtmlSafeString([""], []) : new HtmlSafeString(["", ...Array(strings.length - 1).fill(""), ""], strings);
  }
  function escapeHtml(value) {
    return value instanceof HtmlSafeString ? value.toString() : Array.isArray(value) ? joinHtml(value).toString() : String(value).replace(htmlEscapablesRegex, character => htmlEscapables[character]);
  }
  function html(strings, ...values) {
    return new HtmlSafeString(strings, values);
  }
  function joinMarkdown(strings) {
    return 0 >= strings.length ? new MarkdownSafeString([""], []) : new MarkdownSafeString(["", ...Array(strings.length - 1).fill(""), ""], strings);
  }
  function escapeMarkdown(value) {
    return value instanceof MarkdownSafeString ? value.toString() : Array.isArray(value) ? joinMarkdown(value).toString() : String(value).replace(markdownEscapablesRegex, character => markdownEscapables[character]);
  }
  function markdown(strings, ...values) {
    return new MarkdownSafeString(strings, values);
  }
  function toAbsoluteUrl(url2) {
    if (url2.startsWith("http://") || url2.startsWith("https://")) {
      return url2;
    }
    if (url2.startsWith("www.")) {
      return "https://" + url2;
    }
  }
  function toPlainLson(lson) {
    return lson instanceof LiveObject ? {liveblocksType:"LiveObject", data:Object.fromEntries(Object.entries(lson.toObject()).flatMap(([key, value]) => void 0 !== value ? [[key, toPlainLson(value)]] : []))} : lson instanceof LiveMap ? {liveblocksType:"LiveMap", data:Object.fromEntries([...lson].map(([key, value]) => [key, toPlainLson(value)]))} : lson instanceof LiveList ? {liveblocksType:"LiveList", data:[...lson].map(item => toPlainLson(item))} : lson;
  }
  function lsonObjectToJson(obj) {
    const result = {};
    for (const key in obj) {
      const val = obj[key];
      void 0 !== val && (result[key] = lsonToJson(val));
    }
    return result;
  }
  function lsonToJson(value$jscomp$0) {
    if (value$jscomp$0 instanceof LiveObject) {
      return lsonObjectToJson(value$jscomp$0.toObject());
    }
    if (value$jscomp$0 instanceof LiveList) {
      return value$jscomp$0.toArray().map(lsonToJson);
    }
    if (value$jscomp$0 instanceof LiveMap) {
      const result = {};
      for (const [key, value] of value$jscomp$0.entries()) {
        result[key] = lsonToJson(value);
      }
      return result;
    }
    return value$jscomp$0 instanceof LiveRegister ? value$jscomp$0.data : Array.isArray(value$jscomp$0) ? value$jscomp$0.map(lsonToJson) : isPlainObject(value$jscomp$0) ? lsonObjectToJson(value$jscomp$0) : value$jscomp$0;
  }
  function deepLiveify(value) {
    if (Array.isArray(value)) {
      return new LiveList(value.map(deepLiveify));
    }
    if (isPlainObject(value)) {
      const init = {};
      for (const key in value) {
        const val = value[key];
        void 0 !== val && (init[key] = deepLiveify(val));
      }
      return new LiveObject(init);
    }
    return value;
  }
  function patchLiveObjectKey(liveObject, key, prev, next) {
    var nonSerializableValue = findNonSerializableValue(next);
    if (nonSerializableValue) {
      error2(`New state path: '${nonSerializableValue.path}' value: '${String(nonSerializableValue.value)}' is not serializable.
Only serializable value can be synced with Liveblocks.`);
    } else {
      if (nonSerializableValue = liveObject.get(key), void 0 === next) {
        liveObject.delete(key);
      } else if (void 0 === nonSerializableValue) {
        liveObject.set(key, deepLiveify(next));
      } else if (prev !== next) {
        if (nonSerializableValue instanceof LiveList && Array.isArray(prev) && Array.isArray(next)) {
          liveObject = 0;
          key = prev.length - 1;
          let nextEnd = next.length - 1, prevNode = prev[0], nextNode = next[0];
          a: {
            for (; prevNode === nextNode;) {
              ++liveObject;
              if (liveObject > key || liveObject > nextEnd) {
                break a;
              }
              prevNode = prev[liveObject];
              nextNode = next[liveObject];
            }
            prevNode = prev[key];
            for (nextNode = next[nextEnd]; prevNode === nextNode;) {
              key--;
              nextEnd--;
              if (liveObject > key || liveObject > nextEnd) {
                break a;
              }
              prevNode = prev[key];
              nextNode = next[nextEnd];
            }
          }
          if (liveObject > key) {
            if (liveObject <= nextEnd) {
              for (; liveObject <= nextEnd;) {
                nonSerializableValue.insert(deepLiveify(next[liveObject]), liveObject), liveObject++;
              }
            }
          } else if (liveObject > nextEnd) {
            for (prev = liveObject; prev <= key;) {
              nonSerializableValue.delete(liveObject), prev++;
            }
          } else {
            for (; liveObject <= key && liveObject <= nextEnd;) {
              prevNode = prev[liveObject];
              nextNode = next[liveObject];
              const liveListNode = nonSerializableValue.get(liveObject);
              liveListNode instanceof LiveObject && isPlainObject(prevNode) && isPlainObject(nextNode) ? patchLiveObject(liveListNode, prevNode, nextNode) : nonSerializableValue.set(liveObject, deepLiveify(nextNode));
              liveObject++;
            }
            for (; liveObject <= nextEnd;) {
              nonSerializableValue.insert(deepLiveify(next[liveObject]), liveObject), liveObject++;
            }
            for (prev = liveObject; prev <= key;) {
              nonSerializableValue.delete(liveObject), prev++;
            }
          }
        } else {
          nonSerializableValue instanceof LiveObject && isPlainObject(prev) && isPlainObject(next) ? patchLiveObject(nonSerializableValue, prev, next) : liveObject.set(key, deepLiveify(next));
        }
      }
    }
  }
  function patchLiveObject(root, prev, next) {
    const updates = {};
    for (const key in next) {
      patchLiveObjectKey(root, key, prev[key], next[key]);
    }
    for (const key in prev) {
      void 0 === next[key] && root.delete(key);
    }
    0 < Object.keys(updates).length && root.update(updates);
  }
  function legacy_patchImmutableNode(state, path, update) {
    const pathItem = path.pop();
    if (void 0 === pathItem) {
      switch(update.type) {
        case "LiveObject":
          if (!isJsonObject(state)) {
            throw Error("Internal: received update on LiveObject but state was not an object");
          }
          state = Object.assign({}, state);
          for (const key in update.updates) {
            "update" === _optionalChain([update, "access", _182 => _182.updates, "access", _183 => _183[key], "optionalAccess", _184 => _184.type]) ? (path = update.node.get(key), void 0 !== path && (state[key] = lsonToJson(path))) : "delete" === _optionalChain([update, "access", _185 => _185.updates, "access", _186 => _186[key], "optionalAccess", _187 => _187.type]) && delete state[key];
          }
          return state;
        case "LiveList":
          if (!Array.isArray(state)) {
            throw Error("Internal: received update on LiveList but state was not an array");
          }
          state = state.map(x => x);
          for (const listUpdate of update.updates) {
            "set" === listUpdate.type ? state = state.map((item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item) : "insert" === listUpdate.type ? listUpdate.index === state.length ? state.push(lsonToJson(listUpdate.item)) : state = [...state.slice(0, listUpdate.index), lsonToJson(listUpdate.item), ...state.slice(listUpdate.index)] : "delete" === listUpdate.type ? state.splice(listUpdate.index, 1) : "move" === listUpdate.type && (state = listUpdate.previousIndex > listUpdate.index ? 
            [...state.slice(0, listUpdate.index), lsonToJson(listUpdate.item), ...state.slice(listUpdate.index, listUpdate.previousIndex), ...state.slice(listUpdate.previousIndex + 1)] : [...state.slice(0, listUpdate.previousIndex), ...state.slice(listUpdate.previousIndex + 1, listUpdate.index + 1), lsonToJson(listUpdate.item), ...state.slice(listUpdate.index + 1)]);
          }
          return state;
        case "LiveMap":
          if (!isJsonObject(state)) {
            throw Error("Internal: received update on LiveMap but state was not an object");
          }
          state = Object.assign({}, state);
          for (const key in update.updates) {
            "update" === _optionalChain([update, "access", _188 => _188.updates, "access", _189 => _189[key], "optionalAccess", _190 => _190.type]) ? (path = update.node.get(key), void 0 !== path && (state[key] = lsonToJson(path))) : "delete" === _optionalChain([update, "access", _191 => _191.updates, "access", _192 => _192[key], "optionalAccess", _193 => _193.type]) && delete state[key];
          }
          return state;
      }
    }
    if (Array.isArray(state)) {
      var newArray = [...state];
      newArray[pathItem] = legacy_patchImmutableNode(state[pathItem], path, update);
      return newArray;
    }
    return isJsonObject(state) ? (newArray = state[pathItem], void 0 === newArray ? state : {...state, [pathItem]:legacy_patchImmutableNode(newArray, path, update)}) : state;
  }
  function deprecate(message, key = message) {
    _emittedDeprecationWarnings.has(key) || (_emittedDeprecationWarnings.add(key), errorWithTitle("Deprecation warning", message));
  }
  function throwUsageError(message) {
    const usageError = Error(message);
    usageError.name = "Usage error";
    errorWithTitle("Usage error", message);
    throw usageError;
  }
  function shallowObj(objA, objB) {
    if (!isPlainObject(objA) || !isPlainObject(objB)) {
      return !1;
    }
    const keysA = Object.keys(objA);
    return keysA.length !== Object.keys(objB).length ? !1 : keysA.every(key => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key]));
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  var __defProp = Object.defineProperty, g = "undefined" !== typeof globalThis ? globalThis : "undefined" !== typeof window ? window : "undefined" !== typeof global ? global : {}, fancy_console_exports = {};
  ((target, all) => {
    for (var name in all) {
      __defProp(target, name, {get:all[name], enumerable:!0});
    }
  })(fancy_console_exports, {error:() => error2, errorWithTitle:() => errorWithTitle, warn:() => warn, warnWithTitle:() => warnWithTitle});
  var warn = wrap("warn"), error2 = wrap("error"), warnWithTitle = wrapWithTitle("warn"), errorWithTitle = wrapWithTitle("error"), SafeContext = class {
    constructor(initialContext) {
      this.curr = initialContext;
    }
    get current() {
      return this.curr;
    }
    allowPatching(callback) {
      const self = this;
      let allowed = !0;
      callback({...this.curr, patch(patch) {
        if (allowed) {
          self.curr = Object.assign({}, self.curr, patch);
          for (const pair of Object.entries(patch)) {
            const [key, value] = pair;
            "patch" !== key && (this[key] = value);
          }
        } else {
          throw Error("Can no longer patch stale context");
        }
      }});
      allowed = !1;
    }
  }, nextId = 1, FSM = class {
    get initialState() {
      const result = this.states.values()[Symbol.iterator]().next();
      if (result.done) {
        throw Error("No states defined yet");
      }
      return result.value;
    }
    get currentState() {
      if (null === this.currentStateOrNull) {
        if (0 === this.runningState) {
          throw Error("Not started yet");
        }
        throw Error("Already stopped");
      }
      return this.currentStateOrNull;
    }
    start() {
      if (0 !== this.runningState) {
        throw Error("State machine has already started");
      }
      this.runningState = 1;
      this.currentStateOrNull = this.initialState;
      this.enter(null);
      return this;
    }
    stop() {
      if (1 !== this.runningState) {
        throw Error("Cannot stop a state machine that hasn't started yet");
      }
      this.exit(null);
      this.runningState = 2;
      this.currentStateOrNull = null;
    }
    constructor(initialContext) {
      this.id = nextId++;
      this.runningState = 0;
      this.currentStateOrNull = null;
      this.states = new Set();
      this.enterFns = new Map();
      this.cleanupStack = [];
      this.knownEventTypes = new Set();
      this.allowedTransitions = new Map();
      this.currentContext = new SafeContext(initialContext);
      this.eventHub = {didReceiveEvent:makeEventSource(), willTransition:makeEventSource(), didIgnoreEvent:makeEventSource(), willExitState:makeEventSource(), didEnterState:makeEventSource()};
      this.events = {didReceiveEvent:this.eventHub.didReceiveEvent.observable, willTransition:this.eventHub.willTransition.observable, didIgnoreEvent:this.eventHub.didIgnoreEvent.observable, willExitState:this.eventHub.willExitState.observable, didEnterState:this.eventHub.didEnterState.observable};
    }
    get context() {
      return this.currentContext.current;
    }
    addState(state) {
      if (0 !== this.runningState) {
        throw Error("Already started");
      }
      this.states.add(state);
      return this;
    }
    onEnter(nameOrPattern, enterFn) {
      if (0 !== this.runningState) {
        throw Error("Already started");
      }
      if (this.enterFns.has(nameOrPattern)) {
        throw Error(`enter/exit function for ${nameOrPattern} already exists`);
      }
      this.enterFns.set(nameOrPattern, enterFn);
      return this;
    }
    onEnterAsync(nameOrPattern, promiseFn, onOK, onError, maxTimeout) {
      return this.onEnter(nameOrPattern, () => {
        const abortController = new AbortController(), signal = abortController.signal, timeoutId = maxTimeout ? setTimeout(() => {
          this.transition({type:"ASYNC_ERROR", reason:Error("Timed out")}, onError);
        }, maxTimeout) : void 0;
        let done = !1;
        promiseFn(this.currentContext.current, signal).then(data => {
          signal.aborted || (done = !0, this.transition({type:"ASYNC_OK", data}, onOK));
        }, reason => {
          signal.aborted || (done = !0, this.transition({type:"ASYNC_ERROR", reason}, onError));
        });
        return () => {
          clearTimeout(timeoutId);
          done || abortController.abort();
        };
      });
    }
    getStatesMatching(nameOrPattern) {
      const matches = [];
      if ("*" === nameOrPattern) {
        for (var state$jscomp$0 of this.states) {
          matches.push(state$jscomp$0);
        }
      } else if (nameOrPattern.endsWith(".*")) {
        state$jscomp$0 = nameOrPattern.slice(0, -1);
        for (const state of this.states) {
          state.startsWith(state$jscomp$0) && matches.push(state);
        }
      } else {
        this.states.has(nameOrPattern) && matches.push(nameOrPattern);
      }
      if (0 === matches.length) {
        throw Error(`No states match ${JSON.stringify(nameOrPattern)}`);
      }
      return matches;
    }
    addTransitions(nameOrPattern, mapping) {
      if (0 !== this.runningState) {
        throw Error("Already started");
      }
      for (const srcState of this.getStatesMatching(nameOrPattern)) {
        let map = this.allowedTransitions.get(srcState);
        void 0 === map && (map = new Map(), this.allowedTransitions.set(srcState, map));
        for (const [type, target_] of Object.entries(mapping)) {
          if (map.has(type)) {
            throw Error(`Trying to set transition "${type}" on "${srcState}" (via "${nameOrPattern}"), but a transition already exists there.`);
          }
          const target = target_;
          this.knownEventTypes.add(type);
          void 0 !== target && map.set(type, "function" === typeof target ? target : () => target);
        }
      }
      return this;
    }
    addTimedTransition(stateOrPattern, after2, target) {
      return this.onEnter(stateOrPattern, () => {
        const ms = "function" === typeof after2 ? after2(this.currentContext.current) : after2, timeoutID = setTimeout(() => {
          this.transition({type:"TIMER"}, target);
        }, ms);
        return () => {
          clearTimeout(timeoutID);
        };
      });
    }
    getTargetFn(eventName) {
      return _optionalChain([this, "access", _3 => _3.allowedTransitions, "access", _4 => _4.get, "call", _5 => _5(this.currentState), "optionalAccess", _6 => _6.get, "call", _7 => _7(eventName)]);
    }
    exit(levels) {
      this.eventHub.willExitState.notify(this.currentState);
      this.currentContext.allowPatching(patchableContext => {
        levels = _nullishCoalesce(levels, () => this.cleanupStack.length);
        for (let i = 0; i < levels; i++) {
          _optionalChain([this, "access", _8 => _8.cleanupStack, "access", _9 => _9.pop, "call", _10 => _10(), "optionalCall", _11 => _11(patchableContext)]);
        }
      });
    }
    enter(levels) {
      const enterPatterns = patterns(this.currentState, _nullishCoalesce(levels, () => this.currentState.split(".").length + 1));
      this.currentContext.allowPatching(patchableContext => {
        for (const pattern of enterPatterns) {
          var enterFn = this.enterFns.get(pattern);
          enterFn = _optionalChain([enterFn, "optionalCall", _12 => _12(patchableContext)]);
          "function" === typeof enterFn ? this.cleanupStack.push(enterFn) : this.cleanupStack.push(null);
        }
      });
      this.eventHub.didEnterState.notify(this.currentState);
    }
    send(event) {
      if (!this.knownEventTypes.has(event.type)) {
        throw Error(`Invalid event ${JSON.stringify(event.type)}`);
      }
      if (2 !== this.runningState) {
        var targetFn = this.getTargetFn(event.type);
        if (void 0 !== targetFn) {
          return this.transition(event, targetFn);
        }
        this.eventHub.didIgnoreEvent.notify(event);
      }
    }
    transition(event, target) {
      this.eventHub.didReceiveEvent.notify(event);
      const oldState = this.currentState, nextTarget = ("function" === typeof target ? target : () => target)(event, this.currentContext.current);
      let nextState, effects = void 0;
      if (null === nextTarget) {
        this.eventHub.didIgnoreEvent.notify(event);
      } else {
        "string" === typeof nextTarget ? nextState = nextTarget : (nextState = nextTarget.target, effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect]);
        if (!this.states.has(nextState)) {
          throw Error(`Invalid next state name: ${JSON.stringify(nextState)}`);
        }
        this.eventHub.willTransition.notify({from:oldState, to:nextState});
        var [up, down] = distance(this.currentState, nextState);
        0 < up && this.exit(up);
        this.currentStateOrNull = nextState;
        if (void 0 !== effects) {
          const effectsToRun = effects;
          this.currentContext.allowPatching(patchableContext => {
            for (const effect of effectsToRun) {
              "function" === typeof effect ? effect(patchableContext, event) : patchableContext.patch(effect);
            }
          });
        }
        0 < down && this.enter(down);
      }
    }
  }, ServerMsgCode = (ServerMsgCode2 => {
    ServerMsgCode2[ServerMsgCode2.UPDATE_PRESENCE = 100] = "UPDATE_PRESENCE";
    ServerMsgCode2[ServerMsgCode2.USER_JOINED = 101] = "USER_JOINED";
    ServerMsgCode2[ServerMsgCode2.USER_LEFT = 102] = "USER_LEFT";
    ServerMsgCode2[ServerMsgCode2.BROADCASTED_EVENT = 103] = "BROADCASTED_EVENT";
    ServerMsgCode2[ServerMsgCode2.ROOM_STATE = 104] = "ROOM_STATE";
    ServerMsgCode2[ServerMsgCode2.INITIAL_STORAGE_STATE = 200] = "INITIAL_STORAGE_STATE";
    ServerMsgCode2[ServerMsgCode2.UPDATE_STORAGE = 201] = "UPDATE_STORAGE";
    ServerMsgCode2[ServerMsgCode2.REJECT_STORAGE_OP = 299] = "REJECT_STORAGE_OP";
    ServerMsgCode2[ServerMsgCode2.UPDATE_YDOC = 300] = "UPDATE_YDOC";
    ServerMsgCode2[ServerMsgCode2.THREAD_CREATED = 400] = "THREAD_CREATED";
    ServerMsgCode2[ServerMsgCode2.THREAD_DELETED = 407] = "THREAD_DELETED";
    ServerMsgCode2[ServerMsgCode2.THREAD_METADATA_UPDATED = 401] = "THREAD_METADATA_UPDATED";
    ServerMsgCode2[ServerMsgCode2.THREAD_UPDATED = 408] = "THREAD_UPDATED";
    ServerMsgCode2[ServerMsgCode2.COMMENT_CREATED = 402] = "COMMENT_CREATED";
    ServerMsgCode2[ServerMsgCode2.COMMENT_EDITED = 403] = "COMMENT_EDITED";
    ServerMsgCode2[ServerMsgCode2.COMMENT_DELETED = 404] = "COMMENT_DELETED";
    ServerMsgCode2[ServerMsgCode2.COMMENT_REACTION_ADDED = 405] = "COMMENT_REACTION_ADDED";
    ServerMsgCode2[ServerMsgCode2.COMMENT_REACTION_REMOVED = 406] = "COMMENT_REACTION_REMOVED";
    return ServerMsgCode2;
  })(ServerMsgCode || {}), WebsocketCloseCodes = (WebsocketCloseCodes2 => {
    WebsocketCloseCodes2[WebsocketCloseCodes2.CLOSE_NORMAL = 1e3] = "CLOSE_NORMAL";
    WebsocketCloseCodes2[WebsocketCloseCodes2.CLOSE_ABNORMAL = 1006] = "CLOSE_ABNORMAL";
    WebsocketCloseCodes2[WebsocketCloseCodes2.UNEXPECTED_CONDITION = 1011] = "UNEXPECTED_CONDITION";
    WebsocketCloseCodes2[WebsocketCloseCodes2.TRY_AGAIN_LATER = 1013] = "TRY_AGAIN_LATER";
    WebsocketCloseCodes2[WebsocketCloseCodes2.INVALID_MESSAGE_FORMAT = 4e3] = "INVALID_MESSAGE_FORMAT";
    WebsocketCloseCodes2[WebsocketCloseCodes2.NOT_ALLOWED = 4001] = "NOT_ALLOWED";
    WebsocketCloseCodes2[WebsocketCloseCodes2.MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002] = "MAX_NUMBER_OF_MESSAGES_PER_SECONDS";
    WebsocketCloseCodes2[WebsocketCloseCodes2.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS";
    WebsocketCloseCodes2[WebsocketCloseCodes2.MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004] = "MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP";
    WebsocketCloseCodes2[WebsocketCloseCodes2.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM";
    WebsocketCloseCodes2[WebsocketCloseCodes2.ROOM_ID_UPDATED = 4006] = "ROOM_ID_UPDATED";
    WebsocketCloseCodes2[WebsocketCloseCodes2.KICKED = 4100] = "KICKED";
    WebsocketCloseCodes2[WebsocketCloseCodes2.TOKEN_EXPIRED = 4109] = "TOKEN_EXPIRED";
    WebsocketCloseCodes2[WebsocketCloseCodes2.CLOSE_WITHOUT_RETRY = 4999] = "CLOSE_WITHOUT_RETRY";
    return WebsocketCloseCodes2;
  })(WebsocketCloseCodes || {}), BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4], RESET_DELAY = BACKOFF_DELAYS[0] - 1, BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5], StopRetrying = class extends Error {
    constructor(reason) {
      super(reason);
    }
  }, LiveblocksError = class extends Error {
    constructor(message, code) {
      super(message);
      this.code = code;
    }
  }, logPermanentClose = log(1, "Connection to WebSocket closed permanently. Won't retry."), assign = patch => ctx => ctx.patch(patch), ManagedSocket = class {
    constructor(delegates, enableDebugLogging = !1, waitForActorId = !0) {
      const {machine, events, cleanups} = createConnectionStateMachine(delegates, {waitForActorId, enableDebugLogging});
      this.machine = machine;
      this.events = events;
      this.cleanups = cleanups;
    }
    getStatus() {
      try {
        return toNewConnectionStatus(this.machine);
      } catch (e2) {
        return "initial";
      }
    }
    get authValue() {
      return this.machine.context.authValue;
    }
    connect() {
      this.machine.send({type:"CONNECT"});
    }
    reconnect() {
      this.machine.send({type:"RECONNECT"});
    }
    disconnect() {
      this.machine.send({type:"DISCONNECT"});
    }
    destroy() {
      this.machine.stop();
      let cleanup;
      for (; cleanup = this.cleanups.pop();) {
        cleanup();
      }
    }
    send(data) {
      const socket = _optionalChain([this, "access", _33 => _33.machine, "access", _34 => _34.context, "optionalAccess", _35 => _35.socket]);
      null === socket ? warn("Cannot send: not connected yet", data) : 1 !== socket.readyState ? warn("Cannot send: WebSocket no longer open", data) : socket.send(data);
    }
    _privateSendMachineEvent(event) {
      this.machine.send(event);
    }
  }, kInternal = Symbol(), _bridgeActive = !1, eventSource = makeEventSource();
  "undefined" !== typeof window && window.addEventListener("message", event => {
    event.source === window && "liveblocks-devtools-panel" === _optionalChain([event, "access", _39 => _39.data, "optionalAccess", _40 => _40.source]) && eventSource.notify(event.data);
  });
  var onMessageFromPanel = eventSource.observable, _devtoolsSetupHasRun = !1, unsubsByRoomId = new Map(), loadedAt = Date.now(), eventCounter = 0, roomChannelListeners = new Map(), BatchCall = class {
    constructor(input) {
      this.input = input;
      const {promise, resolve, reject} = Promise_withResolvers();
      this.promise = promise;
      this.resolve = resolve;
      this.reject = reject;
    }
  }, Batch = class {
    constructor(callback, options) {
      this.queue = [];
      this.error = !1;
      this.callback = callback;
      this.size = _nullishCoalesce(options.size, () => 50);
      this.delay = options.delay;
    }
    clearDelayTimeout() {
      void 0 !== this.delayTimeoutId && (clearTimeout(this.delayTimeoutId), this.delayTimeoutId = void 0);
    }
    schedule() {
      this.queue.length === this.size ? this.flush() : 1 === this.queue.length && (this.clearDelayTimeout(), this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay));
    }
    async flush() {
      if (0 !== this.queue.length) {
        var calls = this.queue.splice(0), inputs = calls.map(call => call.input);
        try {
          const results = await this.callback(inputs);
          this.error = !1;
          calls.forEach((call, index) => {
            const result = _optionalChain([results, "optionalAccess", _44 => _44[index]]);
            Array.isArray(results) ? calls.length !== results.length ? call.reject(Error(`Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`)) : result instanceof Error ? call.reject(result) : call.resolve(result) : call.reject(Error("Callback must return an array."));
          });
        } catch (error3) {
          this.error = !0, calls.forEach(call => {
            call.reject(error3);
          });
        }
      }
    }
    get(input) {
      var existingCall = this.queue.find(call2 => stringify(call2.input) === stringify(input));
      if (existingCall) {
        return existingCall.promise;
      }
      existingCall = new BatchCall(input);
      this.queue.push(existingCall);
      this.schedule();
      return existingCall.promise;
    }
    clear() {
      this.queue = [];
      this.error = !1;
      this.clearDelayTimeout();
    }
  }, HttpError = class extends Error {
    constructor(message, status, details) {
      super(message);
      this.message = message;
      this.status = status;
      this.details = details;
    }
  }, DONT_RETRY_4XX = x => x instanceof HttpError && 400 <= x.status && 500 > x.status, HttpClient = class {
    constructor(baseUrl, fetchPolyfill, authCallback) {
      this._baseUrl = baseUrl;
      this._fetchPolyfill = fetchPolyfill;
      this._authCallback = authCallback;
    }
    async rawFetch(endpoint, options, params) {
      endpoint.startsWith("/v2/c/") || raise("This client can only be used to make /v2/c/* requests");
      endpoint = urljoin(this._baseUrl, endpoint, params);
      return await this._fetchPolyfill(endpoint, {...options, headers:{"Content-Type":"application/json; charset\x3dutf-8", ..._optionalChain([options, "optionalAccess", _45 => _45.headers]), Authorization:`Bearer ${getBearerTokenFromAuthValue(await this._authCallback())}`, "X-LB-Client":"2.10.2"}});
    }
    async fetch(endpoint, options, params) {
      endpoint = await this.rawFetch(endpoint, options, params);
      if (!endpoint.ok) {
        let error3;
        try {
          const errorBody = await endpoint.json();
          error3 = new HttpError(errorBody.message, endpoint.status, errorBody);
        } catch (e3) {
          error3 = new HttpError(endpoint.statusText, endpoint.status);
        }
        throw error3;
      }
      let body;
      try {
        body = await endpoint.json();
      } catch (e4) {
        body = {};
      }
      return body;
    }
    async rawGet(endpoint, params, options) {
      return await this.rawFetch(endpoint, options, params);
    }
    async rawPost(endpoint, body) {
      return await this.rawFetch(endpoint, {method:"POST", body:JSON.stringify(body)});
    }
    async rawDelete(endpoint) {
      return await this.rawFetch(endpoint, {method:"DELETE"});
    }
    async get(endpoint, params, options) {
      return await this.fetch(endpoint, options, params);
    }
    async post(endpoint, body, options, params) {
      return await this.fetch(endpoint, {...options, method:"POST", body:JSON.stringify(body)}, params);
    }
    async delete(endpoint) {
      return await this.fetch(endpoint, {method:"DELETE"});
    }
    async putBlob(endpoint, blob, params, options) {
      return await this.fetch(endpoint, {...options, method:"PUT", headers:{"Content-Type":"application/octet-stream"}, body:blob}, params);
    }
  }, ZERO = nthDigit(0), ONE = nthDigit(1), ZERO_NINE = ZERO + nthDigit(-1), OpCode = (OpCode2 => {
    OpCode2[OpCode2.INIT = 0] = "INIT";
    OpCode2[OpCode2.SET_PARENT_KEY = 1] = "SET_PARENT_KEY";
    OpCode2[OpCode2.CREATE_LIST = 2] = "CREATE_LIST";
    OpCode2[OpCode2.UPDATE_OBJECT = 3] = "UPDATE_OBJECT";
    OpCode2[OpCode2.CREATE_OBJECT = 4] = "CREATE_OBJECT";
    OpCode2[OpCode2.DELETE_CRDT = 5] = "DELETE_CRDT";
    OpCode2[OpCode2.DELETE_OBJECT_KEY = 6] = "DELETE_OBJECT_KEY";
    OpCode2[OpCode2.CREATE_MAP = 7] = "CREATE_MAP";
    OpCode2[OpCode2.CREATE_REGISTER = 8] = "CREATE_REGISTER";
    return OpCode2;
  })(OpCode || {}), NoParent = Object.freeze({type:"NoParent"}), AbstractCrdt = class {
    constructor() {
      this._parent = NoParent;
    }
    _getParentKeyOrThrow() {
      switch(this.parent.type) {
        case "HasParent":
          return this.parent.key;
        case "NoParent":
          throw Error("Parent key is missing");
        case "Orphaned":
          return this.parent.oldKey;
        default:
          return assertNever(this.parent, "Unknown state");
      }
    }
    get _parentPos() {
      switch(this.parent.type) {
        case "HasParent":
          return this.parent.pos;
        case "NoParent":
          throw Error("Parent key is missing");
        case "Orphaned":
          return this.parent.oldPos;
        default:
          return assertNever(this.parent, "Unknown state");
      }
    }
    get _pool() {
      return this.__pool;
    }
    get roomId() {
      return this.__pool ? this.__pool.roomId : null;
    }
    get _id() {
      return this.__id;
    }
    get parent() {
      return this._parent;
    }
    get _parentKey() {
      switch(this.parent.type) {
        case "HasParent":
          return this.parent.key;
        case "NoParent":
          return null;
        case "Orphaned":
          return this.parent.oldKey;
        default:
          return assertNever(this.parent, "Unknown state");
      }
    }
    _apply(op, _isLocal) {
      switch(op.type) {
        case 5:
          if ("HasParent" === this.parent.type) {
            return this.parent.node._detachChild(this);
          }
      }
      return {modified:!1};
    }
    _setParentLink(newParentNode, newParentKey) {
      switch(this.parent.type) {
        case "HasParent":
          if (this.parent.node !== newParentNode) {
            throw Error("Cannot set parent: node already has a parent");
          }
          this._parent = HasParent(newParentNode, newParentKey);
          break;
        case "Orphaned":
        case "NoParent":
          this._parent = HasParent(newParentNode, newParentKey);
          break;
        default:
          return assertNever(this.parent, "Unknown state");
      }
    }
    _attach(id, pool) {
      if (this.__id || this.__pool) {
        throw Error("Cannot attach node: already attached");
      }
      pool.addNode(id, this);
      this.__id = id;
      this.__pool = pool;
    }
    _detach() {
      this.__pool && this.__id && this.__pool.deleteNode(this.__id);
      switch(this.parent.type) {
        case "HasParent":
          this._parent = Orphaned(this.parent.key, this.parent.pos);
          break;
        case "NoParent":
          this._parent = NoParent;
          break;
        case "Orphaned":
          break;
        default:
          assertNever(this.parent, "Unknown state");
      }
      this.__pool = void 0;
    }
    invalidate() {
      if (void 0 !== this._cachedImmutable || void 0 !== this._cachedTreeNode) {
        this._cachedTreeNode = this._cachedImmutable = void 0, "HasParent" === this.parent.type && this.parent.node.invalidate();
      }
    }
    toTreeNode(key) {
      if (void 0 === this._cachedTreeNode || this._cachedTreeNodeKey !== key) {
        this._cachedTreeNodeKey = key, this._cachedTreeNode = this._toTreeNode(key);
      }
      return this._cachedTreeNode;
    }
    toImmutable() {
      void 0 === this._cachedImmutable && (this._cachedImmutable = this._toImmutable());
      return this._cachedImmutable;
    }
  }, CrdtType = (CrdtType2 => {
    CrdtType2[CrdtType2.OBJECT = 0] = "OBJECT";
    CrdtType2[CrdtType2.LIST = 1] = "LIST";
    CrdtType2[CrdtType2.MAP = 2] = "MAP";
    CrdtType2[CrdtType2.REGISTER = 3] = "REGISTER";
    return CrdtType2;
  })(CrdtType || {}), nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce((t2, e) => t2 + (36 > (e &= 63) ? e.toString(36) : 62 > e ? (e - 26).toString(36).toUpperCase() : 63 > e ? "_" : "-"), "");
  const node_modules$$liveblocks$core$dist$index$classdecl$var0 = class extends AbstractCrdt {
    constructor(data) {
      super();
      this._data = data;
    }
    get data() {
      return this._data;
    }
    static _deserialize([id, item], _parentToChildren, pool) {
      item = new node_modules$$liveblocks$core$dist$index$classdecl$var0(item.data);
      item._attach(id, pool);
      return item;
    }
    _toOps(parentId, parentKey, pool) {
      if (void 0 === this._id) {
        throw Error("Cannot serialize register if parentId or parentKey is undefined");
      }
      return [{type:8, opId:_optionalChain([pool, "optionalAccess", _49 => _49.generateOpId, "call", _50 => _50()]), id:this._id, parentId, parentKey, data:this.data}];
    }
    _serialize() {
      if ("HasParent" !== this.parent.type) {
        throw Error("Cannot serialize LiveRegister if parent is missing");
      }
      return {type:3, parentId:nn(this.parent.node._id, "Parent node expected to have ID"), parentKey:this.parent.key, data:this.data};
    }
    _attachChild(_op) {
      throw Error("Method not implemented.");
    }
    _detachChild(_crdt) {
      throw Error("Method not implemented.");
    }
    _apply(op, isLocal) {
      return super._apply(op, isLocal);
    }
    _toTreeNode(key) {
      return {type:"Json", id:_nullishCoalesce(this._id, () => nanoid()), key, payload:this._data};
    }
    _toImmutable() {
      return this._data;
    }
    clone() {
      return deepClone(this.data);
    }
  };
  var LiveRegister = node_modules$$liveblocks$core$dist$index$classdecl$var0;
  const node_modules$$liveblocks$core$dist$index$classdecl$var1 = class extends AbstractCrdt {
    constructor(items) {
      super();
      this._items = [];
      this._implicitlyDeletedItems = new WeakSet();
      this._unacknowledgedSets = new Map();
      var position = void 0;
      for (const item of items) {
        items = makePosition(position), position = lsonToLiveNode(item), position._setParentLink(this, items), this._items.push(position), position = items;
      }
    }
    static _deserialize([id], parentToChildren, pool) {
      const list = new node_modules$$liveblocks$core$dist$index$classdecl$var1([]);
      list._attach(id, pool);
      id = parentToChildren.get(id);
      if (void 0 === id) {
        return list;
      }
      for (const [id2, crdt] of id) {
        id = deserialize([id2, crdt], parentToChildren, pool), id._setParentLink(list, crdt.parentKey), list._insertAndSort(id);
      }
      return list;
    }
    _toOps(parentId, parentKey, pool) {
      if (void 0 === this._id) {
        throw Error("Cannot serialize item is not attached");
      }
      const ops = [];
      parentId = {id:this._id, opId:_optionalChain([pool, "optionalAccess", _51 => _51.generateOpId, "call", _52 => _52()]), type:2, parentId, parentKey};
      ops.push(parentId);
      for (const item of this._items) {
        parentId = item._getParentKeyOrThrow();
        parentKey = HACK_addIntentAndDeletedIdToOperation(item._toOps(this._id, parentId, pool), void 0);
        const childOpId = parentKey[0].opId;
        void 0 !== childOpId && this._unacknowledgedSets.set(parentId, childOpId);
        ops.push(...parentKey);
      }
      return ops;
    }
    _insertAndSort(item) {
      this._items.push(item);
      this._sortItems();
    }
    _sortItems() {
      this._items.sort(compareNodePosition);
      this.invalidate();
    }
    _indexOfPosition(position) {
      return this._items.findIndex(item => item._getParentKeyOrThrow() === position);
    }
    _attach(id, pool) {
      super._attach(id, pool);
      for (const item of this._items) {
        item._attach(pool.generateId(), pool);
      }
    }
    _detach() {
      super._detach();
      for (const item of this._items) {
        item._detach();
      }
    }
    _applySetRemote(op) {
      if (void 0 === this._pool) {
        throw Error("Can't attach child if managed pool is not present");
      }
      const {id, parentKey:key} = op;
      var child = lsonToLiveNode(creationOpToLson(op));
      child._attach(id, this._pool);
      child._setParentLink(this, key);
      var deletedId = op.deletedId;
      const indexOfItemWithSamePosition = this._indexOfPosition(key);
      if (-1 !== indexOfItemWithSamePosition) {
        const itemWithSamePosition = this._items[indexOfItemWithSamePosition];
        if (itemWithSamePosition._id === deletedId) {
          return itemWithSamePosition._detach(), this._items[indexOfItemWithSamePosition] = child, {modified:makeUpdate(this, [setDelta(indexOfItemWithSamePosition, child)]), reverse:[]};
        }
        this._implicitlyDeletedItems.add(itemWithSamePosition);
        this._items[indexOfItemWithSamePosition] = child;
        child = [setDelta(indexOfItemWithSamePosition, child)];
        (op = this._detachItemAssociatedToSetOperation(op.deletedId)) && child.push(op);
        return {modified:makeUpdate(this, child), reverse:[]};
      }
      deletedId = [];
      (op = this._detachItemAssociatedToSetOperation(op.deletedId)) && deletedId.push(op);
      this._insertAndSort(child);
      deletedId.push(insertDelta(this._indexOfPosition(key), child));
      return {reverse:[], modified:makeUpdate(this, deletedId)};
    }
    _applySetAck(op) {
      if (void 0 === this._pool) {
        throw Error("Can't attach child if managed pool is not present");
      }
      const delta = [];
      var deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);
      deletedDelta && delta.push(deletedDelta);
      deletedDelta = this._unacknowledgedSets.get(op.parentKey);
      if (void 0 !== deletedDelta) {
        if (deletedDelta !== op.opId) {
          return 0 === delta.length ? {modified:!1} : {modified:makeUpdate(this, delta), reverse:[]};
        }
        this._unacknowledgedSets.delete(op.parentKey);
      }
      deletedDelta = this._indexOfPosition(op.parentKey);
      var existingItem = this._items.find(item => item._id === op.id);
      if (void 0 !== existingItem) {
        if (existingItem._parentKey === op.parentKey) {
          return {modified:0 < delta.length ? makeUpdate(this, delta) : !1, reverse:[]};
        }
        if (-1 !== deletedDelta) {
          this._implicitlyDeletedItems.add(this._items[deletedDelta]);
          var [prevNode] = this._items.splice(deletedDelta, 1);
          delta.push(deleteDelta(deletedDelta, prevNode));
        }
        deletedDelta = this._items.indexOf(existingItem);
        existingItem._setParentLink(this, op.parentKey);
        this._sortItems();
        prevNode = this._items.indexOf(existingItem);
        prevNode !== deletedDelta && delta.push(moveDelta(deletedDelta, prevNode, existingItem));
        return {modified:0 < delta.length ? makeUpdate(this, delta) : !1, reverse:[]};
      }
      if ((existingItem = this._pool.getNode(op.id)) && this._implicitlyDeletedItems.has(existingItem)) {
        return existingItem._setParentLink(this, op.parentKey), this._implicitlyDeletedItems.delete(existingItem), this._insertAndSort(existingItem), prevNode = this._items.indexOf(existingItem), {modified:makeUpdate(this, [-1 === deletedDelta ? insertDelta(prevNode, existingItem) : setDelta(prevNode, existingItem), ...delta]), reverse:[]};
      }
      -1 !== deletedDelta && this._items.splice(deletedDelta, 1);
      const {newItem, newIndex} = this._createAttachItemAndSort(op, op.parentKey);
      return {modified:makeUpdate(this, [-1 === deletedDelta ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem), ...delta]), reverse:[]};
    }
    _detachItemAssociatedToSetOperation(deletedId) {
      if (void 0 === deletedId || void 0 === this._pool) {
        return null;
      }
      deletedId = this._pool.getNode(deletedId);
      if (void 0 === deletedId) {
        return null;
      }
      deletedId = this._detachChild(deletedId);
      return !1 === deletedId.modified ? null : deletedId.modified.updates[0];
    }
    _applyRemoteInsert(op) {
      if (void 0 === this._pool) {
        throw Error("Can't attach child if managed pool is not present");
      }
      const key = asPos(op.parentKey), existingItemIndex = this._indexOfPosition(key);
      -1 !== existingItemIndex && this._shiftItemPosition(existingItemIndex, key);
      const {newItem, newIndex} = this._createAttachItemAndSort(op, key);
      return {modified:makeUpdate(this, [insertDelta(newIndex, newItem)]), reverse:[]};
    }
    _applyInsertAck(op) {
      var existingItem = this._items.find(item => item._id === op.id), key = asPos(op.parentKey);
      const itemIndexAtPosition = this._indexOfPosition(key);
      if (existingItem) {
        if (existingItem._parentKey === key) {
          return {modified:!1};
        }
        const oldPositionIndex = this._items.indexOf(existingItem);
        -1 !== itemIndexAtPosition && this._shiftItemPosition(itemIndexAtPosition, key);
        existingItem._setParentLink(this, key);
        this._sortItems();
        key = this._indexOfPosition(key);
        return key === oldPositionIndex ? {modified:!1} : {modified:makeUpdate(this, [moveDelta(oldPositionIndex, key, existingItem)]), reverse:[]};
      }
      if ((existingItem = nn(this._pool).getNode(op.id)) && this._implicitlyDeletedItems.has(existingItem)) {
        return existingItem._setParentLink(this, key), this._implicitlyDeletedItems.delete(existingItem), this._insertAndSort(existingItem), key = this._indexOfPosition(key), {modified:makeUpdate(this, [insertDelta(key, existingItem)]), reverse:[]};
      }
      -1 !== itemIndexAtPosition && this._shiftItemPosition(itemIndexAtPosition, key);
      const {newItem, newIndex} = this._createAttachItemAndSort(op, key);
      return {modified:makeUpdate(this, [insertDelta(newIndex, newItem)]), reverse:[]};
    }
    _applyInsertUndoRedo(op) {
      const {id, parentKey:key} = op;
      op = lsonToLiveNode(creationOpToLson(op));
      if (void 0 !== _optionalChain([this, "access", _53 => _53._pool, "optionalAccess", _54 => _54.getNode, "call", _55 => _55(id)])) {
        return {modified:!1};
      }
      op._attach(id, nn(this._pool));
      op._setParentLink(this, key);
      const existingItemIndex = this._indexOfPosition(key);
      var newKey = key;
      if (-1 !== existingItemIndex) {
        newKey = _optionalChain([this, "access", _56 => _56._items, "access", _57 => _57[existingItemIndex], "optionalAccess", _58 => _58._parentPos]);
        const after2 = _optionalChain([this, "access", _59 => _59._items, "access", _60 => _60[existingItemIndex + 1], "optionalAccess", _61 => _61._parentPos]);
        newKey = makePosition(newKey, after2);
        op._setParentLink(this, newKey);
      }
      this._insertAndSort(op);
      newKey = this._indexOfPosition(newKey);
      return {modified:makeUpdate(this, [insertDelta(newKey, op)]), reverse:[{type:5, id}]};
    }
    _applySetUndoRedo(op) {
      const {id, parentKey:key} = op;
      var child = lsonToLiveNode(creationOpToLson(op));
      if (void 0 !== _optionalChain([this, "access", _62 => _62._pool, "optionalAccess", _63 => _63.getNode, "call", _64 => _64(id)])) {
        return {modified:!1};
      }
      this._unacknowledgedSets.set(key, nn(op.opId));
      const indexOfItemWithSameKey = this._indexOfPosition(key);
      child._attach(id, nn(this._pool));
      child._setParentLink(this, key);
      if (-1 !== indexOfItemWithSameKey) {
        var existingItem = this._items[indexOfItemWithSameKey];
        existingItem._detach();
        this._items[indexOfItemWithSameKey] = child;
        existingItem = HACK_addIntentAndDeletedIdToOperation(existingItem._toOps(nn(this._id), key, this._pool), op.id);
        child = [setDelta(indexOfItemWithSameKey, child)];
        (op = this._detachItemAssociatedToSetOperation(op.deletedId)) && child.push(op);
        return {modified:makeUpdate(this, child), reverse:existingItem};
      }
      this._insertAndSort(child);
      this._detachItemAssociatedToSetOperation(op.deletedId);
      op = this._indexOfPosition(key);
      return {reverse:[{type:5, id}], modified:makeUpdate(this, [insertDelta(op, child)])};
    }
    _attachChild(op, source) {
      if (void 0 === this._pool) {
        throw Error("Can't attach child if managed pool is not present");
      }
      op = "set" === op.intent ? 1 === source ? this._applySetRemote(op) : 2 === source ? this._applySetAck(op) : this._applySetUndoRedo(op) : 1 === source ? this._applyRemoteInsert(op) : 2 === source ? this._applyInsertAck(op) : this._applyInsertUndoRedo(op);
      !1 !== op.modified && this.invalidate();
      return op;
    }
    _detachChild(child) {
      if (child) {
        var parentKey = nn(child._parentKey);
        parentKey = child._toOps(nn(this._id), parentKey, this._pool);
        const indexToDelete = this._items.indexOf(child);
        if (-1 === indexToDelete) {
          return {modified:!1};
        }
        const [previousNode] = this._items.splice(indexToDelete, 1);
        this.invalidate();
        child._detach();
        return {modified:makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]), reverse:parentKey};
      }
      return {modified:!1};
    }
    _applySetChildKeyRemote(newKey, child) {
      if (this._implicitlyDeletedItems.has(child)) {
        return this._implicitlyDeletedItems.delete(child), child._setParentLink(this, newKey), this._insertAndSort(child), newKey = this._items.indexOf(child), {modified:makeUpdate(this, [insertDelta(newKey, child)]), reverse:[]};
      }
      if (newKey === child._parentKey) {
        return {modified:!1};
      }
      const existingItemIndex = this._indexOfPosition(newKey);
      if (-1 === existingItemIndex) {
        var previousIndex = this._items.indexOf(child);
        child._setParentLink(this, newKey);
        this._sortItems();
        newKey = this._items.indexOf(child);
        return newKey === previousIndex ? {modified:!1} : {modified:makeUpdate(this, [moveDelta(previousIndex, newKey, child)]), reverse:[]};
      }
      this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, _optionalChain([this, "access", _65 => _65._items, "access", _66 => _66[existingItemIndex + 1], "optionalAccess", _67 => _67._parentPos])));
      previousIndex = this._items.indexOf(child);
      child._setParentLink(this, newKey);
      this._sortItems();
      newKey = this._items.indexOf(child);
      return newKey === previousIndex ? {modified:!1} : {modified:makeUpdate(this, [moveDelta(previousIndex, newKey, child)]), reverse:[]};
    }
    _applySetChildKeyAck(newKey, child) {
      var previousKey = nn(child._parentKey);
      if (this._implicitlyDeletedItems.has(child)) {
        const existingItemIndex = this._indexOfPosition(newKey);
        this._implicitlyDeletedItems.delete(child);
        -1 !== existingItemIndex && this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, _optionalChain([this, "access", _68 => _68._items, "access", _69 => _69[existingItemIndex + 1], "optionalAccess", _70 => _70._parentPos])));
        child._setParentLink(this, newKey);
        this._insertAndSort(child);
        return {modified:!1};
      }
      if (newKey === previousKey) {
        return {modified:!1};
      }
      previousKey = this._items.indexOf(child);
      const existingItemIndex = this._indexOfPosition(newKey);
      -1 !== existingItemIndex && this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, _optionalChain([this, "access", _71 => _71._items, "access", _72 => _72[existingItemIndex + 1], "optionalAccess", _73 => _73._parentPos])));
      child._setParentLink(this, newKey);
      this._sortItems();
      newKey = this._items.indexOf(child);
      return previousKey === newKey ? {modified:!1} : {modified:makeUpdate(this, [moveDelta(previousKey, newKey, child)]), reverse:[]};
    }
    _applySetChildKeyUndoRedo(newKey, child) {
      const previousKey = nn(child._parentKey), previousIndex = this._items.indexOf(child), existingItemIndex = this._indexOfPosition(newKey);
      -1 !== existingItemIndex && this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, _optionalChain([this, "access", _74 => _74._items, "access", _75 => _75[existingItemIndex + 1], "optionalAccess", _76 => _76._parentPos])));
      child._setParentLink(this, newKey);
      this._sortItems();
      newKey = this._items.indexOf(child);
      return previousIndex === newKey ? {modified:!1} : {modified:makeUpdate(this, [moveDelta(previousIndex, newKey, child)]), reverse:[{type:1, id:nn(child._id), parentKey:previousKey}]};
    }
    _setChildKey(newKey, child, source) {
      return 1 === source ? this._applySetChildKeyRemote(newKey, child) : 2 === source ? this._applySetChildKeyAck(newKey, child) : this._applySetChildKeyUndoRedo(newKey, child);
    }
    _apply(op, isLocal) {
      return super._apply(op, isLocal);
    }
    _serialize() {
      if ("HasParent" !== this.parent.type) {
        throw Error("Cannot serialize LiveList if parent is missing");
      }
      return {type:1, parentId:nn(this.parent.node._id, "Parent node expected to have ID"), parentKey:this.parent.key};
    }
    get length() {
      return this._items.length;
    }
    push(element) {
      _optionalChain([this, "access", _77 => _77._pool, "optionalAccess", _78 => _78.assertStorageIsWritable, "call", _79 => _79()]);
      return this.insert(element, this.length);
    }
    insert(element, index) {
      _optionalChain([this, "access", _80 => _80._pool, "optionalAccess", _81 => _81.assertStorageIsWritable, "call", _82 => _82()]);
      if (0 > index || index > this._items.length) {
        throw Error(`Cannot insert list item at index "${index}". index should be between 0 and ${this._items.length}`);
      }
      const position = makePosition(this._items[index - 1] ? this._items[index - 1]._parentPos : void 0, this._items[index] ? this._items[index]._parentPos : void 0);
      element = lsonToLiveNode(element);
      element._setParentLink(this, position);
      this._insertAndSort(element);
      if (this._pool && this._id) {
        const id = this._pool.generateId();
        element._attach(id, this._pool);
        this._pool.dispatch(element._toOps(this._id, position, this._pool), [{type:5, id}], new Map([[this._id, makeUpdate(this, [insertDelta(index, element)])]]));
      }
    }
    move(index, targetIndex) {
      _optionalChain([this, "access", _83 => _83._pool, "optionalAccess", _84 => _84.assertStorageIsWritable, "call", _85 => _85()]);
      if (0 > targetIndex) {
        throw Error("targetIndex cannot be less than 0");
      }
      if (targetIndex >= this._items.length) {
        throw Error("targetIndex cannot be greater or equal than the list length");
      }
      if (0 > index) {
        throw Error("index cannot be less than 0");
      }
      if (index >= this._items.length) {
        throw Error("index cannot be greater or equal than the list length");
      }
      var beforePosition = null, afterPosition = null;
      index < targetIndex ? (afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos, beforePosition = this._items[targetIndex]._parentPos) : (afterPosition = this._items[targetIndex]._parentPos, beforePosition = 0 === targetIndex ? void 0 : this._items[targetIndex - 1]._parentPos);
      beforePosition = makePosition(beforePosition, afterPosition);
      afterPosition = this._items[index];
      const previousPosition = afterPosition._getParentKeyOrThrow();
      afterPosition._setParentLink(this, beforePosition);
      this._sortItems();
      this._pool && this._id && (index = new Map([[this._id, makeUpdate(this, [moveDelta(index, targetIndex, afterPosition)])]]), this._pool.dispatch([{type:1, id:nn(afterPosition._id), opId:this._pool.generateOpId(), parentKey:beforePosition}], [{type:1, id:nn(afterPosition._id), parentKey:previousPosition}], index));
    }
    delete(index) {
      _optionalChain([this, "access", _86 => _86._pool, "optionalAccess", _87 => _87.assertStorageIsWritable, "call", _88 => _88()]);
      if (0 > index || index >= this._items.length) {
        throw Error(`Cannot delete list item at index "${index}". index should be between 0 and ${this._items.length - 1}`);
      }
      const item = this._items[index];
      item._detach();
      const [prev] = this._items.splice(index, 1);
      this.invalidate();
      if (this._pool) {
        const childRecordId = item._id;
        if (childRecordId) {
          const storageUpdates = new Map();
          storageUpdates.set(nn(this._id), makeUpdate(this, [deleteDelta(index, prev)]));
          this._pool.dispatch([{id:childRecordId, opId:this._pool.generateOpId(), type:5}], item._toOps(nn(this._id), item._getParentKeyOrThrow()), storageUpdates);
        }
      }
    }
    clear() {
      _optionalChain([this, "access", _89 => _89._pool, "optionalAccess", _90 => _90.assertStorageIsWritable, "call", _91 => _91()]);
      if (this._pool) {
        var ops = [];
        const reverseOps = [], updateDelta = [];
        for (var item of this._items) {
          item._detach();
          const childId = item._id;
          childId && (ops.push({type:5, id:childId, opId:this._pool.generateOpId()}), reverseOps.push(...item._toOps(nn(this._id), item._getParentKeyOrThrow())), updateDelta.push(deleteDelta(0, item)));
        }
        this._items = [];
        this.invalidate();
        item = new Map();
        item.set(nn(this._id), makeUpdate(this, updateDelta));
        this._pool.dispatch(ops, reverseOps, item);
      } else {
        for (ops of this._items) {
          ops._detach();
        }
        this._items = [];
        this.invalidate();
      }
    }
    set(index, item) {
      _optionalChain([this, "access", _92 => _92._pool, "optionalAccess", _93 => _93.assertStorageIsWritable, "call", _94 => _94()]);
      if (0 > index || index >= this._items.length) {
        throw Error(`Cannot set list item at index "${index}". index should be between 0 and ${this._items.length - 1}`);
      }
      var existingItem = this._items[index];
      const position = existingItem._getParentKeyOrThrow(), existingId = existingItem._id;
      existingItem._detach();
      const value = lsonToLiveNode(item);
      value._setParentLink(this, position);
      this._items[index] = value;
      this.invalidate();
      if (this._pool && this._id) {
        const id = this._pool.generateId();
        value._attach(id, this._pool);
        item = new Map();
        item.set(this._id, makeUpdate(this, [setDelta(index, value)]));
        index = HACK_addIntentAndDeletedIdToOperation(value._toOps(this._id, position, this._pool), existingId);
        this._unacknowledgedSets.set(position, nn(index[0].opId));
        existingItem = HACK_addIntentAndDeletedIdToOperation(existingItem._toOps(this._id, position, void 0), id);
        this._pool.dispatch(index, existingItem, item);
      }
    }
    toArray() {
      return this._items.map(entry => liveNodeToLson(entry));
    }
    every(predicate) {
      return this.toArray().every(predicate);
    }
    filter(predicate) {
      return this.toArray().filter(predicate);
    }
    find(predicate) {
      return this.toArray().find(predicate);
    }
    findIndex(predicate) {
      return this.toArray().findIndex(predicate);
    }
    forEach(callbackfn) {
      return this.toArray().forEach(callbackfn);
    }
    get(index) {
      if (!(0 > index || index >= this._items.length)) {
        return liveNodeToLson(this._items[index]);
      }
    }
    indexOf(searchElement, fromIndex) {
      return this.toArray().indexOf(searchElement, fromIndex);
    }
    lastIndexOf(searchElement, fromIndex) {
      return this.toArray().lastIndexOf(searchElement, fromIndex);
    }
    map(callback) {
      return this._items.map((entry, i) => callback(liveNodeToLson(entry), i));
    }
    some(predicate) {
      return this.toArray().some(predicate);
    }
    [Symbol.iterator]() {
      return new LiveListIterator(this._items);
    }
    _createAttachItemAndSort(op, key) {
      const newItem = lsonToLiveNode(creationOpToLson(op));
      newItem._attach(op.id, nn(this._pool));
      newItem._setParentLink(this, key);
      this._insertAndSort(newItem);
      op = this._indexOfPosition(key);
      return {newItem, newIndex:op};
    }
    _shiftItemPosition(index, key) {
      key = makePosition(key, this._items.length > index + 1 ? _optionalChain([this, "access", _95 => _95._items, "access", _96 => _96[index + 1], "optionalAccess", _97 => _97._parentPos]) : void 0);
      this._items[index]._setParentLink(this, key);
    }
    _toTreeNode(key) {
      return {type:"LiveList", id:_nullishCoalesce(this._id, () => nanoid()), key, payload:this._items.map((item, index) => item.toTreeNode(index.toString()))};
    }
    toImmutable() {
      return super.toImmutable();
    }
    _toImmutable() {
      const result = this._items.map(node => node.toImmutable());
      return Object.freeze(result);
    }
    clone() {
      return new node_modules$$liveblocks$core$dist$index$classdecl$var1(this._items.map(item => item.clone()));
    }
  };
  var LiveList = node_modules$$liveblocks$core$dist$index$classdecl$var1, LiveListIterator = class {
    constructor(items) {
      this._innerIterator = items[Symbol.iterator]();
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const result = this._innerIterator.next();
      return result.done ? {done:!0, value:void 0} : {value:liveNodeToLson(result.value)};
    }
  }, freeze = Object.freeze;
  const node_modules$$liveblocks$core$dist$index$classdecl$var2 = class extends AbstractCrdt {
    constructor(entries2) {
      super();
      this.unacknowledgedSet = new Map();
      if (entries2) {
        const mappedEntries = [];
        for (const [key, value] of entries2) {
          entries2 = lsonToLiveNode(value), entries2._setParentLink(this, key), mappedEntries.push([key, entries2]);
        }
        this._map = new Map(mappedEntries);
      } else {
        this._map = new Map();
      }
    }
    _toOps(parentId, parentKey, pool) {
      if (void 0 === this._id) {
        throw Error("Cannot serialize item is not attached");
      }
      const ops = [];
      parentId = {id:this._id, opId:_optionalChain([pool, "optionalAccess", _98 => _98.generateOpId, "call", _99 => _99()]), type:7, parentId, parentKey};
      ops.push(parentId);
      for (const [key, value] of this._map) {
        ops.push(...value._toOps(this._id, key, pool));
      }
      return ops;
    }
    static _deserialize([id], parentToChildren, pool) {
      const map = new node_modules$$liveblocks$core$dist$index$classdecl$var2();
      map._attach(id, pool);
      id = parentToChildren.get(id);
      if (void 0 === id) {
        return map;
      }
      for (const [id2, crdt] of id) {
        id = deserialize([id2, crdt], parentToChildren, pool), id._setParentLink(map, crdt.parentKey), map._map.set(crdt.parentKey, id), map.invalidate();
      }
      return map;
    }
    _attach(id, pool) {
      super._attach(id, pool);
      for (const [, value] of this._map) {
        isLiveNode(value) && value._attach(pool.generateId(), pool);
      }
    }
    _attachChild(op, source) {
      if (void 0 === this._pool) {
        throw Error("Can't attach child if managed pool is not present");
      }
      const {id, parentKey, opId} = op;
      op = lsonToLiveNode(creationOpToLson(op));
      if (void 0 !== this._pool.getNode(id)) {
        return {modified:!1};
      }
      if (2 === source) {
        source = this.unacknowledgedSet.get(parentKey);
        if (source === opId) {
          return this.unacknowledgedSet.delete(parentKey), {modified:!1};
        }
        if (void 0 !== source) {
          return {modified:!1};
        }
      } else {
        1 === source && this.unacknowledgedSet.delete(parentKey);
      }
      source = this._map.get(parentKey);
      if (source) {
        var reverse = nn(this._id);
        reverse = source._toOps(reverse, parentKey);
        source._detach();
      } else {
        reverse = [{type:5, id}];
      }
      op._setParentLink(this, parentKey);
      op._attach(id, this._pool);
      this._map.set(parentKey, op);
      this.invalidate();
      return {modified:{node:this, type:"LiveMap", updates:{[parentKey]:{type:"update"}}}, reverse};
    }
    _detach() {
      super._detach();
      for (const item of this._map.values()) {
        item._detach();
      }
    }
    _detachChild(child) {
      var id = nn(this._id);
      const parentKey = nn(child._parentKey);
      id = child._toOps(id, parentKey, this._pool);
      for (const [key, value] of this._map) {
        value === child && (this._map.delete(key), this.invalidate());
      }
      child._detach();
      return {modified:{node:this, type:"LiveMap", updates:{[parentKey]:{type:"delete"}}}, reverse:id};
    }
    _serialize() {
      if ("HasParent" !== this.parent.type) {
        throw Error("Cannot serialize LiveMap if parent is missing");
      }
      return {type:2, parentId:nn(this.parent.node._id, "Parent node expected to have ID"), parentKey:this.parent.key};
    }
    get(key) {
      key = this._map.get(key);
      if (void 0 !== key) {
        return liveNodeToLson(key);
      }
    }
    set(key, value) {
      _optionalChain([this, "access", _100 => _100._pool, "optionalAccess", _101 => _101.assertStorageIsWritable, "call", _102 => _102()]);
      const oldValue = this._map.get(key);
      oldValue && oldValue._detach();
      value = lsonToLiveNode(value);
      value._setParentLink(this, key);
      this._map.set(key, value);
      this.invalidate();
      if (this._pool && this._id) {
        const id = this._pool.generateId();
        value._attach(id, this._pool);
        const storageUpdates = new Map();
        storageUpdates.set(this._id, {node:this, type:"LiveMap", updates:{[key]:{type:"update"}}});
        const ops = value._toOps(this._id, key, this._pool);
        this.unacknowledgedSet.set(key, nn(ops[0].opId));
        this._pool.dispatch(value._toOps(this._id, key, this._pool), oldValue ? oldValue._toOps(this._id, key) : [{type:5, id}], storageUpdates);
      }
    }
    get size() {
      return this._map.size;
    }
    has(key) {
      return this._map.has(key);
    }
    delete(key) {
      _optionalChain([this, "access", _103 => _103._pool, "optionalAccess", _104 => _104.assertStorageIsWritable, "call", _105 => _105()]);
      const item = this._map.get(key);
      if (void 0 === item) {
        return !1;
      }
      item._detach();
      this._map.delete(key);
      this.invalidate();
      if (this._pool && item._id) {
        const thisId = nn(this._id), storageUpdates = new Map();
        storageUpdates.set(thisId, {node:this, type:"LiveMap", updates:{[key]:{type:"delete"}}});
        this._pool.dispatch([{type:5, id:item._id, opId:this._pool.generateOpId()}], item._toOps(thisId, key), storageUpdates);
      }
      return !0;
    }
    entries() {
      const innerIterator = this._map.entries();
      return {[Symbol.iterator]() {
        return this;
      }, next() {
        var iteratorValue = innerIterator.next();
        if (iteratorValue.done) {
          return {done:!0, value:void 0};
        }
        const key = iteratorValue.value[0];
        iteratorValue = liveNodeToLson(iteratorValue.value[1]);
        return {value:[key, iteratorValue]};
      }};
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    keys() {
      return this._map.keys();
    }
    values() {
      const innerIterator = this._map.values();
      return {[Symbol.iterator]() {
        return this;
      }, next() {
        const iteratorValue = innerIterator.next();
        return iteratorValue.done ? {done:!0, value:void 0} : {value:liveNodeToLson(iteratorValue.value)};
      }};
    }
    forEach(callback) {
      for (const entry of this) {
        callback(entry[1], entry[0], this);
      }
    }
    _toTreeNode(key) {
      return {type:"LiveMap", id:_nullishCoalesce(this._id, () => nanoid()), key, payload:Array.from(this._map.entries()).map(([key2, val]) => val.toTreeNode(key2))};
    }
    toImmutable() {
      return super.toImmutable();
    }
    _toImmutable() {
      const result = new Map();
      for (const [key, value] of this._map) {
        result.set(key, value.toImmutable());
      }
      return freeze(result);
    }
    clone() {
      return new node_modules$$liveblocks$core$dist$index$classdecl$var2(Array.from(this._map).map(([key, node]) => [key, node.clone()]));
    }
  };
  var LiveMap = node_modules$$liveblocks$core$dist$index$classdecl$var2;
  const node_modules$$liveblocks$core$dist$index$classdecl$var3 = class extends AbstractCrdt {
    static _buildRootAndParentToChildren(items) {
      const parentToChildren = new Map();
      let root = null;
      for (const [id, crdt] of items) {
        if (isRootCrdt(crdt)) {
          root = [id, crdt];
        } else {
          items = [id, crdt];
          const children = parentToChildren.get(crdt.parentId);
          void 0 !== children ? children.push(items) : parentToChildren.set(crdt.parentId, [items]);
        }
      }
      if (null === root) {
        throw Error("Root can't be null");
      }
      return [root, parentToChildren];
    }
    static _fromItems(items, pool) {
      const [root, parentToChildren] = node_modules$$liveblocks$core$dist$index$classdecl$var3._buildRootAndParentToChildren(items);
      return node_modules$$liveblocks$core$dist$index$classdecl$var3._deserialize(root, parentToChildren, pool);
    }
    constructor(obj = {}) {
      super();
      this._propToLastUpdate = new Map();
      obj = compactObject(obj);
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        isLiveNode(value) && value._setParentLink(this, key);
      }
      this._map = new Map(Object.entries(obj));
    }
    _toOps(parentId, parentKey, pool) {
      if (void 0 === this._id) {
        throw Error("Cannot serialize item is not attached");
      }
      const opId = _optionalChain([pool, "optionalAccess", _106 => _106.generateOpId, "call", _107 => _107()]), ops = [];
      parentId = {type:4, id:this._id, opId, parentId, parentKey, data:{}};
      ops.push(parentId);
      for (const [key, value] of this._map) {
        isLiveNode(value) ? ops.push(...value._toOps(this._id, key, pool)) : parentId.data[key] = value;
      }
      return ops;
    }
    static _deserialize([id, item], parentToChildren, pool) {
      item = new node_modules$$liveblocks$core$dist$index$classdecl$var3(item.data);
      item._attach(id, pool);
      return this._deserializeChildren(item, parentToChildren, pool);
    }
    static _deserializeChildren(liveObj, parentToChildren, pool) {
      var children = parentToChildren.get(nn(liveObj._id));
      if (void 0 === children) {
        return liveObj;
      }
      for (const [id, crdt] of children) {
        children = deserializeToLson([id, crdt], parentToChildren, pool), isLiveStructure(children) && children._setParentLink(liveObj, crdt.parentKey), liveObj._map.set(crdt.parentKey, children), liveObj.invalidate();
      }
      return liveObj;
    }
    _attach(id, pool) {
      super._attach(id, pool);
      for (const [, value] of this._map) {
        isLiveNode(value) && value._attach(pool.generateId(), pool);
      }
    }
    _attachChild(op, source) {
      if (void 0 === this._pool) {
        throw Error("Can't attach child if managed pool is not present");
      }
      const {id, opId, parentKey:key} = op;
      op = creationOpToLson(op);
      if (void 0 !== this._pool.getNode(id)) {
        return this._propToLastUpdate.get(key) === opId && this._propToLastUpdate.delete(key), {modified:!1};
      }
      if (0 === source) {
        this._propToLastUpdate.set(key, nn(opId));
      } else if (void 0 !== this._propToLastUpdate.get(key)) {
        return this._propToLastUpdate.get(key) === opId && this._propToLastUpdate.delete(key), {modified:!1};
      }
      var thisId = nn(this._id);
      source = this._map.get(key);
      isLiveNode(source) ? (thisId = source._toOps(thisId, key), source._detach()) : thisId = void 0 === source ? [{type:6, id:thisId, key}] : [{type:3, id:thisId, data:{[key]:source}}];
      this._map.set(key, op);
      this.invalidate();
      isLiveStructure(op) && (op._setParentLink(this, key), op._attach(id, this._pool));
      return {reverse:thisId, modified:{node:this, type:"LiveObject", updates:{[key]:{type:"update"}}}};
    }
    _detachChild(child) {
      if (child) {
        var id = nn(this._id);
        const parentKey = nn(child._parentKey);
        id = child._toOps(id, parentKey, this._pool);
        for (const [key, value] of this._map) {
          value === child && (this._map.delete(key), this.invalidate());
        }
        child._detach();
        return {modified:{node:this, type:"LiveObject", updates:{[parentKey]:{type:"delete"}}}, reverse:id};
      }
      return {modified:!1};
    }
    _detach() {
      super._detach();
      for (const value of this._map.values()) {
        isLiveNode(value) && value._detach();
      }
    }
    _apply(op, isLocal) {
      return 3 === op.type ? this._applyUpdate(op, isLocal) : 6 === op.type ? this._applyDeleteObjectKey(op, isLocal) : super._apply(op, isLocal);
    }
    _serialize() {
      const data = {};
      for (const [key, value] of this._map) {
        isLiveNode(value) || (data[key] = value);
      }
      return "HasParent" === this.parent.type && this.parent.node._id ? {type:0, parentId:this.parent.node._id, parentKey:this.parent.key, data} : {type:0, data};
    }
    _applyUpdate(op, isLocal) {
      var isModified = !1, id = nn(this._id);
      const reverse = [], reverseUpdate = {type:3, id, data:{}};
      for (var key$jscomp$0 in op.data) {
        const oldValue = this._map.get(key$jscomp$0);
        isLiveNode(oldValue) ? (reverse.push(...oldValue._toOps(id, key$jscomp$0)), oldValue._detach()) : void 0 !== oldValue ? reverseUpdate.data[key$jscomp$0] = oldValue : void 0 === oldValue && reverse.push({type:6, id, key:key$jscomp$0});
      }
      id = {};
      for (const key in op.data) {
        if (key$jscomp$0 = op.data[key], void 0 !== key$jscomp$0) {
          if (isLocal) {
            this._propToLastUpdate.set(key, nn(op.opId));
          } else if (void 0 !== this._propToLastUpdate.get(key)) {
            this._propToLastUpdate.get(key) === op.opId && this._propToLastUpdate.delete(key);
            continue;
          }
          isModified = this._map.get(key);
          isLiveNode(isModified) && isModified._detach();
          isModified = !0;
          id[key] = {type:"update"};
          this._map.set(key, key$jscomp$0);
          this.invalidate();
        }
      }
      0 !== Object.keys(reverseUpdate.data).length && reverse.unshift(reverseUpdate);
      return isModified ? {modified:{node:this, type:"LiveObject", updates:id}, reverse} : {modified:!1};
    }
    _applyDeleteObjectKey(op, isLocal) {
      const key = op.key;
      if (!1 === this._map.has(key) || !isLocal && void 0 !== this._propToLastUpdate.get(key)) {
        return {modified:!1};
      }
      isLocal = this._map.get(key);
      const id = nn(this._id);
      let reverse = [];
      isLiveNode(isLocal) ? (reverse = isLocal._toOps(id, op.key), isLocal._detach()) : void 0 !== isLocal && (reverse = [{type:3, id, data:{[key]:isLocal}}]);
      this._map.delete(key);
      this.invalidate();
      return {modified:{node:this, type:"LiveObject", updates:{[op.key]:{type:"delete"}}}, reverse};
    }
    toObject() {
      return Object.fromEntries(this._map);
    }
    set(key, value) {
      _optionalChain([this, "access", _108 => _108._pool, "optionalAccess", _109 => _109.assertStorageIsWritable, "call", _110 => _110()]);
      this.update({[key]:value});
    }
    get(key) {
      return this._map.get(key);
    }
    delete(key) {
      _optionalChain([this, "access", _111 => _111._pool, "optionalAccess", _112 => _112.assertStorageIsWritable, "call", _113 => _113()]);
      var oldValue = this._map.get(key);
      if (void 0 !== oldValue) {
        if (void 0 === this._pool || void 0 === this._id) {
          isLiveNode(oldValue) && oldValue._detach(), this._map.delete(key), this.invalidate();
        } else {
          isLiveNode(oldValue) ? (oldValue._detach(), oldValue = oldValue._toOps(this._id, key)) : oldValue = [{type:3, data:{[key]:oldValue}, id:this._id}];
          this._map.delete(key);
          this.invalidate();
          var storageUpdates = new Map();
          storageUpdates.set(this._id, {node:this, type:"LiveObject", updates:{[key]:{type:"delete"}}});
          this._pool.dispatch([{type:6, key, id:this._id, opId:this._pool.generateOpId()}], oldValue, storageUpdates);
        }
      }
    }
    update(patch) {
      _optionalChain([this, "access", _114 => _114._pool, "optionalAccess", _115 => _115.assertStorageIsWritable, "call", _116 => _116()]);
      if (void 0 === this._pool || void 0 === this._id) {
        for (var key$jscomp$0 in patch) {
          var newValue$jscomp$0 = patch[key$jscomp$0];
          if (void 0 !== newValue$jscomp$0) {
            var oldValue = this._map.get(key$jscomp$0);
            isLiveNode(oldValue) && oldValue._detach();
            isLiveNode(newValue$jscomp$0) && newValue$jscomp$0._setParentLink(this, key$jscomp$0);
            this._map.set(key$jscomp$0, newValue$jscomp$0);
            this.invalidate();
          }
        }
      } else {
        key$jscomp$0 = [];
        newValue$jscomp$0 = [];
        var opId = this._pool.generateOpId(), updatedProps = {}, reverseUpdateOp = {id:this._id, type:3, data:{}};
        oldValue = {};
        for (const key in patch) {
          const newValue = patch[key];
          if (void 0 !== newValue) {
            var oldValue$jscomp$0 = this._map.get(key);
            isLiveNode(oldValue$jscomp$0) ? (newValue$jscomp$0.push(...oldValue$jscomp$0._toOps(this._id, key)), oldValue$jscomp$0._detach()) : void 0 === oldValue$jscomp$0 ? newValue$jscomp$0.push({type:6, id:this._id, key}) : reverseUpdateOp.data[key] = oldValue$jscomp$0;
            if (isLiveNode(newValue)) {
              newValue._setParentLink(this, key);
              newValue._attach(this._pool.generateId(), this._pool);
              oldValue$jscomp$0 = newValue._toOps(this._id, key, this._pool);
              const createCrdtOp = oldValue$jscomp$0.find(op => op.parentId === this._id);
              createCrdtOp && this._propToLastUpdate.set(key, nn(createCrdtOp.opId));
              key$jscomp$0.push(...oldValue$jscomp$0);
            } else {
              updatedProps[key] = newValue, this._propToLastUpdate.set(key, opId);
            }
            this._map.set(key, newValue);
            this.invalidate();
            oldValue[key] = {type:"update"};
          }
        }
        0 !== Object.keys(reverseUpdateOp.data).length && newValue$jscomp$0.unshift(reverseUpdateOp);
        0 !== Object.keys(updatedProps).length && key$jscomp$0.unshift({opId, id:this._id, type:3, data:updatedProps});
        patch = new Map();
        patch.set(this._id, {node:this, type:"LiveObject", updates:oldValue});
        this._pool.dispatch(key$jscomp$0, newValue$jscomp$0, patch);
      }
    }
    toImmutable() {
      return super.toImmutable();
    }
    toTreeNode(key) {
      return super.toTreeNode(key);
    }
    _toTreeNode(key) {
      const nodeId = _nullishCoalesce(this._id, () => nanoid());
      return {type:"LiveObject", id:nodeId, key, payload:Array.from(this._map.entries()).map(([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : {type:"Json", id:`${nodeId}:${key2}`, key:key2, payload:value})};
    }
    _toImmutable() {
      const result = {};
      for (const [key, val] of this._map) {
        result[key] = isLiveStructure(val) ? val.toImmutable() : val;
      }
      return Object.freeze(result);
    }
    clone() {
      return new node_modules$$liveblocks$core$dist$index$classdecl$var3(Object.fromEntries(Array.from(this._map).map(([key, value]) => [key, isLiveStructure(value) ? value.clone() : deepClone(value)])));
    }
  };
  var LiveObject = node_modules$$liveblocks$core$dist$index$classdecl$var3, identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/, getFiltersFromKeyValuePairs = keyValuePairs => {
    const filters = [];
    keyValuePairs.forEach(([key, value]) => {
      filters.push({key, operator:":", value});
    });
    return filters;
  }, getFiltersFromKeyValuePairsWithOperator = keyValuePairsWithOperator => {
    const filters = [];
    keyValuePairsWithOperator.forEach(([key, value]) => {
      "startsWith" in value && "string" === typeof value.startsWith && filters.push({key, operator:"^", value:value.startsWith});
    });
    return filters;
  }, isSimpleValue = value => "string" === typeof value || "number" === typeof value || "boolean" === typeof value ? !0 : !1, isValueWithOperator = value => "object" === typeof value && null !== value && "startsWith" in value ? !0 : !1, ClientMsgCode = (ClientMsgCode2 => {
    ClientMsgCode2[ClientMsgCode2.UPDATE_PRESENCE = 100] = "UPDATE_PRESENCE";
    ClientMsgCode2[ClientMsgCode2.BROADCAST_EVENT = 103] = "BROADCAST_EVENT";
    ClientMsgCode2[ClientMsgCode2.FETCH_STORAGE = 200] = "FETCH_STORAGE";
    ClientMsgCode2[ClientMsgCode2.UPDATE_STORAGE = 201] = "UPDATE_STORAGE";
    ClientMsgCode2[ClientMsgCode2.FETCH_YDOC = 300] = "FETCH_YDOC";
    ClientMsgCode2[ClientMsgCode2.UPDATE_YDOC = 301] = "UPDATE_YDOC";
    return ClientMsgCode2;
  })(ClientMsgCode || {}), ImmutableRef = class {
    constructor() {
      this._ev = makeEventSource();
    }
    get didInvalidate() {
      return this._ev.observable;
    }
    invalidate() {
      void 0 !== this._cache && (this._cache = void 0, this._ev.notify());
    }
    get current() {
      return _nullishCoalesce(this._cache, () => this._cache = this._toImmutable());
    }
  }, OthersRef = class extends ImmutableRef {
    constructor() {
      super();
      this._connections = new Map();
      this._presences = new Map();
      this._users = new Map();
    }
    connectionIds() {
      return this._connections.keys();
    }
    _toImmutable() {
      return compact(Array.from(this._presences.keys()).map(connectionId => this.getUser(Number(connectionId))));
    }
    clearOthers() {
      this._connections = new Map();
      this._presences = new Map();
      this._users = new Map();
      this.invalidate();
    }
    _getUser(connectionId$jscomp$0) {
      const conn = this._connections.get(connectionId$jscomp$0);
      connectionId$jscomp$0 = this._presences.get(connectionId$jscomp$0);
      if (void 0 !== conn && void 0 !== connectionId$jscomp$0) {
        const {connectionId, id, info} = conn, canWrite = conn.scopes.includes("room:write");
        return freeze(compactObject({connectionId, id, info, canWrite, canComment:canComment(conn.scopes), isReadOnly:!canWrite, presence:connectionId$jscomp$0}));
      }
    }
    getUser(connectionId) {
      var cachedUser = this._users.get(connectionId);
      if (cachedUser) {
        return cachedUser;
      }
      if (cachedUser = this._getUser(connectionId)) {
        return this._users.set(connectionId, cachedUser), cachedUser;
      }
    }
    _invalidateUser(connectionId) {
      this._users.has(connectionId) && this._users.delete(connectionId);
      this.invalidate();
    }
    setConnection(connectionId, metaUserId, metaUserInfo, scopes) {
      this._connections.set(connectionId, freeze({connectionId, id:metaUserId, info:metaUserInfo, scopes}));
      this._presences.has(connectionId) && this._invalidateUser(connectionId);
    }
    removeConnection(connectionId) {
      this._connections.delete(connectionId);
      this._presences.delete(connectionId);
      this._invalidateUser(connectionId);
    }
    setOther(connectionId, presence) {
      this._presences.set(connectionId, freeze(compactObject(presence)));
      this._connections.has(connectionId) && this._invalidateUser(connectionId);
    }
    patchOther(connectionId, patch) {
      const oldPresence = this._presences.get(connectionId);
      void 0 !== oldPresence && (patch = merge(oldPresence, patch), oldPresence !== patch && (this._presences.set(connectionId, freeze(patch)), this._invalidateUser(connectionId)));
    }
  }, PatchableRef = class extends ImmutableRef {
    constructor(data) {
      super();
      this._data = freeze(compactObject(data));
    }
    _toImmutable() {
      return this._data;
    }
    patch(patch) {
      const oldData = this._data;
      patch = merge(oldData, patch);
      oldData !== patch && (this._data = freeze(patch), this.invalidate());
    }
  }, ValueRef = class extends ImmutableRef {
    constructor(initialValue) {
      super();
      this._value = freeze(initialValue);
    }
    _toImmutable() {
      return this._value;
    }
    set(newValue) {
      this._value = freeze(newValue);
      this.invalidate();
    }
  }, DerivedRef = class extends ImmutableRef {
    constructor(...args) {
      super();
      const transformFn = args.pop();
      this._refs = args;
      this._refs.forEach(ref => {
        ref.didInvalidate.subscribe(() => this.invalidate());
      });
      this._transform = transformFn;
    }
    _toImmutable() {
      return this._transform(...this._refs.map(ref => ref.current));
    }
  }, RETRY_DELAYS = [2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3], commentBodyElementsGuards = {paragraph:function(element) {
    return "type" in element && "paragraph" === element.type;
  }, text:isCommentBodyText, link:isCommentBodyLink, mention:isCommentBodyMention}, commentBodyElementsTypes = {paragraph:"block", text:"inline", link:"inline", mention:"inline"}, htmlEscapables = {"\x26":"\x26amp;", "\x3c":"\x26lt;", "\x3e":"\x26gt;", '"':"\x26quot;", "'":"\x26#39;"}, htmlEscapablesRegex = new RegExp(Object.keys(htmlEscapables).map(entity => `\\${entity}`).join("|"), "g"), HtmlSafeString = class {
    constructor(strings, values) {
      this._strings = strings;
      this._values = values;
    }
    toString() {
      return this._strings.reduce((result, str, i) => result + escapeHtml(nn(this._values[i - 1])) + str);
    }
  }, markdownEscapables = {_:"\\_", "*":"\\*", "#":"\\#", "`":"\\`", "~":"\\~", "!":"\\!", "|":"\\|", "(":"\\(", ")":"\\)", "{":"\\{", "}":"\\}", "[":"\\[", "]":"\\]"}, markdownEscapablesRegex = new RegExp(Object.keys(markdownEscapables).map(entity => `\\${entity}`).join("|"), "g"), MarkdownSafeString = class {
    constructor(strings, values) {
      this._strings = strings;
      this._values = values;
    }
    toString() {
      return this._strings.reduce((result, str, i) => result + escapeMarkdown(nn(this._values[i - 1])) + str);
    }
  }, stringifyCommentBodyPlainElements = {paragraph:({children}) => children, text:({element}) => element.text, link:({element}) => _nullishCoalesce(element.text, () => element.url), mention:({element, user}) => `@${_nullishCoalesce(_optionalChain([user, "optionalAccess", _175 => _175.name]), () => element.id)}`}, stringifyCommentBodyHtmlElements = {paragraph:({children}) => children ? html`<p>${new HtmlSafeString([String(children)], [])}</p>` : children, text:({element}) => {
    let children = element.text;
    if (!children) {
      return children;
    }
    element.bold && (children = html`<strong>${children}</strong>`);
    element.italic && (children = html`<em>${children}</em>`);
    element.strikethrough && (children = html`<s>${children}</s>`);
    element.code && (children = html`<code>${children}</code>`);
    return children;
  }, link:({element, href}) => html`<a href="${href}" target="_blank" rel="noopener noreferrer">${_nullishCoalesce(element.text, () => element.url)}</a>`, mention:({element, user}) => html`<span data-mention>@${_nullishCoalesce(_optionalChain([user, "optionalAccess", _176 => _176.name]), () => element.id)}</span>`}, stringifyCommentBodyMarkdownElements = {paragraph:({children}) => children, text:({element}) => {
    let children = element.text;
    if (!children) {
      return children;
    }
    element.bold && (children = markdown`**${children}**`);
    element.italic && (children = markdown`_${children}_`);
    element.strikethrough && (children = markdown`~~${children}~~`);
    element.code && (children = markdown`\`${children}\``);
    return children;
  }, link:({element, href}) => markdown`[${_nullishCoalesce(element.text, () => element.url)}](${href})`, mention:({element, user}) => markdown`@${_nullishCoalesce(_optionalChain([user, "optionalAccess", _177 => _177.name]), () => element.id)}`}, _emittedDeprecationWarnings = new Set(), BACKOFF_DELAYS2 = [1e3, 2e3, 4e3, 8e3, 1e4];
  const node_modules$$liveblocks$core$dist$index$classdecl$var4 = class {
    constructor(alreadySortedList, lt) {
      this._lt = lt;
      this._data = alreadySortedList;
    }
    static from(arr, lt) {
      lt = new node_modules$$liveblocks$core$dist$index$classdecl$var4([], lt);
      for (const item of arr) {
        lt.add(item);
      }
      return lt;
    }
    static fromAlreadySorted(alreadySorted, lt) {
      return new node_modules$$liveblocks$core$dist$index$classdecl$var4(alreadySorted, lt);
    }
    clone() {
      return new node_modules$$liveblocks$core$dist$index$classdecl$var4(this._data.slice(), this._lt);
    }
    add(value) {
      var arr = this._data, lt = this._lt;
      let lo = 0, hi = arr.length;
      for (; lo < hi;) {
        const mid = lo + (hi - lo >> 1);
        lt(value, arr[mid]) ? hi = mid : lo = mid + 1;
      }
      this._data.splice(lo, 0, value);
    }
    remove(value) {
      value = this._data.indexOf(value);
      return 0 <= value ? (this._data.splice(value, 1), !0) : !1;
    }
    get length() {
      return this._data.length;
    }
    *filter(predicate) {
      for (const item of this._data) {
        predicate(item) && (yield item);
      }
    }
    [Symbol.iterator]() {
      return this._data[Symbol.iterator]();
    }
  };
  var SortedList = node_modules$$liveblocks$core$dist$index$classdecl$var4;
  detectDupes("@liveblocks/core", "2.10.2", "cjs");
  var CommentsApiError = HttpError, NotificationsApiError = HttpError;
  exports.ClientMsgCode = ClientMsgCode;
  exports.CommentsApiError = CommentsApiError;
  exports.CrdtType = CrdtType;
  exports.HttpError = HttpError;
  exports.LiveList = LiveList;
  exports.LiveMap = LiveMap;
  exports.LiveObject = LiveObject;
  exports.NotificationsApiError = NotificationsApiError;
  exports.OpCode = OpCode;
  exports.ServerMsgCode = ServerMsgCode;
  exports.SortedList = SortedList;
  exports.WebsocketCloseCodes = WebsocketCloseCodes;
  exports.ackOp = function(opId) {
    return {type:5, id:"ACK", opId};
  };
  exports.asPos = asPos;
  exports.assert = assert;
  exports.assertNever = assertNever;
  exports.autoRetry = autoRetry;
  exports.b64decode = b64decode;
  exports.chunk = chunk;
  exports.cloneLson = cloneLson;
  exports.compactObject = compactObject;
  exports.console = fancy_console_exports;
  exports.convertToCommentData = convertToCommentData;
  exports.convertToCommentUserReaction = convertToCommentUserReaction;
  exports.convertToInboxNotificationData = convertToInboxNotificationData;
  exports.convertToThreadData = convertToThreadData;
  exports.createClient = function(options) {
    function leaseRoom(details) {
      const leave = () => {
        if (!details.unsubs.delete(leave)) {
          warn("This leave function was already called. Calling it more than once has no effect.");
        } else {
          if (0 === details.unsubs.size) {
            var room = details.room, roomId = room.id;
            "undefined" !== typeof window && (stopSyncStream(roomId), stopRoomChannelListener(roomId), sendToPanel({msg:"room::unavailable", roomId}));
            roomsById.delete(room.id);
            room.destroy();
          }
        }
      };
      details.unsubs.add(leave);
      return {room:details.room, leave};
    }
    const throttleDelay = checkBounds("throttle", _nullishCoalesce(options.throttle, () => 100), 16, 1e3), lostConnectionTimeout = checkBounds("lostConnectionTimeout", _nullishCoalesce(options.lostConnectionTimeout, () => 5e3), 200, 3e4, 1e3), backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(options.backgroundKeepAliveTimeout), baseUrl = getBaseUrl(options.baseUrl), authManager = createAuthManager(options), roomsById = new Map(), currentUserIdStore = createStore(null);
    var fetchPolyfill = _optionalChain([options, "access", _164 => _164.polyfills, "optionalAccess", _165 => _165.fetch]) || _optionalChain([globalThis, "access", _166 => _166.fetch, "optionalAccess", _167 => _167.bind, "call", _168 => _168(globalThis)]);
    fetchPolyfill = createNotificationsApi({baseUrl, fetchPolyfill, authManager, currentUserIdStore});
    const resolveUsers = options.resolveUsers, warnIfNoResolveUsers = createDevelopmentWarning(() => !resolveUsers, "Set the resolveUsers option in createClient to specify user info.");
    var batchedResolveUsers = new Batch(async batchedUserIds => {
      const userIds = batchedUserIds.flat();
      batchedUserIds = await _optionalChain([resolveUsers, "optionalCall", _169 => _169({userIds})]);
      warnIfNoResolveUsers();
      return _nullishCoalesce(batchedUserIds, () => userIds.map(() => {
      }));
    }, {delay:50});
    const usersStore = createBatchStore(batchedResolveUsers), resolveRoomsInfo = options.resolveRoomsInfo, warnIfNoResolveRoomsInfo = createDevelopmentWarning(() => !resolveRoomsInfo, "Set the resolveRoomsInfo option in createClient to specify room info.");
    batchedResolveUsers = new Batch(async batchedRoomIds => {
      const roomIds = batchedRoomIds.flat();
      batchedRoomIds = await _optionalChain([resolveRoomsInfo, "optionalCall", _170 => _170({roomIds})]);
      warnIfNoResolveRoomsInfo();
      return _nullishCoalesce(batchedRoomIds, () => roomIds.map(() => {
      }));
    }, {delay:50});
    const roomsInfoStore = createBatchStore(batchedResolveUsers), mentionSuggestionsCache = new Map(), client = Object.defineProperty({enterRoom:function(roomId, ...args) {
      var existing = roomsById.get(roomId);
      if (void 0 !== existing) {
        return leaseRoom(existing);
      }
      args = _nullishCoalesce(args[0], () => ({}));
      existing = _nullishCoalesce("function" === typeof args.initialPresence ? args.initialPresence(roomId) : args.initialPresence, () => ({}));
      var initialStorage = _nullishCoalesce("function" === typeof args.initialStorage ? args.initialStorage(roomId) : args.initialStorage, () => ({}));
      existing = createRoom({initialPresence:existing, initialStorage}, {roomId, throttleDelay, lostConnectionTimeout, backgroundKeepAliveTimeout, polyfills:options.polyfills, delegates:_nullishCoalesce(options.mockedDelegates, () => ({createSocket:makeCreateSocketDelegateForRoom(roomId, baseUrl, _optionalChain([options, "access", _156 => _156.polyfills, "optionalAccess", _157 => _157.WebSocket])), authenticate:makeAuthDelegateForRoom(roomId, authManager)})), enableDebugLogging:options.enableDebugLogging, 
      unstable_batchedUpdates:_optionalChain([args, "optionalAccess", _158 => _158.unstable_batchedUpdates]), baseUrl, unstable_fallbackToHTTP:!!options.unstable_fallbackToHTTP, unstable_streamData:!!options.unstable_streamData});
      initialStorage = {room:existing, unsubs:new Set()};
      roomsById.set(roomId, initialStorage);
      setupDevTools(() => Array.from(roomsById.keys()));
      linkDevTools(roomId, existing);
      if (_nullishCoalesce(args.autoConnect, () => !0)) {
        if ("undefined" === typeof atob) {
          if (void 0 === _optionalChain([options, "access", _159 => _159.polyfills, "optionalAccess", _160 => _160.atob])) {
            throw Error("You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill");
          }
          global.atob = options.polyfills.atob;
        }
        existing.connect();
      }
      return leaseRoom(initialStorage);
    }, getRoom:function(roomId) {
      const room = _optionalChain([roomsById, "access", _161 => _161.get, "call", _162 => _162(roomId), "optionalAccess", _163 => _163.room]);
      return room ? room : null;
    }, logout:function() {
      authManager.reset();
      for (const {room} of roomsById.values()) {
        var status = room.getStatus();
        "initial" === status || "disconnected" === status || room.reconnect();
      }
    }, ...fetchPolyfill, resolvers:{invalidateUsers:function(userIds) {
      usersStore.invalidate(userIds);
    }, invalidateRoomsInfo:function(roomIds) {
      roomsInfoStore.invalidate(roomIds);
    }, invalidateMentionSuggestions:function() {
      mentionSuggestionsCache.clear();
    }}, [kInternal]:{currentUserIdStore, mentionSuggestionsCache, resolveMentionSuggestions:options.resolveMentionSuggestions, usersStore, roomsInfoStore, getRoomIds() {
      return Array.from(roomsById.keys());
    }, getUserThreads_experimental:fetchPolyfill.getUserThreads_experimental, getUserThreadsSince_experimental:fetchPolyfill.getUserThreadsSince_experimental, as:() => client}}, kInternal, {enumerable:!1});
    return client;
  };
  exports.createCommentId = createCommentId;
  exports.createInboxNotificationId = function() {
    return `${"in"}_${nanoid()}`;
  };
  exports.createStore = createStore;
  exports.createThreadId = createThreadId;
  exports.deprecate = deprecate;
  exports.deprecateIf = function(condition, message, key = message) {
    condition && deprecate(message, key);
  };
  exports.detectDupes = detectDupes;
  exports.errorIf = function(condition, message) {
    condition && throwUsageError(message);
  };
  exports.freeze = freeze;
  exports.getMentionedIdsFromCommentBody = getMentionedIdsFromCommentBody;
  exports.isChildCrdt = isChildCrdt;
  exports.isJsonArray = isJsonArray;
  exports.isJsonObject = isJsonObject;
  exports.isJsonScalar = isJsonScalar;
  exports.isLiveNode = isLiveNode;
  exports.isPlainObject = isPlainObject;
  exports.isRootCrdt = isRootCrdt;
  exports.kInternal = kInternal;
  exports.legacy_patchImmutableObject = function(state, updates) {
    return updates.reduce((state2, update) => {
      var node = update.node;
      const path = [];
      for (; "HasParent" === node.parent.type;) {
        node.parent.node instanceof LiveList ? path.push(node.parent.node._indexOfPosition(node.parent.key)) : path.push(node.parent.key), node = node.parent.node;
      }
      return legacy_patchImmutableNode(state2, path, update);
    }, state);
  };
  exports.lsonToJson = lsonToJson;
  exports.makeEventSource = makeEventSource;
  exports.makePoller = function(callback, intervalMs, options) {
    function startOrStop() {
      0 < context.count && context.inForeground ? fsm.send({type:"START"}) : fsm.send({type:"STOP"});
    }
    function pollNowIfStale() {
      performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs && fsm.send({type:"POLL"});
    }
    function setInForeground(inForeground) {
      context.inForeground = inForeground;
      startOrStop();
      pollNowIfStale();
    }
    function onVisibilityChange() {
      setInForeground("hidden" !== _optionalChain([doc, "optionalAccess", _196 => _196.visibilityState]));
    }
    const startTime = performance.now(), doc = "undefined" !== typeof document ? document : void 0, win = "undefined" !== typeof window ? window : void 0, maxStaleTimeMs = _nullishCoalesce(_optionalChain([options, "optionalAccess", _194 => _194.maxStaleTimeMs]), () => Number.POSITIVE_INFINITY), context = {inForeground:"hidden" !== _optionalChain([doc, "optionalAccess", _195 => _195.visibilityState]), lastSuccessfulPollAt:startTime, count:0, backoff:0}, fsm = (new FSM({})).addState("@idle").addState("@enabled").addState("@polling");
    fsm.addTransitions("@idle", {START:"@enabled"});
    fsm.addTransitions("@enabled", {STOP:"@idle", POLL:"@polling"});
    fsm.addTimedTransition("@enabled", () => Math.max(0, context.lastSuccessfulPollAt + intervalMs - performance.now()) + context.backoff, "@polling");
    fsm.onEnterAsync("@polling", async(_ctx, signal) => {
      await callback(signal);
      signal.aborted || (context.lastSuccessfulPollAt = performance.now());
    }, () => ({target:0 < context.count && context.inForeground ? "@enabled" : "@idle", effect:() => {
      context.backoff = 0;
    }}), () => ({target:0 < context.count && context.inForeground ? "@enabled" : "@idle", effect:() => {
      context.backoff = _nullishCoalesce(BACKOFF_DELAYS2.find(delay => delay > context.backoff), () => BACKOFF_DELAYS2[BACKOFF_DELAYS2.length - 1]);
    }}), 3e4);
    _optionalChain([doc, "optionalAccess", _197 => _197.addEventListener, "call", _198 => _198("visibilitychange", onVisibilityChange)]);
    _optionalChain([win, "optionalAccess", _199 => _199.addEventListener, "call", _200 => _200("online", onVisibilityChange)]);
    fsm.start();
    return {inc:function() {
      context.count++;
      startOrStop();
    }, dec:function() {
      context.count--;
      0 > context.count && (context.count = 0);
      startOrStop();
    }, pollNowIfStale, setInForeground};
  };
  exports.makePosition = makePosition;
  exports.mapValues = function(obj, mapFn) {
    const result = {};
    for (const pair of Object.entries(obj)) {
      obj = pair[0], "__proto__" !== obj && (result[obj] = mapFn(pair[1], obj));
    }
    return result;
  };
  exports.memoizeOnSuccess = memoizeOnSuccess;
  exports.nanoid = nanoid;
  exports.nn = nn;
  exports.objectToQuery = objectToQuery;
  exports.patchLiveObjectKey = patchLiveObjectKey;
  exports.raise = raise;
  exports.shallow = function(a, b) {
    if (Object.is(a, b)) {
      return !0;
    }
    var isArrayA = Array.isArray(a);
    const isArrayB = Array.isArray(b);
    if (isArrayA || isArrayB) {
      if (!isArrayA || !isArrayB) {
        return !1;
      }
      a: {
        if (a.length !== b.length) {
          a = !1;
        } else {
          for (isArrayA = 0; isArrayA < a.length; isArrayA++) {
            if (!Object.is(a[isArrayA], b[isArrayA])) {
              a = !1;
              break a;
            }
          }
          a = !0;
        }
      }
      return a;
    }
    return shallowObj(a, b);
  };
  exports.stringify = stringify;
  exports.stringifyCommentBody = async function(body, options) {
    const format = _nullishCoalesce(_optionalChain([options, "optionalAccess", _178 => _178.format]), () => "plain"), separator = _nullishCoalesce(_optionalChain([options, "optionalAccess", _179 => _179.separator]), () => "markdown" === format ? "\n\n" : "\n"), elements = {...("html" === format ? stringifyCommentBodyHtmlElements : "markdown" === format ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements), ..._optionalChain([options, "optionalAccess", _180 => _180.elements])}, 
    resolvedUsers = await resolveUsersInCommentBody(body, _optionalChain([options, "optionalAccess", _181 => _181.resolveUsers]));
    return body.content.flatMap((block, blockIndex) => {
      switch(block.type) {
        case "paragraph":
          const inlines = block.children.flatMap((inline, inlineIndex) => isCommentBodyMention(inline) ? inline.id ? [elements.mention({element:inline, user:resolvedUsers.get(inline.id)}, inlineIndex)] : [] : isCommentBodyLink(inline) ? [elements.link({element:inline, href:_nullishCoalesce(toAbsoluteUrl(inline.url), () => inline.url)}, inlineIndex)] : isCommentBodyText(inline) ? [elements.text({element:inline}, inlineIndex)] : []);
          return [elements.paragraph({element:block, children:inlines.join("")}, blockIndex)];
        default:
          return [];
      }
    }).join(separator);
  };
  exports.throwUsageError = throwUsageError;
  exports.toPlainLson = toPlainLson;
  exports.tryParseJson = tryParseJson;
  exports.url = url;
  exports.urljoin = urljoin;
  exports.wait = wait;
  exports.withTimeout = withTimeout;
};

//# sourceMappingURL=module$node_modules$$liveblocks$core$dist$index.js.map
