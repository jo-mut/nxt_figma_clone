["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@liveblocks/core/dist/index.js"],"~:js","shadow$provide.module$node_modules$$liveblocks$core$dist$index = function(global, require, module, exports) {\n  function _nullishCoalesce(lhs, rhsFn) {\n    return null != lhs ? lhs : rhsFn();\n  }\n  function _optionalChain(ops) {\n    let lastAccessLHS = void 0, value = ops[0], i = 1;\n    for (; i < ops.length;) {\n      const op = ops[i], fn = ops[i + 1];\n      i += 2;\n      if ((\"optionalAccess\" === op || \"optionalCall\" === op) && null == value) {\n        return;\n      }\n      if (\"access\" === op || \"optionalAccess\" === op) {\n        lastAccessLHS = value, value = fn(value);\n      } else if (\"call\" === op || \"optionalCall\" === op) {\n        value = fn((...args) => value.call(lastAccessLHS, ...args)), lastAccessLHS = void 0;\n      }\n    }\n    return value;\n  }\n  function detectDupes(pkgName, pkgVersion, pkgFormat) {\n    const pkgId = Symbol.for(pkgName);\n    pkgFormat = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n    if (!g[pkgId]) {\n      g[pkgId] = pkgFormat;\n    } else if (g[pkgId] !== pkgFormat) {\n      throw pkgName = [\"Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See https://liveblocks.io/docs/errors/dupes \\n\\nConflicts:\", `- ${pkgName} ${g[pkgId]} (already loaded)`, `- ${pkgName} ${pkgFormat} (trying to load this now)`].join(\"\\n\"), Error(pkgName);\n    }\n    if (pkgVersion && \"2.10.2\" !== pkgVersion) {\n      throw pkgName = [\"Cross-linked versions of Liveblocks found, which will cause issues! See https://liveblocks.io/docs/errors/cross-linked \\n\\nConflicts:\\n- @liveblocks/core is at 2.10.2\", `- ${pkgName} is at ${pkgVersion}`, \"\\nAlways upgrade all Liveblocks packages to the same version number.\"].join(\"\\n\"), Error(pkgName);\n    }\n  }\n  function assertNever(_value, errmsg) {\n    throw Error(errmsg);\n  }\n  function assert(condition, errmsg) {\n    if (!condition) {\n      throw condition = Error(errmsg), condition.name = \"Assertion failure\", condition;\n    }\n  }\n  function nn(value, errmsg = \"Expected value to be non-nullable\") {\n    assert(null !== value && void 0 !== value, errmsg);\n    return value;\n  }\n  function controlledPromise() {\n    let resolve, reject;\n    return [new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    }), resolve, reject];\n  }\n  function Promise_withResolvers() {\n    const [promise, resolve, reject] = controlledPromise();\n    return {promise, resolve, reject};\n  }\n  function makeEventSource() {\n    function subscribe(callback) {\n      _observers.add(callback);\n      return () => _observers.delete(callback);\n    }\n    function subscribeOnce(callback) {\n      _onetimeObservers.add(callback);\n      return () => _onetimeObservers.delete(callback);\n    }\n    async function waitUntil(predicate) {\n      let unsub;\n      return (new Promise(res => {\n        unsub = subscribe(event => {\n          (void 0 === predicate || predicate(event)) && res(event);\n        });\n      })).finally(() => _optionalChain([unsub, \"optionalCall\", _2 => _2()]));\n    }\n    function notify(event) {\n      _onetimeObservers.forEach(callback => callback(event));\n      _onetimeObservers.clear();\n      _observers.forEach(callback => callback(event));\n    }\n    const _onetimeObservers = new Set(), _observers = new Set();\n    let _buffer = null;\n    return {notify:function(event) {\n      null !== _buffer ? _buffer.push(event) : notify(event);\n    }, subscribe, subscribeOnce, _forceClear:function() {\n      _onetimeObservers.clear();\n      _observers.clear();\n    }, count:function() {\n      return _onetimeObservers.size + _observers.size;\n    }, waitUntil, pause:function() {\n      _buffer = [];\n    }, unpause:function() {\n      if (null !== _buffer) {\n        for (const event of _buffer) {\n          notify(event);\n        }\n        _buffer = null;\n      }\n    }, observable:{subscribe, subscribeOnce, waitUntil}};\n  }\n  function wrap(method) {\n    return \"undefined\" === typeof window ? console[method] : (message, ...args) => console[method](\"%cLiveblocks\", \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\", message, ...args);\n  }\n  function wrapWithTitle(method) {\n    return \"undefined\" === typeof window ? console[method] : (title, message, ...args) => console[method](`%cLiveblocks%c ${title}`, \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\", \"font-weight:600\", message, ...args);\n  }\n  function distance(state1, state2) {\n    if (state1 === state2) {\n      return [0, 0];\n    }\n    state1 = state1.split(\".\");\n    state2 = state2.split(\".\");\n    const minLen = Math.min(state1.length, state2.length);\n    let shared = 0;\n    for (; shared < minLen && state1[shared] === state2[shared]; shared++) {\n    }\n    return [state1.length - shared, state2.length - shared];\n  }\n  function patterns(targetState, levels) {\n    const parts = targetState.split(\".\");\n    if (1 > levels || levels > parts.length + 1) {\n      throw Error(\"Invalid number of levels\");\n    }\n    const result = [];\n    levels > parts.length && result.push(\"*\");\n    for (levels = parts.length - levels + 1; levels < parts.length; levels++) {\n      const slice = parts.slice(0, levels);\n      0 < slice.length && result.push(slice.join(\".\") + \".*\");\n    }\n    result.push(targetState);\n    return result;\n  }\n  function raise(msg) {\n    throw Error(msg);\n  }\n  function isPlainObject(blob) {\n    return null !== blob && \"object\" === typeof blob && \"[object Object]\" === Object.prototype.toString.call(blob);\n  }\n  function tryParseJson(rawMessage) {\n    try {\n      return JSON.parse(rawMessage);\n    } catch (e) {\n    }\n  }\n  function deepClone(value) {\n    return JSON.parse(JSON.stringify(value));\n  }\n  function b64decode(b64value) {\n    try {\n      const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n      return decodeURIComponent(atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\"));\n    } catch (err) {\n      return atob(b64value);\n    }\n  }\n  function compact(items) {\n    return items.filter(item => null !== item && void 0 !== item);\n  }\n  function compactObject(obj) {\n    const newObj = {...obj};\n    Object.keys(obj).forEach(k => {\n      void 0 === newObj[k] && delete newObj[k];\n    });\n    return newObj;\n  }\n  function wait(millis) {\n    return new Promise(res => setTimeout(res, millis));\n  }\n  async function withTimeout(promise, millis, errmsg) {\n    let timerID;\n    const timer$ = new Promise((_, reject) => {\n      timerID = setTimeout(() => {\n        reject(Error(errmsg));\n      }, millis);\n    });\n    return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n  }\n  function memoizeOnSuccess(factoryFn) {\n    let cached = null;\n    return () => {\n      null === cached && (cached = factoryFn().catch(err => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      }));\n      return cached;\n    };\n  }\n  function shouldDisconnect(code) {\n    return 4999 === code || 4e3 <= code && 4100 > code;\n  }\n  function shouldRetryWithoutReauth(code) {\n    return 1013 === code || 4200 <= code && 4300 > code;\n  }\n  function toNewConnectionStatus(machine) {\n    const state = machine.currentState;\n    switch(state) {\n      case \"@ok.connected\":\n      case \"@ok.awaiting-pong\":\n        return \"connected\";\n      case \"@idle.initial\":\n        return \"initial\";\n      case \"@auth.busy\":\n      case \"@auth.backoff\":\n      case \"@connecting.busy\":\n      case \"@connecting.backoff\":\n      case \"@idle.zombie\":\n        return 0 < machine.context.successCount ? \"reconnecting\" : \"connecting\";\n      case \"@idle.failed\":\n        return \"disconnected\";\n      default:\n        return assertNever(state, \"Unknown state\");\n    }\n  }\n  function nextBackoffDelay(currentDelay, delays) {\n    return _nullishCoalesce(delays.find(delay => delay > currentDelay), () => delays[delays.length - 1]);\n  }\n  function increaseBackoffDelay(context) {\n    context.patch({backoffDelay:nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)});\n  }\n  function increaseBackoffDelayAggressively(context) {\n    context.patch({backoffDelay:nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)});\n  }\n  function resetSuccessCount(context) {\n    context.patch({successCount:0});\n  }\n  function log(level, message) {\n    const logger = 2 === level ? error2 : 1 === level ? warn : () => {\n    };\n    return () => {\n      logger(message);\n    };\n  }\n  function logPrematureErrorOrCloseEvent(e) {\n    return ctx => {\n      e instanceof Error ? warn(`${\"Connection to Liveblocks websocket server\"} could not be established. ${String(e)}`) : warn(e instanceof Error || \"close\" !== e.type ? \"Connection to Liveblocks websocket server could not be established.\" : `${\"Connection to Liveblocks websocket server\"} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.`);\n    };\n  }\n  function logCloseEvent(event) {\n    const details = [`code: ${event.code}`];\n    event.reason && details.push(`reason: ${event.reason}`);\n    return ctx => {\n      warn(`Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`);\n    };\n  }\n  function enableTracing(machine) {\n    function log2(...args) {\n      warn(`${(((new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`, ...args);\n    }\n    const start = (new Date()).getTime(), unsubs = [machine.events.didReceiveEvent.subscribe(e => log2(`Event ${e.type}`)), machine.events.willTransition.subscribe(({from, to}) => log2(\"Transitioning\", from, \"→\", to)), machine.events.didIgnoreEvent.subscribe(e => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\"))];\n    return () => {\n      for (const unsub of unsubs) {\n        unsub();\n      }\n    };\n  }\n  function defineConnectivityEvents(machine) {\n    const statusDidChange = makeEventSource(), didConnect = makeEventSource(), didDisconnect = makeEventSource();\n    let lastStatus = null;\n    const unsubscribe = machine.events.didEnterState.subscribe(() => {\n      const currStatus = toNewConnectionStatus(machine);\n      currStatus !== lastStatus && statusDidChange.notify(currStatus);\n      \"connected\" === lastStatus && \"connected\" !== currStatus ? didDisconnect.notify() : \"connected\" !== lastStatus && \"connected\" === currStatus && didConnect.notify();\n      lastStatus = currStatus;\n    });\n    return {statusDidChange:statusDidChange.observable, didConnect:didConnect.observable, didDisconnect:didDisconnect.observable, unsubscribe};\n  }\n  function createConnectionStateMachine(delegates, options) {\n    function fireErrorEvent(errmsg, errcode) {\n      return () => {\n        const err = new LiveblocksError(errmsg, errcode);\n        onLiveblocksError.notify(err);\n      };\n    }\n    function teardownSocket(socket) {\n      socket && (socket.removeEventListener(\"error\", onSocketError), socket.removeEventListener(\"close\", onSocketClose), socket.removeEventListener(\"message\", onSocketMessage), socket.close());\n    }\n    const onMessage = makeEventSource();\n    onMessage.pause();\n    const onLiveblocksError = makeEventSource(), machine = (new FSM({successCount:0, authValue:null, socket:null, backoffDelay:RESET_DELAY})).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n    machine.addTransitions(\"*\", {RECONNECT:{target:\"@auth.backoff\", effect:[increaseBackoffDelay, resetSuccessCount]}, DISCONNECT:\"@idle.initial\"});\n    machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {CONNECT:(_, ctx) => null !== ctx.authValue ? \"@connecting.busy\" : \"@auth.busy\"});\n    machine.addTransitions(\"@auth.backoff\", {NAVIGATOR_ONLINE:{target:\"@auth.busy\", effect:assign({backoffDelay:RESET_DELAY})}}).addTimedTransition(\"@auth.backoff\", ctx => ctx.backoffDelay, \"@auth.busy\").onEnterAsync(\"@auth.busy\", () => withTimeout(delegates.authenticate(), 1e4, \"Timed out during auth\"), okEvent => ({target:\"@connecting.busy\", effect:assign({authValue:okEvent.data})}), failedEvent => failedEvent.reason instanceof StopRetrying ? {target:\"@idle.failed\", effect:[log(2, failedEvent.reason.message), \n    fireErrorEvent(failedEvent.reason.message, -1)]} : {target:\"@auth.backoff\", effect:[increaseBackoffDelay, log(2, `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`)]});\n    const onSocketError = event => machine.send({type:\"EXPLICIT_SOCKET_ERROR\", event}), onSocketClose = event => machine.send({type:\"EXPLICIT_SOCKET_CLOSE\", event}), onSocketMessage = event => \"pong\" === event.data ? machine.send({type:\"PONG\"}) : onMessage.notify(event);\n    machine.addTransitions(\"@connecting.backoff\", {NAVIGATOR_ONLINE:{target:\"@connecting.busy\", effect:assign({backoffDelay:RESET_DELAY})}}).addTimedTransition(\"@connecting.backoff\", ctx => ctx.backoffDelay, \"@connecting.busy\").onEnterAsync(\"@connecting.busy\", async(ctx, signal) => {\n      let capturedPrematureEvent = null, unconfirmedSocket = null;\n      const connect$ = new Promise((resolve, rej) => {\n        function reject(event) {\n          capturedPrematureEvent = event;\n          socket.removeEventListener(\"message\", onSocketMessage);\n          rej(event);\n        }\n        function waitForActorId(event) {\n          event = tryParseJson(event.data);\n          104 === _optionalChain([event, \"optionalAccess\", _13 => _13.type]) && didReceiveActor();\n        }\n        if (null === ctx.authValue) {\n          throw Error(\"No auth authValue\");\n        }\n        const socket = delegates.createSocket(ctx.authValue);\n        unconfirmedSocket = socket;\n        const [actor$, didReceiveActor] = controlledPromise();\n        options.waitForActorId || didReceiveActor();\n        socket.addEventListener(\"message\", onSocketMessage);\n        options.waitForActorId && socket.addEventListener(\"message\", waitForActorId);\n        socket.addEventListener(\"error\", reject);\n        socket.addEventListener(\"close\", reject);\n        socket.addEventListener(\"open\", () => {\n          socket.addEventListener(\"error\", onSocketError);\n          socket.addEventListener(\"close\", onSocketClose);\n          const unsub = () => {\n            socket.removeEventListener(\"error\", reject);\n            socket.removeEventListener(\"close\", reject);\n            socket.removeEventListener(\"message\", waitForActorId);\n          };\n          actor$.then(() => {\n            resolve([socket, unsub]);\n          });\n        });\n      });\n      return withTimeout(connect$, 1e4, \"Timed out during websocket connection\").then(([socket, unsub]) => {\n        unsub();\n        if (signal.aborted) {\n          throw Error(\"Aborted\");\n        }\n        if (capturedPrematureEvent) {\n          throw capturedPrematureEvent;\n        }\n        return socket;\n      }).catch(e => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    }, okEvent => ({target:\"@ok.connected\", effect:assign({socket:okEvent.data, backoffDelay:RESET_DELAY})}), failure => {\n      failure = failure.reason;\n      if (failure instanceof StopRetrying) {\n        return {target:\"@idle.failed\", effect:[log(2, failure.message), fireErrorEvent(failure.message, -1)]};\n      }\n      if (!(failure instanceof Error) && \"close\" === failure.type) {\n        if (4109 === failure.code) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(failure.code)) {\n          return {target:\"@connecting.backoff\", effect:[increaseBackoffDelayAggressively, logPrematureErrorOrCloseEvent(failure)]};\n        }\n        if (shouldDisconnect(failure.code)) {\n          return {target:\"@idle.failed\", effect:[log(2, failure.reason), fireErrorEvent(failure.reason, failure.code)]};\n        }\n      }\n      return {target:\"@auth.backoff\", effect:[increaseBackoffDelay, logPrematureErrorOrCloseEvent(failure)]};\n    });\n    const sendHeartbeat = {target:\"@ok.awaiting-pong\", effect:ctx => {\n      _optionalChain([ctx, \"access\", _14 => _14.socket, \"optionalAccess\", _15 => _15.send, \"call\", _16 => _16(\"ping\")]);\n    }};\n    var maybeHeartbeat = () => \"hidden\" === _optionalChain([\"undefined\" !== typeof document ? document : void 0, \"optionalAccess\", _17 => _17.visibilityState]) && delegates.canZombie() ? \"@idle.zombie\" : sendHeartbeat;\n    machine.addTimedTransition(\"@ok.connected\", 3e4, maybeHeartbeat).addTransitions(\"@ok.connected\", {NAVIGATOR_OFFLINE:maybeHeartbeat, WINDOW_GOT_FOCUS:sendHeartbeat});\n    machine.addTransitions(\"@idle.zombie\", {WINDOW_GOT_FOCUS:\"@connecting.backoff\"});\n    machine.onEnter(\"@ok.*\", ctx => {\n      ctx.patch({successCount:ctx.successCount + 1});\n      const timerID = setTimeout(onMessage.unpause, 0);\n      return ctx2 => {\n        teardownSocket(ctx2.socket);\n        ctx2.patch({socket:null});\n        clearTimeout(timerID);\n        onMessage.pause();\n      };\n    }).addTransitions(\"@ok.awaiting-pong\", {PONG:\"@ok.connected\"}).addTimedTransition(\"@ok.awaiting-pong\", 2e3, {target:\"@connecting.busy\", effect:log(1, \"Received no pong from server, assume implicit connection loss.\")}).addTransitions(\"@ok.*\", {EXPLICIT_SOCKET_ERROR:(_, context) => 1 === _optionalChain([context, \"access\", _18 => _18.socket, \"optionalAccess\", _19 => _19.readyState]) ? null : {target:\"@connecting.backoff\", effect:increaseBackoffDelay}, EXPLICIT_SOCKET_CLOSE:e => {\n      if (shouldDisconnect(e.event.code)) {\n        return {target:\"@idle.failed\", effect:[logPermanentClose, fireErrorEvent(e.event.reason, e.event.code)]};\n      }\n      var code = e.event.code;\n      return 4100 <= code && 4200 > code ? 4109 === e.event.code ? \"@auth.busy\" : {target:\"@auth.backoff\", effect:[increaseBackoffDelay, logCloseEvent(e.event)]} : shouldRetryWithoutReauth(e.event.code) ? {target:\"@connecting.backoff\", effect:[increaseBackoffDelayAggressively, logCloseEvent(e.event)]} : {target:\"@connecting.backoff\", effect:[increaseBackoffDelay, logCloseEvent(e.event)]};\n    }});\n    if (\"undefined\" !== typeof document) {\n      const doc = \"undefined\" !== typeof document ? document : void 0, win = \"undefined\" !== typeof window ? window : void 0, root = _nullishCoalesce(win, () => doc);\n      machine.onEnter(\"*\", ctx => {\n        function onNetworkOffline() {\n          machine.send({type:\"NAVIGATOR_OFFLINE\"});\n        }\n        function onNetworkBackOnline() {\n          machine.send({type:\"NAVIGATOR_ONLINE\"});\n        }\n        function onVisibilityChange() {\n          \"visible\" === _optionalChain([doc, \"optionalAccess\", _20 => _20.visibilityState]) && machine.send({type:\"WINDOW_GOT_FOCUS\"});\n        }\n        _optionalChain([win, \"optionalAccess\", _21 => _21.addEventListener, \"call\", _22 => _22(\"online\", onNetworkBackOnline)]);\n        _optionalChain([win, \"optionalAccess\", _23 => _23.addEventListener, \"call\", _24 => _24(\"offline\", onNetworkOffline)]);\n        _optionalChain([root, \"optionalAccess\", _25 => _25.addEventListener, \"call\", _26 => _26(\"visibilitychange\", onVisibilityChange)]);\n        return () => {\n          _optionalChain([root, \"optionalAccess\", _27 => _27.removeEventListener, \"call\", _28 => _28(\"visibilitychange\", onVisibilityChange)]);\n          _optionalChain([win, \"optionalAccess\", _29 => _29.removeEventListener, \"call\", _30 => _30(\"online\", onNetworkBackOnline)]);\n          _optionalChain([win, \"optionalAccess\", _31 => _31.removeEventListener, \"call\", _32 => _32(\"offline\", onNetworkOffline)]);\n          teardownSocket(ctx.socket);\n        };\n      });\n    }\n    maybeHeartbeat = [];\n    const {statusDidChange, didConnect, didDisconnect, unsubscribe} = defineConnectivityEvents(machine);\n    maybeHeartbeat.push(unsubscribe);\n    options.enableDebugLogging && maybeHeartbeat.push(enableTracing(machine));\n    machine.start();\n    return {machine, cleanups:maybeHeartbeat, events:{statusDidChange, didConnect, didDisconnect, onMessage:onMessage.observable, onLiveblocksError:onLiveblocksError.observable}};\n  }\n  function canComment(scopes) {\n    return scopes.includes(\"comments:write\") || scopes.includes(\"room:write\");\n  }\n  function parseAuthToken(rawTokenString) {\n    var tokenParts = rawTokenString.split(\".\");\n    if (3 !== tokenParts.length) {\n      throw Error(\"Authentication error: invalid JWT token\");\n    }\n    tokenParts = tryParseJson(b64decode(tokenParts[1]));\n    if (!tokenParts || !isPlainObject(tokenParts) || \"acc\" !== tokenParts.k && \"id\" !== tokenParts.k && \"sec-legacy\" !== tokenParts.k) {\n      throw Error(\"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\");\n    }\n    return {raw:rawTokenString, parsed:tokenParts};\n  }\n  function createAuthManager(authOptions) {\n    function hasCorrespondingScopes(requestedScope, scopes) {\n      return \"comments:read\" === requestedScope ? scopes.includes(\"comments:read\") || scopes.includes(\"comments:write\") || scopes.includes(\"room:read\") || scopes.includes(\"room:write\") : \"room:read\" === requestedScope ? scopes.includes(\"room:read\") || scopes.includes(\"room:write\") : !1;\n    }\n    function getCachedToken(requestOptions) {\n      const now = Math.ceil(Date.now() / 1e3);\n      for (let i = tokens.length - 1; 0 <= i; i--) {\n        const token = tokens[i];\n        if (expiryTimes[i] <= now) {\n          tokens.splice(i, 1), expiryTimes.splice(i, 1);\n        } else {\n          if (\"id\" === token.parsed.k) {\n            return token;\n          }\n          if (\"acc\" === token.parsed.k) {\n            if (!requestOptions.roomId && 0 === Object.entries(token.parsed.perms).length) {\n              return token;\n            }\n            for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n              if (!requestOptions.roomId) {\n                if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n                  return token;\n                }\n              } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n                return token;\n              }\n            }\n          }\n        }\n      }\n    }\n    async function makeAuthRequest(options) {\n      var fetcher = _nullishCoalesce(_optionalChain([authOptions, \"access\", _36 => _36.polyfills, \"optionalAccess\", _37 => _37.fetch]), () => \"undefined\" === typeof window ? void 0 : window.fetch);\n      if (\"private\" === authentication.type) {\n        if (void 0 === fetcher) {\n          throw new StopRetrying(\"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\");\n        }\n        options = await fetchAuthEndpoint(fetcher, authentication.url, {room:options.roomId});\n        options = parseAuthToken(options.token);\n        if (seenTokens.has(options.raw)) {\n          throw new StopRetrying(\"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\");\n        }\n        return options;\n      }\n      if (\"custom\" === authentication.type) {\n        if ((options = await authentication.callback(options.roomId)) && \"object\" === typeof options) {\n          if (\"string\" === typeof options.token) {\n            return parseAuthToken(options.token);\n          }\n          if (\"string\" === typeof options.error) {\n            fetcher = `Authentication failed: ${\"reason\" in options && \"string\" === typeof options.reason ? options.reason : \"Forbidden\"}`;\n            if (\"forbidden\" === options.error) {\n              throw new StopRetrying(fetcher);\n            }\n            throw Error(fetcher);\n          }\n        }\n        throw Error('Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }');\n      }\n      throw Error(\"Unexpected authentication type. Must be private or custom.\");\n    }\n    const authentication = prepareAuthentication(authOptions), seenTokens = new Set(), tokens = [], expiryTimes = [], requestPromises = new Map();\n    return {reset:function() {\n      seenTokens.clear();\n      tokens.length = 0;\n      expiryTimes.length = 0;\n      requestPromises.clear();\n    }, getAuthValue:async function(requestOptions) {\n      if (\"public\" === authentication.type) {\n        return {type:\"public\", publicApiKey:authentication.publicApiKey};\n      }\n      var cachedToken = getCachedToken(requestOptions);\n      if (void 0 !== cachedToken) {\n        return {type:\"secret\", token:cachedToken};\n      }\n      requestOptions.roomId ? (cachedToken = requestPromises.get(requestOptions.roomId), void 0 === cachedToken && (cachedToken = makeAuthRequest(requestOptions), requestPromises.set(requestOptions.roomId, cachedToken))) : (cachedToken = requestPromises.get(\"liveblocks-user-token\"), void 0 === cachedToken && (cachedToken = makeAuthRequest(requestOptions), requestPromises.set(\"liveblocks-user-token\", cachedToken)));\n      try {\n        const token = await cachedToken, expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - 30;\n        seenTokens.add(token.raw);\n        \"sec-legacy\" !== token.parsed.k && (tokens.push(token), expiryTimes.push(expiresAt));\n        return {type:\"secret\", token};\n      } finally {\n        requestOptions.roomId ? requestPromises.delete(requestOptions.roomId) : requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }};\n  }\n  function prepareAuthentication(authOptions) {\n    const {publicApiKey, authEndpoint} = authOptions;\n    if (void 0 !== authEndpoint && void 0 !== publicApiKey) {\n      throw Error(\"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\");\n    }\n    if (\"string\" === typeof publicApiKey) {\n      if (publicApiKey.startsWith(\"sk_\")) {\n        throw Error(\"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\");\n      }\n      if (!publicApiKey.startsWith(\"pk_\")) {\n        throw Error(\"Invalid key. Please use the public key format: pk_\\x3cpublic key\\x3e. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\");\n      }\n      return {type:\"public\", publicApiKey};\n    }\n    if (\"string\" === typeof authEndpoint) {\n      return {type:\"private\", url:authEndpoint};\n    }\n    if (\"function\" === typeof authEndpoint) {\n      return {type:\"custom\", callback:authEndpoint};\n    }\n    if (void 0 !== authEndpoint) {\n      throw Error(\"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\");\n    }\n    throw Error(\"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\");\n  }\n  async function fetchAuthEndpoint(fetch, endpoint, body) {\n    fetch = await fetch(endpoint, {method:\"POST\", headers:{\"Content-Type\":\"application/json\"}, body:JSON.stringify(body)});\n    if (!fetch.ok) {\n      endpoint = `${(await fetch.text()).trim() || \"reason not provided in auth response\"} (${fetch.status} returned by POST ${endpoint})`;\n      if (401 === fetch.status || 403 === fetch.status) {\n        throw new StopRetrying(`Unauthorized: ${endpoint}`);\n      }\n      throw Error(`Failed to authenticate: ${endpoint}`);\n    }\n    let data;\n    try {\n      data = await fetch.json();\n    } catch (er) {\n      throw Error(`Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(er)}`);\n    }\n    if (!isPlainObject(data) || \"string\" !== typeof data.token) {\n      throw Error(`Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(data)}`);\n    }\n    ({token:endpoint} = data);\n    return {token:endpoint};\n  }\n  function sendToPanel(message, options) {\n    \"undefined\" !== typeof window && (message = {...message, source:\"liveblocks-devtools-client\"}, (_optionalChain([options, \"optionalAccess\", _38 => _38.force]) || _bridgeActive) && window.postMessage(message, \"*\"));\n  }\n  function setupDevTools(getAllRooms) {\n    \"undefined\" === typeof window || _devtoolsSetupHasRun || (_devtoolsSetupHasRun = !0, onMessageFromPanel.subscribe(msg => {\n      switch(msg.msg) {\n        case \"connect\":\n          _bridgeActive = !0;\n          for (const roomId of getAllRooms()) {\n            sendToPanel({msg:\"room::available\", roomId, clientVersion:\"2.10.2\"});\n          }\n      }\n    }), sendToPanel({msg:\"wake-up-devtools\"}, {force:!0}));\n  }\n  function stopSyncStream(roomId) {\n    const unsubs = _nullishCoalesce(unsubsByRoomId.get(roomId), () => []);\n    unsubsByRoomId.delete(roomId);\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  }\n  function startSyncStream(room) {\n    stopSyncStream(room.id);\n    fullSync(room);\n    unsubsByRoomId.set(room.id, [room.events.status.subscribe(() => {\n      sendToPanel({msg:\"room::sync::partial\", roomId:room.id, status:room.getStatus()});\n    }), room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)), room.events.storageBatch.subscribe(() => partialSyncStorage(room)), room.events.self.subscribe(() => {\n      const me = room[kInternal].getSelf_forDevTools();\n      me && sendToPanel({msg:\"room::sync::partial\", roomId:room.id, me});\n    }), room.events.others.subscribe(() => {\n      const others = room[kInternal].getOthers_forDevTools();\n      others && sendToPanel({msg:\"room::sync::partial\", roomId:room.id, others});\n    }), room.events.ydoc.subscribe(update => {\n      sendToPanel({msg:\"room::sync::ydoc\", roomId:room.id, update});\n    }), room.events.customEvent.subscribe(eventData => {\n      sendToPanel({msg:\"room::events::custom-event\", roomId:room.id, event:{type:\"CustomEvent\", id:`event-${loadedAt}-${eventCounter++}`, key:\"Event\", connectionId:eventData.connectionId, payload:eventData.event}});\n    })]);\n  }\n  function partialSyncStorage(room) {\n    const root = room.getStorageSnapshot();\n    root && sendToPanel({msg:\"room::sync::partial\", roomId:room.id, storage:root.toTreeNode(\"root\").payload});\n  }\n  function fullSync(room) {\n    const root = room.getStorageSnapshot(), me = room[kInternal].getSelf_forDevTools(), others = room[kInternal].getOthers_forDevTools();\n    room.fetchYDoc(\"\");\n    sendToPanel({msg:\"room::sync::full\", roomId:room.id, status:room.getStatus(), storage:_nullishCoalesce(_optionalChain([root, \"optionalAccess\", _41 => _41.toTreeNode, \"call\", _42 => _42(\"root\"), \"access\", _43 => _43.payload]), () => null), me, others});\n  }\n  function stopRoomChannelListener(roomId) {\n    const listener = roomChannelListeners.get(roomId);\n    roomChannelListeners.delete(roomId);\n    listener && listener();\n  }\n  function linkDevTools(roomId, room) {\n    \"undefined\" !== typeof window && (sendToPanel({msg:\"room::available\", roomId, clientVersion:\"2.10.2\"}), stopRoomChannelListener(roomId), roomChannelListeners.set(roomId, onMessageFromPanel.subscribe(msg => {\n      switch(msg.msg) {\n        case \"room::subscribe\":\n          msg.roomId === roomId && startSyncStream(room);\n          break;\n        case \"room::unsubscribe\":\n          msg.roomId === roomId && stopSyncStream(roomId);\n      }\n    })));\n  }\n  function stringify(object, ...args) {\n    if (\"object\" !== typeof object || null === object || Array.isArray(object)) {\n      return JSON.stringify(object, ...args);\n    }\n    const sortedObject = Object.keys(object).sort().reduce((sortedObject2, key) => {\n      sortedObject2[key] = object[key];\n      return sortedObject2;\n    }, {});\n    return JSON.stringify(sortedObject, ...args);\n  }\n  function createBatchStore(batch) {\n    const cache = new Map(), eventSource2 = makeEventSource();\n    return {...eventSource2.observable, get:async function(input) {\n      const cacheKey = stringify(input);\n      if (!cache.has(cacheKey)) {\n        try {\n          cache.set(cacheKey, {isLoading:!0});\n          eventSource2.notify();\n          const result = await batch.get(input);\n          cache.set(cacheKey, {isLoading:!1, data:result});\n          eventSource2.notify();\n        } catch (error3) {\n          cache.set(cacheKey, {isLoading:!1, error:error3}), eventSource2.notify();\n        }\n      }\n    }, getState:function(input) {\n      input = stringify(input);\n      return cache.get(input);\n    }, invalidate:function(inputs) {\n      if (Array.isArray(inputs)) {\n        for (const input of inputs) {\n          cache.delete(stringify(input));\n        }\n      } else {\n        cache.clear();\n      }\n      eventSource2.notify();\n    }, _cacheKeys:function() {\n      return [...cache.keys()];\n    }};\n  }\n  function createStore(initialState) {\n    function notify() {\n      if (dirty) {\n        dirty = !1;\n        for (const subscriber of subscribers) {\n          subscriber(state);\n        }\n      }\n    }\n    let notifyImmediately = !0, dirty = !1, state = initialState;\n    const subscribers = new Set();\n    return {get:function() {\n      return state;\n    }, set:function(callback) {\n      const oldState = state;\n      callback = callback(oldState);\n      callback !== oldState && (state = callback, dirty = !0);\n      notifyImmediately && notify();\n    }, batch:function(cb) {\n      if (!1 === notifyImmediately) {\n        return cb();\n      }\n      notifyImmediately = !1;\n      try {\n        cb();\n      } finally {\n        notifyImmediately = !0, notify();\n      }\n    }, subscribe:function(callback) {\n      subscribers.add(callback);\n      return () => {\n        subscribers.delete(callback);\n      };\n    }};\n  }\n  function convertToCommentData(data) {\n    const editedAt = data.editedAt ? new Date(data.editedAt) : void 0, createdAt = new Date(data.createdAt), reactions = data.reactions.map(reaction => ({...reaction, createdAt:new Date(reaction.createdAt)}));\n    return data.body ? {...data, reactions, createdAt, editedAt} : {...data, reactions, createdAt, editedAt, deletedAt:new Date(data.deletedAt)};\n  }\n  function convertToThreadData(data) {\n    const createdAt = new Date(data.createdAt), updatedAt = new Date(data.updatedAt), comments = data.comments.map(comment => convertToCommentData(comment));\n    return {...data, createdAt, updatedAt, comments};\n  }\n  function convertToCommentUserReaction(data) {\n    return {...data, createdAt:new Date(data.createdAt)};\n  }\n  function convertToInboxNotificationData(data) {\n    const notifiedAt = new Date(data.notifiedAt), readAt = data.readAt ? new Date(data.readAt) : null;\n    if (\"activities\" in data) {\n      const activities = data.activities.map(activity => ({...activity, createdAt:new Date(activity.createdAt)}));\n      return {...data, notifiedAt, readAt, activities};\n    }\n    return {...data, notifiedAt, readAt};\n  }\n  function convertToThreadDeleteInfo(data) {\n    return {...data, deletedAt:new Date(data.deletedAt)};\n  }\n  function convertToInboxNotificationDeleteInfo(data) {\n    return {...data, deletedAt:new Date(data.deletedAt)};\n  }\n  async function autoRetry(promiseFn, maxTries, backoff, shouldStopRetrying = DONT_RETRY_4XX) {\n    const fallbackBackoff = 0 < backoff.length ? backoff[backoff.length - 1] : 0;\n    let attempt = 0;\n    for (;;) {\n      attempt++;\n      try {\n        return await promiseFn();\n      } catch (err) {\n        if (shouldStopRetrying(err)) {\n          throw err;\n        }\n        if (attempt >= maxTries) {\n          throw Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n        }\n      }\n      const delay = _nullishCoalesce(backoff[attempt - 1], () => fallbackBackoff);\n      warn(`Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`);\n      await wait(delay);\n    }\n  }\n  function urljoin(baseUrl, path, params) {\n    baseUrl = new URL(path, baseUrl);\n    if (void 0 !== params) {\n      if (!(params instanceof URLSearchParams)) {\n        path = new URLSearchParams();\n        for (const [key, value] of Object.entries(params)) {\n          void 0 !== value && null !== value && path.set(key, value.toString());\n        }\n        params = path;\n      }\n      baseUrl.search = params.toString();\n    }\n    return baseUrl.toString();\n  }\n  function url(strings, ...values) {\n    return strings.reduce((result, str, i) => result + encodeURIComponent(_nullishCoalesce(values[i - 1], () => \"\")) + str);\n  }\n  function getBearerTokenFromAuthValue(authValue) {\n    return \"public\" === authValue.type ? authValue.publicApiKey : authValue.token.raw;\n  }\n  function createNotificationsApi({baseUrl, authManager, currentUserIdStore, fetchPolyfill}) {\n    async function markInboxNotificationsAsRead(inboxNotificationIds) {\n      await httpClient.post(url`/v2/c/inbox-notifications/read`, {inboxNotificationIds});\n    }\n    const httpClient = new HttpClient(baseUrl, fetchPolyfill, async function() {\n      const authValue = await authManager.getAuthValue({requestedScope:\"comments:read\"});\n      if (\"secret\" === authValue.type && \"acc\" === authValue.token.parsed.k) {\n        const userId = authValue.token.parsed.uid;\n        currentUserIdStore.set(() => userId);\n      }\n      return authValue;\n    }), batchedMarkInboxNotificationsAsRead = new Batch(async batchedInboxNotificationIds => {\n      batchedInboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(batchedInboxNotificationIds);\n      return batchedInboxNotificationIds;\n    }, {delay:50});\n    return {getInboxNotifications:async function(options) {\n      options = await httpClient.get(url`/v2/c/inbox-notifications`, {cursor:_optionalChain([options, \"optionalAccess\", _46 => _46.cursor]), limit:50});\n      return {inboxNotifications:options.inboxNotifications.map(convertToInboxNotificationData), threads:options.threads.map(convertToThreadData), nextCursor:options.meta.nextCursor, requestedAt:new Date(options.meta.requestedAt)};\n    }, getInboxNotificationsSince:async function(options) {\n      options = await httpClient.get(url`/v2/c/inbox-notifications/delta`, {since:options.since.toISOString()}, {signal:_optionalChain([options, \"optionalAccess\", _47 => _47.signal])});\n      return {inboxNotifications:{updated:options.inboxNotifications.map(convertToInboxNotificationData), deleted:options.deletedInboxNotifications.map(convertToInboxNotificationDeleteInfo)}, threads:{updated:options.threads.map(convertToThreadData), deleted:options.deletedThreads.map(convertToThreadDeleteInfo)}, requestedAt:new Date(options.meta.requestedAt)};\n    }, getUnreadInboxNotificationsCount:async function() {\n      const {count} = await httpClient.get(url`/v2/c/inbox-notifications/count`);\n      return count;\n    }, markAllInboxNotificationsAsRead:async function() {\n      await httpClient.post(url`/v2/c/inbox-notifications/read`, {inboxNotificationIds:\"all\"});\n    }, markInboxNotificationAsRead:async function(inboxNotificationId) {\n      await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n    }, deleteAllInboxNotifications:async function() {\n      await httpClient.delete(url`/v2/c/inbox-notifications`);\n    }, deleteInboxNotification:async function(inboxNotificationId) {\n      await httpClient.delete(url`/v2/c/inbox-notifications/${inboxNotificationId}`);\n    }, getUserThreads_experimental:async function(options) {\n      let query;\n      _optionalChain([options, \"optionalAccess\", _48 => _48.query]) && (query = objectToQuery(options.query));\n      options = await httpClient.get(url`/v2/c/threads`, {cursor:options.cursor, query, limit:50});\n      return {threads:options.threads.map(convertToThreadData), inboxNotifications:options.inboxNotifications.map(convertToInboxNotificationData), nextCursor:options.meta.nextCursor, requestedAt:new Date(options.meta.requestedAt)};\n    }, getUserThreadsSince_experimental:async function(options) {\n      options = await httpClient.get(url`/v2/c/threads/delta`, {since:options.since.toISOString()}, {signal:options.signal});\n      return {threads:{updated:options.threads.map(convertToThreadData), deleted:options.deletedThreads.map(convertToThreadDeleteInfo)}, inboxNotifications:{updated:options.inboxNotifications.map(convertToInboxNotificationData), deleted:options.deletedInboxNotifications.map(convertToInboxNotificationDeleteInfo)}, requestedAt:new Date(options.meta.requestedAt)};\n    }};\n  }\n  function nthDigit(n) {\n    const code = 32 + (0 > n ? 95 + n : n);\n    if (32 > code || 126 < code) {\n      throw Error(`Invalid n value: ${n}`);\n    }\n    return String.fromCharCode(code);\n  }\n  function makePosition(x, y) {\n    if (void 0 !== x && void 0 !== y) {\n      if (x < y) {\n        y = _between(x, y);\n      } else if (x > y) {\n        y = _between(y, x);\n      } else {\n        throw Error(\"Cannot compute value between two equal positions\");\n      }\n      return y;\n    }\n    if (void 0 !== x) {\n      a: {\n        for (y = 0; y <= x.length - 1; y++) {\n          var code$jscomp$0 = x.charCodeAt(y);\n          if (!(126 <= code$jscomp$0)) {\n            y = x.substring(0, y) + String.fromCharCode(code$jscomp$0 + 1);\n            break a;\n          }\n        }\n        y = x + ONE;\n      }\n      return y;\n    }\n    if (void 0 !== y) {\n      a: {\n        x = y.length - 1;\n        for (code$jscomp$0 = 0; code$jscomp$0 <= x; code$jscomp$0++) {\n          const code = y.charCodeAt(code$jscomp$0);\n          if (!(32 >= code)) {\n            y = code$jscomp$0 === x ? 33 === code ? y.substring(0, code$jscomp$0) + ZERO_NINE : y.substring(0, code$jscomp$0) + String.fromCharCode(code - 1) : y.substring(0, code$jscomp$0 + 1);\n            break a;\n          }\n        }\n        y = ONE;\n      }\n    } else {\n      y = ONE;\n    }\n    return y;\n  }\n  function _between(lo, hi) {\n    var index = 0;\n    const loLen = lo.length, hiLen = hi.length;\n    for (;;) {\n      var loCode = index < loLen ? lo.charCodeAt(index) : 32, hiCode = index < hiLen ? hi.charCodeAt(index) : 126;\n      if (loCode === hiCode) {\n        index++;\n      } else {\n        return 1 === hiCode - loCode ? (hiCode = index + 1, loCode = lo.substring(0, hiCode), loCode.length < hiCode && (loCode += ZERO.repeat(hiCode - loCode.length)), lo = lo.substring(hiCode), loCode + _between(lo, \"\")) : (index < lo.length ? lo.substring(0, index) : lo + ZERO.repeat(index - lo.length)) + String.fromCharCode(hiCode + loCode >> 1);\n      }\n    }\n  }\n  function isPos(str) {\n    if (\"\" === str) {\n      return !1;\n    }\n    const lastIdx = str.length - 1;\n    var last = str.charCodeAt(lastIdx);\n    if (33 > last || 126 < last) {\n      return !1;\n    }\n    for (last = 0; last < lastIdx; last++) {\n      const code = str.charCodeAt(last);\n      if (32 > code || 126 < code) {\n        return !1;\n      }\n    }\n    return !0;\n  }\n  function asPos(str) {\n    if (!isPos(str)) {\n      const codes = [];\n      for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n        codes.push(32 > code ? 32 : 126 < code ? 126 : code);\n      }\n      for (; 0 < codes.length && 32 === codes[codes.length - 1];) {\n        codes.length--;\n      }\n      str = 0 < codes.length ? String.fromCharCode(...codes) : ONE;\n    }\n    return str;\n  }\n  function HasParent(node, key, pos = asPos(key)) {\n    return Object.freeze({type:\"HasParent\", node, key, pos});\n  }\n  function Orphaned(oldKey, oldPos = asPos(oldKey)) {\n    return Object.freeze({type:\"Orphaned\", oldKey, oldPos});\n  }\n  function isRootCrdt(crdt) {\n    return 0 === crdt.type && !isChildCrdt(crdt);\n  }\n  function isChildCrdt(crdt) {\n    return void 0 !== crdt.parentId && void 0 !== crdt.parentKey;\n  }\n  function compareNodePosition(itemA, itemB) {\n    itemA = itemA._parentPos;\n    itemB = itemB._parentPos;\n    return itemA === itemB ? 0 : itemA < itemB ? -1 : 1;\n  }\n  function makeUpdate(liveList, deltaUpdates) {\n    return {node:liveList, type:\"LiveList\", updates:deltaUpdates};\n  }\n  function setDelta(index, item) {\n    return {index, type:\"set\", item:item instanceof LiveRegister ? item.data : item};\n  }\n  function deleteDelta(index, deletedNode) {\n    return {type:\"delete\", index, deletedItem:deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode};\n  }\n  function insertDelta(index, item) {\n    return {index, type:\"insert\", item:item instanceof LiveRegister ? item.data : item};\n  }\n  function moveDelta(previousIndex, index, item) {\n    return {type:\"move\", index, item:item instanceof LiveRegister ? item.data : item, previousIndex};\n  }\n  function HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n    return ops.map((op, index) => 0 === index ? {...op, intent:\"set\", deletedId} : op);\n  }\n  function creationOpToLson(op) {\n    switch(op.type) {\n      case 8:\n        return op.data;\n      case 4:\n        return new LiveObject(op.data);\n      case 7:\n        return new LiveMap();\n      case 2:\n        return new LiveList([]);\n      default:\n        return assertNever(op, \"Unknown creation Op\");\n    }\n  }\n  function isSameNodeOrChildOf(node, parent) {\n    return node === parent ? !0 : \"HasParent\" === node.parent.type ? isSameNodeOrChildOf(node.parent.node, parent) : !1;\n  }\n  function deserialize([id, crdt], parentToChildren, pool) {\n    switch(crdt.type) {\n      case 0:\n        return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n      case 1:\n        return LiveList._deserialize([id, crdt], parentToChildren, pool);\n      case 2:\n        return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n      case 3:\n        return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n      default:\n        throw Error(\"Unexpected CRDT type\");\n    }\n  }\n  function deserializeToLson([id, crdt], parentToChildren, pool) {\n    switch(crdt.type) {\n      case 0:\n        return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n      case 1:\n        return LiveList._deserialize([id, crdt], parentToChildren, pool);\n      case 2:\n        return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n      case 3:\n        return crdt.data;\n      default:\n        throw Error(\"Unexpected CRDT type\");\n    }\n  }\n  function isLiveStructure(value) {\n    return value instanceof LiveList || value instanceof LiveMap || value instanceof LiveObject;\n  }\n  function isLiveNode(value) {\n    return isLiveStructure(value) || value instanceof LiveRegister;\n  }\n  function cloneLson(value) {\n    return void 0 === value ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n  }\n  function liveNodeToLson(obj) {\n    return obj instanceof LiveRegister ? obj.data : obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject ? obj : assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n  function lsonToLiveNode(value) {\n    return value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList ? value : new LiveRegister(value);\n  }\n  function getTreesDiffOperations(currentItems, newItems) {\n    const ops = [];\n    currentItems.forEach((_, id) => {\n      newItems.get(id) || ops.push({type:5, id});\n    });\n    newItems.forEach((crdt, id) => {\n      const currentCrdt = currentItems.get(id);\n      if (currentCrdt) {\n        0 !== crdt.type || 0 === currentCrdt.type && JSON.stringify(crdt.data) === JSON.stringify(currentCrdt.data) || ops.push({type:3, id, data:crdt.data}), crdt.parentKey !== currentCrdt.parentKey && ops.push({type:1, id, parentKey:nn(crdt.parentKey, \"Parent key must not be missing\")});\n      } else {\n        switch(crdt.type) {\n          case 3:\n            ops.push({type:8, id, parentId:crdt.parentId, parentKey:crdt.parentKey, data:crdt.data});\n            break;\n          case 1:\n            ops.push({type:2, id, parentId:crdt.parentId, parentKey:crdt.parentKey});\n            break;\n          case 0:\n            if (void 0 === crdt.parentId || void 0 === crdt.parentKey) {\n              throw Error(\"Internal error. Cannot serialize storage root into an operation\");\n            }\n            ops.push({type:4, id, parentId:crdt.parentId, parentKey:crdt.parentKey, data:crdt.data});\n            break;\n          case 2:\n            ops.push({type:7, id, parentId:crdt.parentId, parentKey:crdt.parentKey});\n        }\n      }\n    });\n    return ops;\n  }\n  function mergeStorageUpdates(first, second) {\n    if (void 0 === first) {\n      return second;\n    }\n    if (\"LiveObject\" === first.type && \"LiveObject\" === second.type) {\n      first = first.updates;\n      for (const [key, value] of Object.entries(second.updates)) {\n        first[key] = value;\n      }\n      return {...second, updates:first};\n    }\n    if (\"LiveMap\" === first.type && \"LiveMap\" === second.type) {\n      first = first.updates;\n      for (const [key, value] of Object.entries(second.updates)) {\n        first[key] = value;\n      }\n      return {...second, updates:first};\n    }\n    return \"LiveList\" === first.type && \"LiveList\" === second.type ? {...second, updates:first.updates.concat(second.updates)} : second;\n  }\n  function isPlain(value) {\n    const type = typeof value;\n    return void 0 === value || null === value || \"string\" === type || \"boolean\" === type || \"number\" === type || Array.isArray(value) || isPlainObject(value);\n  }\n  function findNonSerializableValue(value, path = \"\") {\n    if (!isPlain) {\n      return {path:path || \"root\", value};\n    }\n    if (\"object\" !== typeof value || null === value) {\n      return !1;\n    }\n    for (const [key, nestedValue] of Object.entries(value)) {\n      value = path ? path + \".\" + key : key;\n      if (!isPlain(nestedValue)) {\n        return {path:value, value:nestedValue};\n      }\n      if (\"object\" === typeof nestedValue && (value = findNonSerializableValue(nestedValue, value))) {\n        return value;\n      }\n    }\n    return !1;\n  }\n  function chunk(array, size) {\n    const chunks = [];\n    for (let i = 0, j = array.length; i < j; i += size) {\n      chunks.push(array.slice(i, i + size));\n    }\n    return chunks;\n  }\n  function createThreadId() {\n    return `${\"th\"}_${nanoid()}`;\n  }\n  function createCommentId() {\n    return `${\"cm\"}_${nanoid()}`;\n  }\n  function captureStackTrace(msg, traceRoot) {\n    msg = {name:msg};\n    if (\"function\" === typeof Error.captureStackTrace) {\n      return Error.captureStackTrace(msg, traceRoot), msg.stack;\n    }\n  }\n  function isJsonScalar(data) {\n    return null === data || \"string\" === typeof data || \"number\" === typeof data || \"boolean\" === typeof data;\n  }\n  function isJsonArray(data) {\n    return Array.isArray(data);\n  }\n  function isJsonObject(data) {\n    return !isJsonScalar(data) && !isJsonArray(data);\n  }\n  function objectToQuery(obj) {\n    let filterList = [];\n    const keyValuePairs = [], keyValuePairsWithOperator = [], indexedKeys = [];\n    Object.entries(obj).forEach(([key, value]) => {\n      if (!identifierRegex.test(key)) {\n        throw Error(\"Key must only contain letters, numbers, _\");\n      }\n      isSimpleValue(value) ? keyValuePairs.push([key, value]) : isValueWithOperator(value) ? keyValuePairsWithOperator.push([key, value]) : \"object\" !== typeof value || \"startsWith\" in value || indexedKeys.push([key, value]);\n    });\n    filterList = [...getFiltersFromKeyValuePairs(keyValuePairs), ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)];\n    indexedKeys.forEach(([key, value]) => {\n      const nKeyValuePairs = [], nKeyValuePairsWithOperator = [];\n      Object.entries(value).forEach(([nestedKey, nestedValue]) => {\n        if (!nestedKey || \"\" === nestedKey.toString().trim()) {\n          throw Error(\"Key cannot be empty\");\n        }\n        if (isSimpleValue(nestedValue)) {\n          var JSCompiler_temp_const = nKeyValuePairs.push;\n          nestedKey = nestedKey ? `${key}[${JSON.stringify(nestedKey)}]` : key;\n          JSCompiler_temp_const.call(nKeyValuePairs, [nestedKey, nestedValue]);\n        } else {\n          isValueWithOperator(nestedValue) && (JSCompiler_temp_const = nKeyValuePairsWithOperator.push, nestedKey = nestedKey ? `${key}[${JSON.stringify(nestedKey)}]` : key, JSCompiler_temp_const.call(nKeyValuePairsWithOperator, [nestedKey, nestedValue]));\n        }\n      });\n      filterList = [...filterList, ...getFiltersFromKeyValuePairs(nKeyValuePairs), ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)];\n    });\n    return filterList.map(({key, operator, value}) => {\n      if (\"string\" === typeof value) {\n        if (!value || \"\" === value.toString().trim()) {\n          throw Error(\"Value cannot be empty\");\n        }\n        value = JSON.stringify(value);\n      } else {\n        value = value.toString();\n      }\n      return `${key}${operator}${value}`;\n    }).join(\" AND \");\n  }\n  function merge(target, patch) {\n    let updated = !1;\n    const newValue = {...target};\n    Object.keys(patch).forEach(k => {\n      const val = patch[k];\n      newValue[k] !== val && (void 0 === val ? delete newValue[k] : newValue[k] = val, updated = !0);\n    });\n    return updated ? newValue : target;\n  }\n  function makeIdFactory(connectionId) {\n    let count = 0;\n    return () => `${connectionId}:${count++}`;\n  }\n  function userToTreeNode(key, user) {\n    return {type:\"User\", id:`${user.connectionId}`, key, payload:{connectionId:user.connectionId, id:user.id, info:user.info, presence:user.presence, isReadOnly:!user.canWrite}};\n  }\n  function installBackgroundTabSpy() {\n    function onVisibilityChange() {\n      \"hidden\" === _optionalChain([doc, \"optionalAccess\", _117 => _117.visibilityState]) ? inBackgroundSince.current = _nullishCoalesce(inBackgroundSince.current, () => Date.now()) : inBackgroundSince.current = null;\n    }\n    const doc = \"undefined\" !== typeof document ? document : void 0, inBackgroundSince = {current:null};\n    _optionalChain([doc, \"optionalAccess\", _118 => _118.addEventListener, \"call\", _119 => _119(\"visibilitychange\", onVisibilityChange)]);\n    return [inBackgroundSince, () => {\n      _optionalChain([doc, \"optionalAccess\", _120 => _120.removeEventListener, \"call\", _121 => _121(\"visibilitychange\", onVisibilityChange)]);\n    }];\n  }\n  function splitFileIntoParts(file) {\n    const parts = [];\n    let start = 0;\n    for (; start < file.size;) {\n      const end = Math.min(start + 5242880, file.size);\n      parts.push({partNumber:parts.length + 1, part:file.slice(start, end)});\n      start = end;\n    }\n    return parts;\n  }\n  function createRoom(options, config) {\n    function sendMessages(messages) {\n      const serializedPayload = JSON.stringify(messages), nonce = _optionalChain([context, \"access\", _130 => _130.dynamicSessionInfo, \"access\", _131 => _131.current, \"optionalAccess\", _132 => _132.nonce]);\n      config.unstable_fallbackToHTTP && nonce && 1047552 < (new TextEncoder()).encode(serializedPayload).length ? (httpClient1.rawPost(url`/v2/c/rooms/${config.roomId}/send-message`, {nonce, messages}).then(resp => {\n        resp.ok || 403 !== resp.status || managedSocket.reconnect();\n      }), warn(\"Message was too large for websockets and sent over HTTP instead\")) : managedSocket.send(serializedPayload);\n    }\n    function notifySelfChanged(batchedUpdatesWrapper) {\n      const currSelf = self.current;\n      null !== currSelf && currSelf !== _lastSelf && (batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      }), _lastSelf = currSelf);\n    }\n    function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n      if (0 === message.items.length) {\n        throw Error(\"Internal error: cannot load storage without items\");\n      }\n      void 0 !== context.root ? updateRoot(message.items, batchedUpdatesWrapper) : context.root = LiveObject._fromItems(message.items, pool);\n      message = _nullishCoalesce(_optionalChain([self, \"access\", _133 => _133.current, \"optionalAccess\", _134 => _134.canWrite]), () => !0);\n      batchedUpdatesWrapper = context.undoStack.length;\n      for (const key in context.initialStorage) {\n        void 0 === context.root.get(key) && (message ? context.root.set(key, cloneLson(context.initialStorage[key])) : warn(`Attempted to populate missing storage key '${key}', but current user has no write access`));\n      }\n      context.undoStack.length = batchedUpdatesWrapper;\n    }\n    function updateRoot(items, batchedUpdatesWrapper) {\n      if (void 0 !== context.root) {\n        var currentItems = new Map();\n        for (const [id, node] of context.nodes) {\n          currentItems.set(id, node._serialize());\n        }\n        items = getTreesDiffOperations(currentItems, new Map(items));\n        items = applyOps(items, !1);\n        notify(items.updates, batchedUpdatesWrapper);\n      }\n    }\n    function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n      50 <= context.undoStack.length && context.undoStack.shift();\n      context.undoStack.push(historyOps);\n      onHistoryChange(batchedUpdatesWrapper);\n    }\n    function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n      null !== context.pausedHistory ? context.pausedHistory.unshift(...historyOps) : _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n    function notify(updates, batchedUpdatesWrapper) {\n      const storageUpdates = updates.storageUpdates, othersUpdates = updates.others;\n      batchedUpdatesWrapper(() => {\n        if (void 0 !== othersUpdates && 0 < othersUpdates.length) {\n          var others = context.others.current;\n          for (const event of othersUpdates) {\n            eventHub.others.notify({...event, others});\n          }\n        }\n        _nullishCoalesce(updates.presence, () => !1) && (notifySelfChanged(doNotBatchUpdates), eventHub.myPresence.notify(context.myPresence.current));\n        void 0 !== storageUpdates && 0 < storageUpdates.size && (others = Array.from(storageUpdates.values()), eventHub.storageBatch.notify(others));\n        notifyStorageStatus();\n      });\n    }\n    function getConnectionId() {\n      const info = context.dynamicSessionInfo.current;\n      if (info) {\n        return info.actor;\n      }\n      throw Error(\"Internal. Tried to get connection id but connection was never open\");\n    }\n    function applyOps(rawOps, isLocal) {\n      var JSCompiler_object_inline_reverse_1628 = [], JSCompiler_object_inline_storageUpdates_1629 = new Map(), JSCompiler_object_inline_presence_1630 = !1;\n      const createdNodeIds = new Set();\n      rawOps = rawOps.map(op => \"presence\" === op.type || op.opId ? op : {...op, opId:pool.generateOpId()});\n      for (const op of rawOps) {\n        if (\"presence\" === op.type) {\n          JSCompiler_object_inline_presence_1630 = {type:\"presence\", data:{}};\n          for (const key in op.data) {\n            JSCompiler_object_inline_presence_1630.data[key] = context.myPresence.current[key];\n          }\n          context.myPresence.patch(op.data);\n          if (null === context.buffer.presenceUpdates) {\n            context.buffer.presenceUpdates = {type:\"partial\", data:op.data};\n          } else {\n            for (const key in op.data) {\n              context.buffer.presenceUpdates.data[key] = op.data[key];\n            }\n          }\n          JSCompiler_object_inline_reverse_1628.unshift(JSCompiler_object_inline_presence_1630);\n          JSCompiler_object_inline_presence_1630 = !0;\n        } else {\n          var source = void 0;\n          isLocal ? source = 0 : (source = nn(op.opId), nn(context.opStackTraces).delete(source), source = context.unacknowledgedOps.delete(source) ? 2 : 1);\n          source = applyOp(op, source);\n          if (source.modified) {\n            const nodeId = source.modified.node._id;\n            nodeId && createdNodeIds.has(nodeId) || (JSCompiler_object_inline_storageUpdates_1629.set(nn(source.modified.node._id), mergeStorageUpdates(JSCompiler_object_inline_storageUpdates_1629.get(nn(source.modified.node._id)), source.modified)), JSCompiler_object_inline_reverse_1628.unshift(...source.reverse));\n            2 !== op.type && 7 !== op.type && 4 !== op.type || createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n      return {ops:rawOps, reverse:JSCompiler_object_inline_reverse_1628, updates:{storageUpdates:JSCompiler_object_inline_storageUpdates_1629, presence:JSCompiler_object_inline_presence_1630}};\n    }\n    function applyOp(op, source) {\n      if (5 === op.type && \"ACK\" === op.id) {\n        return {modified:!1};\n      }\n      switch(op.type) {\n        case 6:\n        case 3:\n        case 5:\n          var node = context.nodes.get(op.id);\n          return void 0 === node ? {modified:!1} : node._apply(op, 0 === source);\n        case 1:\n          return node = context.nodes.get(op.id), void 0 === node ? {modified:!1} : \"HasParent\" === node.parent.type && node.parent.node instanceof LiveList ? node.parent.node._setChildKey(asPos(op.parentKey), node, source) : {modified:!1};\n        case 4:\n        case 2:\n        case 7:\n        case 8:\n          if (void 0 === op.parentId) {\n            return {modified:!1};\n          }\n          node = context.nodes.get(op.parentId);\n          return void 0 === node ? {modified:!1} : node._attachChild(op, source);\n      }\n    }\n    function onUpdatePresenceMessage(message) {\n      if (void 0 !== message.targetActor) {\n        var oldUser = context.others.getUser(message.actor);\n        context.others.setOther(message.actor, message.data);\n        const newUser = context.others.getUser(message.actor);\n        if (void 0 === oldUser && void 0 !== newUser) {\n          return {type:\"enter\", user:newUser};\n        }\n      } else {\n        context.others.patchOther(message.actor, message.data), message;\n      }\n      if (oldUser = context.others.getUser(message.actor)) {\n        return {type:\"update\", updates:message.data, user:oldUser};\n      }\n    }\n    function onUserLeftMessage(message) {\n      const user = context.others.getUser(message.actor);\n      return user ? (context.others.removeConnection(message.actor), {type:\"leave\", user}) : null;\n    }\n    function onRoomStateMessage(message, batchedUpdatesWrapper) {\n      context.dynamicSessionInfo.set({actor:message.actor, nonce:message.nonce, scopes:message.scopes});\n      context.idFactory = makeIdFactory(message.actor);\n      notifySelfChanged(batchedUpdatesWrapper);\n      for (const connectionId of context.others.connectionIds()) {\n        void 0 === message.users[connectionId] && context.others.removeConnection(connectionId);\n      }\n      for (const key in message.users) {\n        batchedUpdatesWrapper = message.users[key], context.others.setConnection(Number(key), batchedUpdatesWrapper.id, batchedUpdatesWrapper.info, batchedUpdatesWrapper.scopes);\n      }\n      return {type:\"reset\"};\n    }\n    function canUndo() {\n      return 0 < context.undoStack.length;\n    }\n    function canRedo() {\n      return 0 < context.redoStack.length;\n    }\n    function onHistoryChange(batchedUpdatesWrapper) {\n      batchedUpdatesWrapper(() => {\n        eventHub.history.notify({canUndo:canUndo(), canRedo:canRedo()});\n      });\n    }\n    function onUserJoinedMessage(message) {\n      context.others.setConnection(message.actor, message.id, message.info, message.scopes);\n      context.buffer.messages.push({type:100, data:context.myPresence.current, targetActor:message.actor});\n      flushNowOrSoon();\n      return (message = context.others.getUser(message.actor)) ? {type:\"enter\", user:message} : void 0;\n    }\n    function parseServerMessages(text) {\n      text = tryParseJson(text);\n      return void 0 === text ? null : isJsonArray(text) ? compact(text.map(item => isJsonObject(item) ? item : null)) : compact([isJsonObject(text) ? text : null]);\n    }\n    function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n      if (0 !== offlineOps.size) {\n        var messages = [];\n        offlineOps = Array.from(offlineOps.values());\n        offlineOps = applyOps(offlineOps, !0);\n        messages.push({type:201, ops:offlineOps.ops});\n        notify(offlineOps.updates, batchedUpdatesWrapper);\n        sendMessages(messages);\n      }\n    }\n    function flushNowOrSoon() {\n      var storageOps = context.buffer.storageOperations;\n      if (0 < storageOps.length) {\n        for (var op of storageOps) {\n          context.unacknowledgedOps.set(nn(op.opId), op);\n        }\n        notifyStorageStatus();\n      }\n      if (\"connected\" !== managedSocket.getStatus()) {\n        context.buffer.storageOperations = [];\n      } else {\n        if (storageOps = Date.now(), op = storageOps - context.buffer.lastFlushedAt, op >= config.throttleDelay) {\n          op = [];\n          context.buffer.presenceUpdates && op.push(\"full\" === context.buffer.presenceUpdates.type ? {type:100, targetActor:-1, data:context.buffer.presenceUpdates.data} : {type:100, data:context.buffer.presenceUpdates.data});\n          for (JSCompiler_inline_result of context.buffer.messages) {\n            op.push(JSCompiler_inline_result);\n          }\n          0 < context.buffer.storageOperations.length && op.push({type:201, ops:context.buffer.storageOperations});\n          var JSCompiler_inline_result = op;\n          0 !== JSCompiler_inline_result.length && (sendMessages(JSCompiler_inline_result), context.buffer = {flushTimerID:void 0, lastFlushedAt:storageOps, messages:[], storageOperations:[], presenceUpdates:null});\n        } else {\n          clearTimeout(context.buffer.flushTimerID), context.buffer.flushTimerID = setTimeout(flushNowOrSoon, config.throttleDelay - op);\n        }\n      }\n    }\n    function dispatchOps(ops) {\n      const {storageOperations} = context.buffer;\n      for (const op of ops) {\n        storageOperations.push(op);\n      }\n      flushNowOrSoon();\n    }\n    function processInitialStorage(message) {\n      const unacknowledgedOps = new Map(context.unacknowledgedOps);\n      createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n      applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n      _optionalChain([_resolveStoragePromise, \"optionalCall\", _140 => _140()]);\n      notifyStorageStatus();\n      eventHub.storageDidLoad.notify();\n    }\n    async function streamStorage() {\n      if (managedSocket.authValue) {\n        var items = await (await httpClient1.rawGet(url`/v2/c/rooms/${config.roomId}/storage`)).json();\n        processInitialStorage({type:200, items});\n      }\n    }\n    function refreshStorage(options2) {\n      const messages = context.buffer.messages;\n      config.unstable_streamData ? streamStorage() : messages.some(msg => 200 === msg.type) || messages.push({type:200});\n      options2.flush && flushNowOrSoon();\n    }\n    function startLoadingStorage() {\n      null === _getStorage$ && (refreshStorage({flush:!0}), _getStorage$ = new Promise(resolve => {\n        _resolveStoragePromise = resolve;\n      }), notifyStorageStatus());\n      return _getStorage$;\n    }\n    function getStorageSnapshot() {\n      const root = context.root;\n      if (void 0 !== root) {\n        return root;\n      }\n      startLoadingStorage();\n      return null;\n    }\n    async function getStorage() {\n      if (void 0 !== context.root) {\n        return Promise.resolve({root:context.root});\n      }\n      await startLoadingStorage();\n      return {root:nn(context.root)};\n    }\n    function getStorageStatus() {\n      return void 0 === context.root ? null === _getStorage$ ? \"not-loaded\" : \"loading\" : 0 === context.unacknowledgedOps.size ? \"synchronized\" : \"synchronizing\";\n    }\n    function notifyStorageStatus() {\n      const storageStatus = getStorageStatus();\n      _lastStorageStatus !== storageStatus && (_lastStorageStatus = storageStatus, eventHub.storageStatus.notify(storageStatus));\n    }\n    function isPresenceReady() {\n      return null !== self.current;\n    }\n    function isStorageReady() {\n      return null !== getStorageSnapshot();\n    }\n    async function getAttachmentUrls(attachmentIds) {\n      ({urls:attachmentIds} = await httpClient2.post(url`/v2/c/rooms/${config.roomId}/attachments/presigned-urls`, {attachmentIds}));\n      return attachmentIds;\n    }\n    async function fetchNotificationsJson(endpoint, options2) {\n      return await httpClient2.get(endpoint, void 0, options2);\n    }\n    async function markInboxNotificationsAsRead(inboxNotificationIds) {\n      await fetchNotificationsJson(url`/v2/c/rooms/${config.roomId}/inbox-notifications/read`, {method:\"POST\", body:JSON.stringify({inboxNotificationIds})});\n    }\n    var initialPresence = options.initialPresence;\n    options = options.initialStorage;\n    const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy(), delegates = {...config.delegates, canZombie() {\n      return void 0 !== config.backgroundKeepAliveTimeout && null !== inBackgroundSince.current && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && \"synchronizing\" !== getStorageStatus();\n    }}, managedSocket = new ManagedSocket(delegates, config.enableDebugLogging), context = {buffer:{flushTimerID:void 0, lastFlushedAt:0, presenceUpdates:{type:\"full\", data:initialPresence}, messages:[], storageOperations:[]}, staticSessionInfo:new ValueRef(null), dynamicSessionInfo:new ValueRef(null), myPresence:new PatchableRef(initialPresence), others:new OthersRef(), initialStorage:options, idFactory:null, provider:void 0, onProviderUpdate:makeEventSource(), clock:0, opClock:0, nodes:new Map(), \n    root:void 0, undoStack:[], redoStack:[], pausedHistory:null, activeBatch:null, unacknowledgedOps:new Map(), opStackTraces:new Map()}, doNotBatchUpdates = cb => cb(), batchUpdates = _nullishCoalesce(config.unstable_batchedUpdates, () => doNotBatchUpdates);\n    let lastTokenKey, _connectionLossTimerId, _hasLostConnection = !1;\n    managedSocket.events.onMessage.subscribe(function(event) {\n      if (\"string\" === typeof event.data) {\n        var messages = parseServerMessages(event.data);\n        if (null !== messages && 0 !== messages.length) {\n          var updates = {storageUpdates:new Map(), others:[]};\n          batchUpdates(() => {\n            for (const message of messages) {\n              switch(message.type) {\n                case 101:\n                  var userJoinedUpdate = onUserJoinedMessage(message);\n                  userJoinedUpdate && updates.others.push(userJoinedUpdate);\n                  break;\n                case 100:\n                  (userJoinedUpdate = onUpdatePresenceMessage(message)) && updates.others.push(userJoinedUpdate);\n                  break;\n                case 103:\n                  userJoinedUpdate = context.others.current;\n                  eventHub.customEvent.notify({connectionId:message.actor, user:0 > message.actor ? null : _nullishCoalesce(userJoinedUpdate.find(u => u.connectionId === message.actor), () => null), event:message.event});\n                  break;\n                case 102:\n                  (userJoinedUpdate = onUserLeftMessage(message)) && updates.others.push(userJoinedUpdate);\n                  break;\n                case 300:\n                  eventHub.ydoc.notify(message);\n                  break;\n                case 104:\n                  updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n                  break;\n                case 200:\n                  processInitialStorage(message);\n                  break;\n                case 201:\n                  userJoinedUpdate = applyOps(message.ops, !1);\n                  for (const [key, value] of userJoinedUpdate.updates.storageUpdates) {\n                    updates.storageUpdates.set(key, mergeStorageUpdates(updates.storageUpdates.get(key), value));\n                  }\n                  break;\n                case 299:\n                  errorWithTitle(\"Storage mutation rejection error\", message.reason);\n                  userJoinedUpdate = new Set();\n                  for (const opId of message.opIds) {\n                    const trace = _optionalChain([context, \"access\", _137 => _137.opStackTraces, \"optionalAccess\", _138 => _138.get, \"call\", _139 => _139(opId)]);\n                    trace && userJoinedUpdate.add(trace);\n                  }\n                  0 < userJoinedUpdate.size && warnWithTitle(\"The following function calls caused the rejected storage mutations:\", `\n\n${Array.from(userJoinedUpdate).join(\"\\n\\n\")}`);\n                  throw Error(`Storage mutations rejected by server: ${message.reason}`);\n                case 400:\n                case 407:\n                case 401:\n                case 408:\n                case 405:\n                case 406:\n                case 402:\n                case 403:\n                case 404:\n                  eventHub.comments.notify(message);\n              }\n            }\n            notify(updates, doNotBatchUpdates);\n          });\n        }\n      }\n    });\n    managedSocket.events.statusDidChange.subscribe(function(newStatus) {\n      var authValue = managedSocket.authValue;\n      if (null !== authValue) {\n        const tokenKey = getBearerTokenFromAuthValue(authValue);\n        tokenKey !== lastTokenKey && (lastTokenKey = tokenKey, \"secret\" === authValue.type ? (authValue = authValue.token.parsed, context.staticSessionInfo.set({userId:\"sec-legacy\" === authValue.k ? authValue.id : authValue.uid, userInfo:\"sec-legacy\" === authValue.k ? authValue.info : authValue.ui})) : context.staticSessionInfo.set({userId:void 0, userInfo:void 0}));\n      }\n      batchUpdates(() => {\n        eventHub.status.notify(newStatus);\n        notifySelfChanged(doNotBatchUpdates);\n      });\n    });\n    managedSocket.events.statusDidChange.subscribe(function(newStatus) {\n      \"reconnecting\" === newStatus ? _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = !0;\n          context.others.clearOthers();\n          notify({others:[{type:\"reset\"}]}, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout) : (clearTimeout(_connectionLossTimerId), _hasLostConnection && (\"disconnected\" === newStatus ? batchUpdates(() => {\n        eventHub.lostConnection.notify(\"failed\");\n      }) : batchUpdates(() => {\n        eventHub.lostConnection.notify(\"restored\");\n      }), _hasLostConnection = !1));\n    });\n    managedSocket.events.didConnect.subscribe(function() {\n      context.buffer.presenceUpdates = {type:\"full\", data:{...context.myPresence.current}};\n      null !== _getStorage$ && refreshStorage({flush:!1});\n      flushNowOrSoon();\n    });\n    managedSocket.events.didDisconnect.subscribe(function() {\n      clearTimeout(context.buffer.flushTimerID);\n    });\n    managedSocket.events.onLiveblocksError.subscribe(err => {\n      batchUpdates(() => {\n        error2(`Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`);\n        eventHub.error.notify(err);\n      });\n    });\n    const pool = {roomId:config.roomId, getNode:id => context.nodes.get(id), addNode:(id, node) => void context.nodes.set(id, node), deleteNode:id => void context.nodes.delete(id), generateId:() => `${getConnectionId()}:${context.clock++}`, generateOpId:() => `${getConnectionId()}:${context.opClock++}`, dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch, stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n      if (stackTrace) {\n        for (const op of ops) {\n          op.opId && nn(context.opStackTraces).set(op.opId, stackTrace);\n        }\n      }\n      if (activeBatch) {\n        for (const op of ops) {\n          activeBatch.ops.push(op);\n        }\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(key, mergeStorageUpdates(activeBatch.updates.storageUpdates.get(key), value));\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({storageUpdates}, doNotBatchUpdates);\n        });\n      }\n    }, assertStorageIsWritable:() => {\n      const scopes = _optionalChain([context, \"access\", _122 => _122.dynamicSessionInfo, \"access\", _123 => _123.current, \"optionalAccess\", _124 => _124.scopes]);\n      if (void 0 !== scopes && !scopes.includes(\"room:write\")) {\n        throw Error(\"Cannot write to storage with a read only user, please ensure the user has write permissions\");\n      }\n    }}, eventHub = {status:makeEventSource(), lostConnection:makeEventSource(), customEvent:makeEventSource(), self:makeEventSource(), myPresence:makeEventSource(), others:makeEventSource(), error:makeEventSource(), storageBatch:makeEventSource(), history:makeEventSource(), storageDidLoad:makeEventSource(), storageStatus:makeEventSource(), ydoc:makeEventSource(), comments:makeEventSource()};\n    initialPresence = _optionalChain([config, \"access\", _125 => _125.polyfills, \"optionalAccess\", _126 => _126.fetch]) || _optionalChain([globalThis, \"access\", _127 => _127.fetch, \"optionalAccess\", _128 => _128.bind, \"call\", _129 => _129(globalThis)]);\n    const httpClient1 = new HttpClient(config.baseUrl, initialPresence, () => Promise.resolve(_nullishCoalesce(managedSocket.authValue, () => raise(\"Not authorized\")))), httpClient2 = new HttpClient(config.baseUrl, initialPresence, () => delegates.authenticate()), self = new DerivedRef(context.staticSessionInfo, context.dynamicSessionInfo, context.myPresence, (staticSession, dynamicSession, myPresence) => {\n      if (null === staticSession || null === dynamicSession) {\n        return null;\n      }\n      const canWrite = dynamicSession.scopes.includes(\"room:write\");\n      return {connectionId:dynamicSession.actor, id:staticSession.userId, info:staticSession.userInfo, presence:myPresence, canWrite, canComment:canComment(dynamicSession.scopes)};\n    });\n    let _lastSelf;\n    const selfAsTreeNode = new DerivedRef(self, me => null !== me ? userToTreeNode(\"Me\", me) : null);\n    let _getStorage$ = null, _resolveStoragePromise = null, _lastStorageStatus = getStorageStatus();\n    const others_forDevTools = new DerivedRef(context.others, others => others.map((other, index) => userToTreeNode(`Other ${index}`, other))), events = {status:eventHub.status.observable, lostConnection:eventHub.lostConnection.observable, customEvent:eventHub.customEvent.observable, others:eventHub.others.observable, self:eventHub.self.observable, myPresence:eventHub.myPresence.observable, error:eventHub.error.observable, storage:eventHub.storageBatch.observable, storageBatch:eventHub.storageBatch.observable, \n    history:eventHub.history.observable, storageDidLoad:eventHub.storageDidLoad.observable, storageStatus:eventHub.storageStatus.observable, ydoc:eventHub.ydoc.observable, comments:eventHub.comments.observable}, batchedGetAttachmentUrls = new Batch(async batchedAttachmentIds => {\n      batchedAttachmentIds = batchedAttachmentIds.flat();\n      return (await getAttachmentUrls(batchedAttachmentIds)).map(url2 => _nullishCoalesce(url2, () => Error(\"There was an error while getting this attachment's URL\")));\n    }, {delay:50});\n    initialPresence = createBatchStore(batchedGetAttachmentUrls);\n    const batchedMarkInboxNotificationsAsRead = new Batch(async batchedInboxNotificationIds => {\n      batchedInboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(batchedInboxNotificationIds);\n      return batchedInboxNotificationIds;\n    }, {delay:50});\n    return Object.defineProperty({[kInternal]:{get presenceBuffer() {\n      return deepClone(_nullishCoalesce(_optionalChain([context, \"access\", _152 => _152.buffer, \"access\", _153 => _153.presenceUpdates, \"optionalAccess\", _154 => _154.data]), () => null));\n    }, get undoStack() {\n      return deepClone(context.undoStack);\n    }, get nodeCount() {\n      return context.nodes.size;\n    }, getProvider() {\n      return context.provider;\n    }, setProvider(provider) {\n      context.provider = provider;\n      context.onProviderUpdate.notify();\n    }, onProviderUpdate:context.onProviderUpdate.observable, reportTextEditor:async function(type, rootKey) {\n      await httpClient2.rawPost(url`/v2/c/rooms/${config.roomId}/text-metadata`, {type, rootKey});\n    }, createTextMention:async function(userId, mentionId) {\n      await httpClient1.rawPost(url`/v2/c/rooms/${config.roomId}/text-mentions`, {userId, mentionId});\n    }, deleteTextMention:async function(mentionId) {\n      await httpClient1.rawDelete(url`/v2/c/rooms/${config.roomId}/text-mentions/${mentionId}`);\n    }, listTextVersions:async function() {\n      const result = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/versions`);\n      return {versions:result.versions.map(({createdAt, ...version}) => ({createdAt:new Date(createdAt), ...version})), requestedAt:new Date(result.meta.requestedAt)};\n    }, listTextVersionsSince:async function(options2) {\n      options2 = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/versions/delta`, {since:options2.since.toISOString()}, {signal:options2.signal});\n      return {versions:options2.versions.map(({createdAt, ...version}) => ({createdAt:new Date(createdAt), ...version})), requestedAt:new Date(options2.meta.requestedAt)};\n    }, getTextVersion:async function(versionId) {\n      return httpClient2.rawGet(url`/v2/c/rooms/${config.roomId}/y-version/${versionId}`);\n    }, createTextVersion:async function() {\n      await httpClient2.rawPost(url`/v2/c/rooms/${config.roomId}/version`);\n    }, getSelf_forDevTools:() => selfAsTreeNode.current, getOthers_forDevTools:() => others_forDevTools.current, simulate:{explicitClose:event => managedSocket._privateSendMachineEvent({type:\"EXPLICIT_SOCKET_CLOSE\", event}), rawSend:data => managedSocket.send(data)}, attachmentUrlsStore:initialPresence}, id:config.roomId, subscribe:makeClassicSubscribeFn(events), connect:() => managedSocket.connect(), reconnect:() => managedSocket.reconnect(), disconnect:() => managedSocket.disconnect(), destroy:() => \n    {\n      uninstallBgTabSpy();\n      managedSocket.destroy();\n    }, updatePresence:function(patch, options2) {\n      const oldValues = {};\n      null === context.buffer.presenceUpdates && (context.buffer.presenceUpdates = {type:\"partial\", data:{}});\n      for (const key in patch) {\n        const overrideValue = patch[key];\n        void 0 !== overrideValue && (context.buffer.presenceUpdates.data[key] = overrideValue, oldValues[key] = context.myPresence.current[key]);\n      }\n      context.myPresence.patch(patch);\n      context.activeBatch ? (_optionalChain([options2, \"optionalAccess\", _135 => _135.addToHistory]) && context.activeBatch.reverseOps.unshift({type:\"presence\", data:oldValues}), context.activeBatch.updates.presence = !0) : (flushNowOrSoon(), batchUpdates(() => {\n        _optionalChain([options2, \"optionalAccess\", _136 => _136.addToHistory]) && addToUndoStack([{type:\"presence\", data:oldValues}], doNotBatchUpdates);\n        notify({presence:!0}, doNotBatchUpdates);\n      }));\n    }, updateYDoc:function(update, guid) {\n      update = {type:301, update, guid};\n      context.buffer.messages.push(update);\n      eventHub.ydoc.notify(update);\n      flushNowOrSoon();\n    }, broadcastEvent:function(event, options2 = {shouldQueueEventIfNotReady:!1}) {\n      if (\"connected\" === managedSocket.getStatus() || options2.shouldQueueEventIfNotReady) {\n        context.buffer.messages.push({type:103, event}), flushNowOrSoon();\n      }\n    }, batch:function(callback) {\n      if (context.activeBatch) {\n        return callback();\n      }\n      let returnValue = void 0;\n      batchUpdates(() => {\n        context.activeBatch = {ops:[], updates:{storageUpdates:new Map(), presence:!1, others:[]}, reverseOps:[]};\n        try {\n          returnValue = callback();\n        } finally {\n          const currentBatch = context.activeBatch;\n          context.activeBatch = null;\n          0 < currentBatch.reverseOps.length && addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n          0 < currentBatch.ops.length && (context.redoStack.length = 0);\n          0 < currentBatch.ops.length && dispatchOps(currentBatch.ops);\n          notify(currentBatch.updates, doNotBatchUpdates);\n          flushNowOrSoon();\n        }\n      });\n      return returnValue;\n    }, history:{undo:function() {\n      if (context.activeBatch) {\n        throw Error(\"undo is not allowed during a batch\");\n      }\n      const historyOps = context.undoStack.pop();\n      if (void 0 !== historyOps) {\n        context.pausedHistory = null;\n        var result = applyOps(historyOps, !0);\n        batchUpdates(() => {\n          notify(result.updates, doNotBatchUpdates);\n          context.redoStack.push(result.reverse);\n          onHistoryChange(doNotBatchUpdates);\n        });\n        for (const op of result.ops) {\n          \"presence\" !== op.type && context.buffer.storageOperations.push(op);\n        }\n        flushNowOrSoon();\n      }\n    }, redo:function() {\n      if (context.activeBatch) {\n        throw Error(\"redo is not allowed during a batch\");\n      }\n      const historyOps = context.redoStack.pop();\n      if (void 0 !== historyOps) {\n        context.pausedHistory = null;\n        var result = applyOps(historyOps, !0);\n        batchUpdates(() => {\n          notify(result.updates, doNotBatchUpdates);\n          context.undoStack.push(result.reverse);\n          onHistoryChange(doNotBatchUpdates);\n        });\n        for (const op of result.ops) {\n          \"presence\" !== op.type && context.buffer.storageOperations.push(op);\n        }\n        flushNowOrSoon();\n      }\n    }, canUndo, canRedo, clear:function() {\n      context.undoStack.length = 0;\n      context.redoStack.length = 0;\n    }, pause:function() {\n      null === context.pausedHistory && (context.pausedHistory = []);\n    }, resume:function() {\n      const historyOps = context.pausedHistory;\n      context.pausedHistory = null;\n      null !== historyOps && 0 < historyOps.length && _addToRealUndoStack(historyOps, batchUpdates);\n    }}, fetchYDoc:function(vector, guid) {\n      context.buffer.messages.find(m => 300 === m.type && m.vector === vector && m.guid === guid) || context.buffer.messages.push({type:300, vector, guid});\n      flushNowOrSoon();\n    }, getStorage, getStorageSnapshot, getStorageStatus, isPresenceReady, isStorageReady, waitUntilPresenceReady:memoizeOnSuccess(async function() {\n      for (; !isPresenceReady();) {\n        const {promise, resolve} = Promise_withResolvers(), unsub1 = events.self.subscribeOnce(resolve), unsub2 = events.status.subscribeOnce(resolve);\n        await promise;\n        unsub1();\n        unsub2();\n      }\n    }), waitUntilStorageReady:memoizeOnSuccess(async function() {\n      for (; !isStorageReady();) {\n        await getStorage();\n      }\n    }), events, getStatus:() => managedSocket.getStatus(), getSelf:() => self.current, getPresence:() => context.myPresence.current, getOthers:() => context.others.current, getThreads:async function(options2) {\n      let query;\n      _optionalChain([options2, \"optionalAccess\", _144 => _144.query]) && (query = objectToQuery(options2.query));\n      options2 = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/threads`, {cursor:_optionalChain([options2, \"optionalAccess\", _145 => _145.cursor]), query, limit:50});\n      return {threads:options2.data.map(convertToThreadData), inboxNotifications:options2.inboxNotifications.map(convertToInboxNotificationData), nextCursor:options2.meta.nextCursor, requestedAt:new Date(options2.meta.requestedAt)};\n    }, getThreadsSince:async function(options2) {\n      options2 = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/threads/delta`, {since:_optionalChain([options2, \"optionalAccess\", _141 => _141.since, \"optionalAccess\", _142 => _142.toISOString, \"call\", _143 => _143()])}, {signal:options2.signal});\n      return {threads:{updated:options2.data.map(convertToThreadData), deleted:options2.deletedThreads.map(convertToThreadDeleteInfo)}, inboxNotifications:{updated:options2.inboxNotifications.map(convertToInboxNotificationData), deleted:options2.deletedInboxNotifications.map(convertToInboxNotificationDeleteInfo)}, requestedAt:new Date(options2.meta.requestedAt)};\n    }, getThread:async function(threadId) {\n      const response = await httpClient2.rawGet(url`/v2/c/rooms/${config.roomId}/thread-with-notification/${threadId}`);\n      if (response.ok) {\n        return threadId = await response.json(), {thread:convertToThreadData(threadId.thread), inboxNotification:threadId.inboxNotification ? convertToInboxNotificationData(threadId.inboxNotification) : void 0};\n      }\n      if (404 === response.status) {\n        return {thread:void 0, inboxNotification:void 0};\n      }\n      throw Error(`There was an error while getting thread ${threadId}.`);\n    }, createThread:async function({metadata, body, commentId = createCommentId(), threadId = createThreadId(), attachmentIds}) {\n      metadata = await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads`, {id:threadId, comment:{id:commentId, body, attachmentIds}, metadata});\n      return convertToThreadData(metadata);\n    }, deleteThread:async function(threadId) {\n      await httpClient2.delete(url`/v2/c/rooms/${config.roomId}/threads/${threadId}`);\n    }, editThreadMetadata:async function({metadata, threadId}) {\n      return await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/metadata`, metadata);\n    }, markThreadAsResolved:async function(threadId) {\n      await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-resolved`);\n    }, markThreadAsUnresolved:async function(threadId) {\n      await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-unresolved`);\n    }, createComment:async function({threadId, commentId = createCommentId(), body, attachmentIds}) {\n      threadId = await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments`, {id:commentId, body, attachmentIds});\n      return convertToCommentData(threadId);\n    }, editComment:async function({threadId, commentId, body, attachmentIds}) {\n      threadId = await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`, {body, attachmentIds});\n      return convertToCommentData(threadId);\n    }, deleteComment:async function({threadId, commentId}) {\n      await httpClient2.delete(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`);\n    }, addReaction:async function({threadId, commentId, emoji}) {\n      threadId = await httpClient2.post(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions`, {emoji});\n      return convertToCommentUserReaction(threadId);\n    }, removeReaction:async function({threadId, commentId, emoji}) {\n      await httpClient2.delete(url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions/${emoji}`);\n    }, prepareAttachment:function(file) {\n      return {type:\"localAttachment\", status:\"idle\", id:`${\"at\"}_${nanoid()}`, name:file.name, size:file.size, mimeType:file.type, file};\n    }, uploadAttachment:async function(attachment, options2 = {}) {\n      const abortSignal = options2.signal, abortError = abortSignal ? new DOMException(`Upload of attachment ${attachment.id} was aborted.`, \"AbortError\") : void 0;\n      if (_optionalChain([abortSignal, \"optionalAccess\", _146 => _146.aborted])) {\n        throw abortError;\n      }\n      options2 = err => {\n        if (_optionalChain([abortSignal, \"optionalAccess\", _147 => _147.aborted])) {\n          throw abortError;\n        }\n        if (err instanceof HttpError && 413 === err.status) {\n          throw err;\n        }\n        return !1;\n      };\n      if (5242880 >= attachment.size) {\n        return autoRetry(() => httpClient2.putBlob(url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`, attachment.file, {fileSize:attachment.size}, {signal:abortSignal}), 10, RETRY_DELAYS, options2);\n      }\n      let uploadId;\n      const uploadedParts = [], createMultiPartUpload = await autoRetry(() => httpClient2.post(url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`, void 0, {signal:abortSignal}, {fileSize:attachment.size}), 10, RETRY_DELAYS, options2);\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n        var parts = splitFileIntoParts(attachment.file);\n        if (_optionalChain([abortSignal, \"optionalAccess\", _148 => _148.aborted])) {\n          throw abortError;\n        }\n        const batches = chunk(parts, 5);\n        for (const parts2 of batches) {\n          parts = [];\n          for (const {part, partNumber} of parts2) {\n            parts.push(autoRetry(() => httpClient2.putBlob(url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`, part, void 0, {signal:abortSignal}), 10, RETRY_DELAYS, options2));\n          }\n          uploadedParts.push(...(await Promise.all(parts)));\n        }\n        if (_optionalChain([abortSignal, \"optionalAccess\", _149 => _149.aborted])) {\n          throw abortError;\n        }\n        const sortedUploadedParts = uploadedParts.sort((a, b) => a.partNumber - b.partNumber);\n        return httpClient2.post(url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`, {parts:sortedUploadedParts}, {signal:abortSignal});\n      } catch (error3) {\n        if (uploadId && _optionalChain([error3, \"optionalAccess\", _150 => _150.name]) && (\"AbortError\" === error3.name || \"TimeoutError\" === error3.name)) {\n          try {\n            await httpClient2.rawDelete(url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}`);\n          } catch (error4) {\n          }\n        }\n        throw error3;\n      }\n    }, getAttachmentUrl:function(attachmentId) {\n      return batchedGetAttachmentUrls.get(attachmentId);\n    }, getNotificationSettings:function(options2) {\n      return fetchNotificationsJson(url`/v2/c/rooms/${config.roomId}/notification-settings`, {signal:_optionalChain([options2, \"optionalAccess\", _151 => _151.signal])});\n    }, updateNotificationSettings:function(settings) {\n      return fetchNotificationsJson(url`/v2/c/rooms/${config.roomId}/notification-settings`, {method:\"POST\", body:JSON.stringify(settings)});\n    }, markInboxNotificationAsRead:async function(inboxNotificationId) {\n      await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n    }}, kInternal, {enumerable:!1});\n  }\n  function makeClassicSubscribeFn(events) {\n    function subscribeToLiveStructureDeeply(node, callback) {\n      return events.storageBatch.subscribe(updates => {\n        updates = updates.filter(update => isSameNodeOrChildOf(update.node, node));\n        0 < updates.length && callback(updates);\n      });\n    }\n    function subscribeToLiveStructureShallowly(node, callback) {\n      return events.storageBatch.subscribe(updates => {\n        for (const update of updates) {\n          update.node._id === node._id && callback(update.node);\n        }\n      });\n    }\n    return function(first, second, options) {\n      if (\"string\" === typeof first && (\"my-presence\" === first || \"others\" === first || \"event\" === first || \"error\" === first || \"history\" === first || \"status\" === first || \"storage-status\" === first || \"lost-connection\" === first || \"connection\" === first || \"comments\" === first)) {\n        if (\"function\" !== typeof second) {\n          throw Error(\"Second argument must be a callback function\");\n        }\n        switch(first) {\n          case \"event\":\n            return events.customEvent.subscribe(second);\n          case \"my-presence\":\n            return events.myPresence.subscribe(second);\n          case \"others\":\n            return events.others.subscribe(event => {\n              const {others, ...internalEvent} = event;\n              return second(others, internalEvent);\n            });\n          case \"error\":\n            return events.error.subscribe(second);\n          case \"status\":\n            return events.status.subscribe(second);\n          case \"lost-connection\":\n            return events.lostConnection.subscribe(second);\n          case \"history\":\n            return events.history.subscribe(second);\n          case \"storage-status\":\n            return events.storageStatus.subscribe(second);\n          case \"comments\":\n            return events.comments.subscribe(second);\n          default:\n            return assertNever(first, `\"${String(first)}\" is not a valid event name`);\n        }\n      }\n      if (void 0 === second || \"function\" === typeof first) {\n        if (\"function\" === typeof first) {\n          return events.storageBatch.subscribe(first);\n        }\n        throw Error(\"Please specify a listener callback\");\n      }\n      if (isLiveNode(first)) {\n        return _optionalChain([options, \"optionalAccess\", _155 => _155.isDeep]) ? subscribeToLiveStructureDeeply(first, second) : subscribeToLiveStructureShallowly(first, second);\n      }\n      throw Error(`${String(first)} is not a value that can be subscribed to.`);\n    };\n  }\n  function makeAuthDelegateForRoom(roomId, authManager) {\n    return async() => authManager.getAuthValue({requestedScope:\"room:read\", roomId});\n  }\n  function makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n    return authValue => {\n      const ws = _nullishCoalesce(WebSocketPolyfill, () => \"undefined\" === typeof WebSocket ? void 0 : WebSocket);\n      if (void 0 === ws) {\n        throw new StopRetrying(\"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\");\n      }\n      const url2 = new URL(baseUrl);\n      url2.protocol = \"http:\" === url2.protocol ? \"ws\" : \"wss\";\n      url2.pathname = \"/v7\";\n      url2.searchParams.set(\"roomId\", roomId);\n      if (\"secret\" === authValue.type) {\n        url2.searchParams.set(\"tok\", authValue.token.raw);\n      } else if (\"public\" === authValue.type) {\n        url2.searchParams.set(\"pubkey\", authValue.publicApiKey);\n      } else {\n        return assertNever(authValue, \"Unhandled case\");\n      }\n      url2.searchParams.set(\"version\", \"2.10.2\");\n      return new ws(url2.toString());\n    };\n  }\n  function getBaseUrl(baseUrl) {\n    return \"string\" === typeof baseUrl && baseUrl.startsWith(\"http\") ? baseUrl : \"https://api.liveblocks.io\";\n  }\n  function checkBounds(option, value, min, max, recommendedMin) {\n    if (\"number\" !== typeof value || value < min || void 0 !== max && value > max) {\n      throw Error(void 0 !== max ? `${option} should be between ${_nullishCoalesce(recommendedMin, () => min)} and ${max}.` : `${option} should be at least ${_nullishCoalesce(recommendedMin, () => min)}.`);\n    }\n    return value;\n  }\n  function getBackgroundKeepAliveTimeout(value) {\n    if (void 0 !== value) {\n      return checkBounds(\"backgroundKeepAliveTimeout\", value, 15e3);\n    }\n  }\n  function createDevelopmentWarning(condition, ...args) {\n    let hasWarned = !1;\n    return () => {\n      !hasWarned && (\"function\" === typeof condition ? condition() : condition) && (warn(...args), hasWarned = !0);\n    };\n  }\n  function isCommentBodyText(element) {\n    return !(\"type\" in element) && \"text\" in element && \"string\" === typeof element.text;\n  }\n  function isCommentBodyMention(element) {\n    return \"type\" in element && \"mention\" === element.type;\n  }\n  function isCommentBodyLink(element) {\n    return \"type\" in element && \"link\" === element.type;\n  }\n  function traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n    if (body && _optionalChain([body, \"optionalAccess\", _171 => _171.content])) {\n      var element = \"string\" === typeof elementOrVisitor ? elementOrVisitor : void 0, type = element ? commentBodyElementsTypes[element] : \"all\";\n      element = element ? commentBodyElementsGuards[element] : () => !0;\n      elementOrVisitor = \"function\" === typeof elementOrVisitor ? elementOrVisitor : possiblyVisitor;\n      for (const block of body.content) {\n        if ((\"all\" === type || \"block\" === type) && element(block) && _optionalChain([elementOrVisitor, \"optionalCall\", _172 => _172(block)]), \"all\" === type || \"inline\" === type) {\n          for (const inline of block.children) {\n            element(inline) && _optionalChain([elementOrVisitor, \"optionalCall\", _173 => _173(inline)]);\n          }\n        }\n      }\n    }\n  }\n  function getMentionedIdsFromCommentBody(body) {\n    const mentionedIds = new Set();\n    traverseCommentBody(body, \"mention\", mention => mentionedIds.add(mention.id));\n    return Array.from(mentionedIds);\n  }\n  async function resolveUsersInCommentBody(body, resolveUsers) {\n    const resolvedUsers = new Map();\n    if (!resolveUsers) {\n      return resolvedUsers;\n    }\n    body = getMentionedIdsFromCommentBody(body);\n    resolveUsers = await resolveUsers({userIds:body});\n    for (const [index, userId] of body.entries()) {\n      (body = _optionalChain([resolveUsers, \"optionalAccess\", _174 => _174[index]])) && resolvedUsers.set(userId, body);\n    }\n    return resolvedUsers;\n  }\n  function joinHtml(strings) {\n    return 0 >= strings.length ? new HtmlSafeString([\"\"], []) : new HtmlSafeString([\"\", ...Array(strings.length - 1).fill(\"\"), \"\"], strings);\n  }\n  function escapeHtml(value) {\n    return value instanceof HtmlSafeString ? value.toString() : Array.isArray(value) ? joinHtml(value).toString() : String(value).replace(htmlEscapablesRegex, character => htmlEscapables[character]);\n  }\n  function html(strings, ...values) {\n    return new HtmlSafeString(strings, values);\n  }\n  function joinMarkdown(strings) {\n    return 0 >= strings.length ? new MarkdownSafeString([\"\"], []) : new MarkdownSafeString([\"\", ...Array(strings.length - 1).fill(\"\"), \"\"], strings);\n  }\n  function escapeMarkdown(value) {\n    return value instanceof MarkdownSafeString ? value.toString() : Array.isArray(value) ? joinMarkdown(value).toString() : String(value).replace(markdownEscapablesRegex, character => markdownEscapables[character]);\n  }\n  function markdown(strings, ...values) {\n    return new MarkdownSafeString(strings, values);\n  }\n  function toAbsoluteUrl(url2) {\n    if (url2.startsWith(\"http://\") || url2.startsWith(\"https://\")) {\n      return url2;\n    }\n    if (url2.startsWith(\"www.\")) {\n      return \"https://\" + url2;\n    }\n  }\n  function toPlainLson(lson) {\n    return lson instanceof LiveObject ? {liveblocksType:\"LiveObject\", data:Object.fromEntries(Object.entries(lson.toObject()).flatMap(([key, value]) => void 0 !== value ? [[key, toPlainLson(value)]] : []))} : lson instanceof LiveMap ? {liveblocksType:\"LiveMap\", data:Object.fromEntries([...lson].map(([key, value]) => [key, toPlainLson(value)]))} : lson instanceof LiveList ? {liveblocksType:\"LiveList\", data:[...lson].map(item => toPlainLson(item))} : lson;\n  }\n  function lsonObjectToJson(obj) {\n    const result = {};\n    for (const key in obj) {\n      const val = obj[key];\n      void 0 !== val && (result[key] = lsonToJson(val));\n    }\n    return result;\n  }\n  function lsonToJson(value$jscomp$0) {\n    if (value$jscomp$0 instanceof LiveObject) {\n      return lsonObjectToJson(value$jscomp$0.toObject());\n    }\n    if (value$jscomp$0 instanceof LiveList) {\n      return value$jscomp$0.toArray().map(lsonToJson);\n    }\n    if (value$jscomp$0 instanceof LiveMap) {\n      const result = {};\n      for (const [key, value] of value$jscomp$0.entries()) {\n        result[key] = lsonToJson(value);\n      }\n      return result;\n    }\n    return value$jscomp$0 instanceof LiveRegister ? value$jscomp$0.data : Array.isArray(value$jscomp$0) ? value$jscomp$0.map(lsonToJson) : isPlainObject(value$jscomp$0) ? lsonObjectToJson(value$jscomp$0) : value$jscomp$0;\n  }\n  function deepLiveify(value) {\n    if (Array.isArray(value)) {\n      return new LiveList(value.map(deepLiveify));\n    }\n    if (isPlainObject(value)) {\n      const init = {};\n      for (const key in value) {\n        const val = value[key];\n        void 0 !== val && (init[key] = deepLiveify(val));\n      }\n      return new LiveObject(init);\n    }\n    return value;\n  }\n  function patchLiveObjectKey(liveObject, key, prev, next) {\n    var nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(`New state path: '${nonSerializableValue.path}' value: '${String(nonSerializableValue.value)}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`);\n    } else {\n      if (nonSerializableValue = liveObject.get(key), void 0 === next) {\n        liveObject.delete(key);\n      } else if (void 0 === nonSerializableValue) {\n        liveObject.set(key, deepLiveify(next));\n      } else if (prev !== next) {\n        if (nonSerializableValue instanceof LiveList && Array.isArray(prev) && Array.isArray(next)) {\n          liveObject = 0;\n          key = prev.length - 1;\n          let nextEnd = next.length - 1, prevNode = prev[0], nextNode = next[0];\n          a: {\n            for (; prevNode === nextNode;) {\n              ++liveObject;\n              if (liveObject > key || liveObject > nextEnd) {\n                break a;\n              }\n              prevNode = prev[liveObject];\n              nextNode = next[liveObject];\n            }\n            prevNode = prev[key];\n            for (nextNode = next[nextEnd]; prevNode === nextNode;) {\n              key--;\n              nextEnd--;\n              if (liveObject > key || liveObject > nextEnd) {\n                break a;\n              }\n              prevNode = prev[key];\n              nextNode = next[nextEnd];\n            }\n          }\n          if (liveObject > key) {\n            if (liveObject <= nextEnd) {\n              for (; liveObject <= nextEnd;) {\n                nonSerializableValue.insert(deepLiveify(next[liveObject]), liveObject), liveObject++;\n              }\n            }\n          } else if (liveObject > nextEnd) {\n            for (prev = liveObject; prev <= key;) {\n              nonSerializableValue.delete(liveObject), prev++;\n            }\n          } else {\n            for (; liveObject <= key && liveObject <= nextEnd;) {\n              prevNode = prev[liveObject];\n              nextNode = next[liveObject];\n              const liveListNode = nonSerializableValue.get(liveObject);\n              liveListNode instanceof LiveObject && isPlainObject(prevNode) && isPlainObject(nextNode) ? patchLiveObject(liveListNode, prevNode, nextNode) : nonSerializableValue.set(liveObject, deepLiveify(nextNode));\n              liveObject++;\n            }\n            for (; liveObject <= nextEnd;) {\n              nonSerializableValue.insert(deepLiveify(next[liveObject]), liveObject), liveObject++;\n            }\n            for (prev = liveObject; prev <= key;) {\n              nonSerializableValue.delete(liveObject), prev++;\n            }\n          }\n        } else {\n          nonSerializableValue instanceof LiveObject && isPlainObject(prev) && isPlainObject(next) ? patchLiveObject(nonSerializableValue, prev, next) : liveObject.set(key, deepLiveify(next));\n        }\n      }\n    }\n  }\n  function patchLiveObject(root, prev, next) {\n    const updates = {};\n    for (const key in next) {\n      patchLiveObjectKey(root, key, prev[key], next[key]);\n    }\n    for (const key in prev) {\n      void 0 === next[key] && root.delete(key);\n    }\n    0 < Object.keys(updates).length && root.update(updates);\n  }\n  function legacy_patchImmutableNode(state, path, update) {\n    const pathItem = path.pop();\n    if (void 0 === pathItem) {\n      switch(update.type) {\n        case \"LiveObject\":\n          if (!isJsonObject(state)) {\n            throw Error(\"Internal: received update on LiveObject but state was not an object\");\n          }\n          state = Object.assign({}, state);\n          for (const key in update.updates) {\n            \"update\" === _optionalChain([update, \"access\", _182 => _182.updates, \"access\", _183 => _183[key], \"optionalAccess\", _184 => _184.type]) ? (path = update.node.get(key), void 0 !== path && (state[key] = lsonToJson(path))) : \"delete\" === _optionalChain([update, \"access\", _185 => _185.updates, \"access\", _186 => _186[key], \"optionalAccess\", _187 => _187.type]) && delete state[key];\n          }\n          return state;\n        case \"LiveList\":\n          if (!Array.isArray(state)) {\n            throw Error(\"Internal: received update on LiveList but state was not an array\");\n          }\n          state = state.map(x => x);\n          for (const listUpdate of update.updates) {\n            \"set\" === listUpdate.type ? state = state.map((item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item) : \"insert\" === listUpdate.type ? listUpdate.index === state.length ? state.push(lsonToJson(listUpdate.item)) : state = [...state.slice(0, listUpdate.index), lsonToJson(listUpdate.item), ...state.slice(listUpdate.index)] : \"delete\" === listUpdate.type ? state.splice(listUpdate.index, 1) : \"move\" === listUpdate.type && (state = listUpdate.previousIndex > listUpdate.index ? \n            [...state.slice(0, listUpdate.index), lsonToJson(listUpdate.item), ...state.slice(listUpdate.index, listUpdate.previousIndex), ...state.slice(listUpdate.previousIndex + 1)] : [...state.slice(0, listUpdate.previousIndex), ...state.slice(listUpdate.previousIndex + 1, listUpdate.index + 1), lsonToJson(listUpdate.item), ...state.slice(listUpdate.index + 1)]);\n          }\n          return state;\n        case \"LiveMap\":\n          if (!isJsonObject(state)) {\n            throw Error(\"Internal: received update on LiveMap but state was not an object\");\n          }\n          state = Object.assign({}, state);\n          for (const key in update.updates) {\n            \"update\" === _optionalChain([update, \"access\", _188 => _188.updates, \"access\", _189 => _189[key], \"optionalAccess\", _190 => _190.type]) ? (path = update.node.get(key), void 0 !== path && (state[key] = lsonToJson(path))) : \"delete\" === _optionalChain([update, \"access\", _191 => _191.updates, \"access\", _192 => _192[key], \"optionalAccess\", _193 => _193.type]) && delete state[key];\n          }\n          return state;\n      }\n    }\n    if (Array.isArray(state)) {\n      var newArray = [...state];\n      newArray[pathItem] = legacy_patchImmutableNode(state[pathItem], path, update);\n      return newArray;\n    }\n    return isJsonObject(state) ? (newArray = state[pathItem], void 0 === newArray ? state : {...state, [pathItem]:legacy_patchImmutableNode(newArray, path, update)}) : state;\n  }\n  function deprecate(message, key = message) {\n    _emittedDeprecationWarnings.has(key) || (_emittedDeprecationWarnings.add(key), errorWithTitle(\"Deprecation warning\", message));\n  }\n  function throwUsageError(message) {\n    const usageError = Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n  function shallowObj(objA, objB) {\n    if (!isPlainObject(objA) || !isPlainObject(objB)) {\n      return !1;\n    }\n    const keysA = Object.keys(objA);\n    return keysA.length !== Object.keys(objB).length ? !1 : keysA.every(key => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key]));\n  }\n  Object.defineProperty(exports, \"__esModule\", {value:!0});\n  var __defProp = Object.defineProperty, g = \"undefined\" !== typeof globalThis ? globalThis : \"undefined\" !== typeof window ? window : \"undefined\" !== typeof global ? global : {}, fancy_console_exports = {};\n  ((target, all) => {\n    for (var name in all) {\n      __defProp(target, name, {get:all[name], enumerable:!0});\n    }\n  })(fancy_console_exports, {error:() => error2, errorWithTitle:() => errorWithTitle, warn:() => warn, warnWithTitle:() => warnWithTitle});\n  var warn = wrap(\"warn\"), error2 = wrap(\"error\"), warnWithTitle = wrapWithTitle(\"warn\"), errorWithTitle = wrapWithTitle(\"error\"), SafeContext = class {\n    constructor(initialContext) {\n      this.curr = initialContext;\n    }\n    get current() {\n      return this.curr;\n    }\n    allowPatching(callback) {\n      const self = this;\n      let allowed = !0;\n      callback({...this.curr, patch(patch) {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            \"patch\" !== key && (this[key] = value);\n          }\n        } else {\n          throw Error(\"Can no longer patch stale context\");\n        }\n      }});\n      allowed = !1;\n    }\n  }, nextId = 1, FSM = class {\n    get initialState() {\n      const result = this.states.values()[Symbol.iterator]().next();\n      if (result.done) {\n        throw Error(\"No states defined yet\");\n      }\n      return result.value;\n    }\n    get currentState() {\n      if (null === this.currentStateOrNull) {\n        if (0 === this.runningState) {\n          throw Error(\"Not started yet\");\n        }\n        throw Error(\"Already stopped\");\n      }\n      return this.currentStateOrNull;\n    }\n    start() {\n      if (0 !== this.runningState) {\n        throw Error(\"State machine has already started\");\n      }\n      this.runningState = 1;\n      this.currentStateOrNull = this.initialState;\n      this.enter(null);\n      return this;\n    }\n    stop() {\n      if (1 !== this.runningState) {\n        throw Error(\"Cannot stop a state machine that hasn't started yet\");\n      }\n      this.exit(null);\n      this.runningState = 2;\n      this.currentStateOrNull = null;\n    }\n    constructor(initialContext) {\n      this.id = nextId++;\n      this.runningState = 0;\n      this.currentStateOrNull = null;\n      this.states = new Set();\n      this.enterFns = new Map();\n      this.cleanupStack = [];\n      this.knownEventTypes = new Set();\n      this.allowedTransitions = new Map();\n      this.currentContext = new SafeContext(initialContext);\n      this.eventHub = {didReceiveEvent:makeEventSource(), willTransition:makeEventSource(), didIgnoreEvent:makeEventSource(), willExitState:makeEventSource(), didEnterState:makeEventSource()};\n      this.events = {didReceiveEvent:this.eventHub.didReceiveEvent.observable, willTransition:this.eventHub.willTransition.observable, didIgnoreEvent:this.eventHub.didIgnoreEvent.observable, willExitState:this.eventHub.willExitState.observable, didEnterState:this.eventHub.didEnterState.observable};\n    }\n    get context() {\n      return this.currentContext.current;\n    }\n    addState(state) {\n      if (0 !== this.runningState) {\n        throw Error(\"Already started\");\n      }\n      this.states.add(state);\n      return this;\n    }\n    onEnter(nameOrPattern, enterFn) {\n      if (0 !== this.runningState) {\n        throw Error(\"Already started\");\n      }\n      if (this.enterFns.has(nameOrPattern)) {\n        throw Error(`enter/exit function for ${nameOrPattern} already exists`);\n      }\n      this.enterFns.set(nameOrPattern, enterFn);\n      return this;\n    }\n    onEnterAsync(nameOrPattern, promiseFn, onOK, onError, maxTimeout) {\n      return this.onEnter(nameOrPattern, () => {\n        const abortController = new AbortController(), signal = abortController.signal, timeoutId = maxTimeout ? setTimeout(() => {\n          this.transition({type:\"ASYNC_ERROR\", reason:Error(\"Timed out\")}, onError);\n        }, maxTimeout) : void 0;\n        let done = !1;\n        promiseFn(this.currentContext.current, signal).then(data => {\n          signal.aborted || (done = !0, this.transition({type:\"ASYNC_OK\", data}, onOK));\n        }, reason => {\n          signal.aborted || (done = !0, this.transition({type:\"ASYNC_ERROR\", reason}, onError));\n        });\n        return () => {\n          clearTimeout(timeoutId);\n          done || abortController.abort();\n        };\n      });\n    }\n    getStatesMatching(nameOrPattern) {\n      const matches = [];\n      if (\"*\" === nameOrPattern) {\n        for (var state$jscomp$0 of this.states) {\n          matches.push(state$jscomp$0);\n        }\n      } else if (nameOrPattern.endsWith(\".*\")) {\n        state$jscomp$0 = nameOrPattern.slice(0, -1);\n        for (const state of this.states) {\n          state.startsWith(state$jscomp$0) && matches.push(state);\n        }\n      } else {\n        this.states.has(nameOrPattern) && matches.push(nameOrPattern);\n      }\n      if (0 === matches.length) {\n        throw Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n      }\n      return matches;\n    }\n    addTransitions(nameOrPattern, mapping) {\n      if (0 !== this.runningState) {\n        throw Error(\"Already started\");\n      }\n      for (const srcState of this.getStatesMatching(nameOrPattern)) {\n        let map = this.allowedTransitions.get(srcState);\n        void 0 === map && (map = new Map(), this.allowedTransitions.set(srcState, map));\n        for (const [type, target_] of Object.entries(mapping)) {\n          if (map.has(type)) {\n            throw Error(`Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`);\n          }\n          const target = target_;\n          this.knownEventTypes.add(type);\n          void 0 !== target && map.set(type, \"function\" === typeof target ? target : () => target);\n        }\n      }\n      return this;\n    }\n    addTimedTransition(stateOrPattern, after2, target) {\n      return this.onEnter(stateOrPattern, () => {\n        const ms = \"function\" === typeof after2 ? after2(this.currentContext.current) : after2, timeoutID = setTimeout(() => {\n          this.transition({type:\"TIMER\"}, target);\n        }, ms);\n        return () => {\n          clearTimeout(timeoutID);\n        };\n      });\n    }\n    getTargetFn(eventName) {\n      return _optionalChain([this, \"access\", _3 => _3.allowedTransitions, \"access\", _4 => _4.get, \"call\", _5 => _5(this.currentState), \"optionalAccess\", _6 => _6.get, \"call\", _7 => _7(eventName)]);\n    }\n    exit(levels) {\n      this.eventHub.willExitState.notify(this.currentState);\n      this.currentContext.allowPatching(patchableContext => {\n        levels = _nullishCoalesce(levels, () => this.cleanupStack.length);\n        for (let i = 0; i < levels; i++) {\n          _optionalChain([this, \"access\", _8 => _8.cleanupStack, \"access\", _9 => _9.pop, \"call\", _10 => _10(), \"optionalCall\", _11 => _11(patchableContext)]);\n        }\n      });\n    }\n    enter(levels) {\n      const enterPatterns = patterns(this.currentState, _nullishCoalesce(levels, () => this.currentState.split(\".\").length + 1));\n      this.currentContext.allowPatching(patchableContext => {\n        for (const pattern of enterPatterns) {\n          var enterFn = this.enterFns.get(pattern);\n          enterFn = _optionalChain([enterFn, \"optionalCall\", _12 => _12(patchableContext)]);\n          \"function\" === typeof enterFn ? this.cleanupStack.push(enterFn) : this.cleanupStack.push(null);\n        }\n      });\n      this.eventHub.didEnterState.notify(this.currentState);\n    }\n    send(event) {\n      if (!this.knownEventTypes.has(event.type)) {\n        throw Error(`Invalid event ${JSON.stringify(event.type)}`);\n      }\n      if (2 !== this.runningState) {\n        var targetFn = this.getTargetFn(event.type);\n        if (void 0 !== targetFn) {\n          return this.transition(event, targetFn);\n        }\n        this.eventHub.didIgnoreEvent.notify(event);\n      }\n    }\n    transition(event, target) {\n      this.eventHub.didReceiveEvent.notify(event);\n      const oldState = this.currentState, nextTarget = (\"function\" === typeof target ? target : () => target)(event, this.currentContext.current);\n      let nextState, effects = void 0;\n      if (null === nextTarget) {\n        this.eventHub.didIgnoreEvent.notify(event);\n      } else {\n        \"string\" === typeof nextTarget ? nextState = nextTarget : (nextState = nextTarget.target, effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect]);\n        if (!this.states.has(nextState)) {\n          throw Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n        }\n        this.eventHub.willTransition.notify({from:oldState, to:nextState});\n        var [up, down] = distance(this.currentState, nextState);\n        0 < up && this.exit(up);\n        this.currentStateOrNull = nextState;\n        if (void 0 !== effects) {\n          const effectsToRun = effects;\n          this.currentContext.allowPatching(patchableContext => {\n            for (const effect of effectsToRun) {\n              \"function\" === typeof effect ? effect(patchableContext, event) : patchableContext.patch(effect);\n            }\n          });\n        }\n        0 < down && this.enter(down);\n      }\n    }\n  }, ServerMsgCode = (ServerMsgCode2 => {\n    ServerMsgCode2[ServerMsgCode2.UPDATE_PRESENCE = 100] = \"UPDATE_PRESENCE\";\n    ServerMsgCode2[ServerMsgCode2.USER_JOINED = 101] = \"USER_JOINED\";\n    ServerMsgCode2[ServerMsgCode2.USER_LEFT = 102] = \"USER_LEFT\";\n    ServerMsgCode2[ServerMsgCode2.BROADCASTED_EVENT = 103] = \"BROADCASTED_EVENT\";\n    ServerMsgCode2[ServerMsgCode2.ROOM_STATE = 104] = \"ROOM_STATE\";\n    ServerMsgCode2[ServerMsgCode2.INITIAL_STORAGE_STATE = 200] = \"INITIAL_STORAGE_STATE\";\n    ServerMsgCode2[ServerMsgCode2.UPDATE_STORAGE = 201] = \"UPDATE_STORAGE\";\n    ServerMsgCode2[ServerMsgCode2.REJECT_STORAGE_OP = 299] = \"REJECT_STORAGE_OP\";\n    ServerMsgCode2[ServerMsgCode2.UPDATE_YDOC = 300] = \"UPDATE_YDOC\";\n    ServerMsgCode2[ServerMsgCode2.THREAD_CREATED = 400] = \"THREAD_CREATED\";\n    ServerMsgCode2[ServerMsgCode2.THREAD_DELETED = 407] = \"THREAD_DELETED\";\n    ServerMsgCode2[ServerMsgCode2.THREAD_METADATA_UPDATED = 401] = \"THREAD_METADATA_UPDATED\";\n    ServerMsgCode2[ServerMsgCode2.THREAD_UPDATED = 408] = \"THREAD_UPDATED\";\n    ServerMsgCode2[ServerMsgCode2.COMMENT_CREATED = 402] = \"COMMENT_CREATED\";\n    ServerMsgCode2[ServerMsgCode2.COMMENT_EDITED = 403] = \"COMMENT_EDITED\";\n    ServerMsgCode2[ServerMsgCode2.COMMENT_DELETED = 404] = \"COMMENT_DELETED\";\n    ServerMsgCode2[ServerMsgCode2.COMMENT_REACTION_ADDED = 405] = \"COMMENT_REACTION_ADDED\";\n    ServerMsgCode2[ServerMsgCode2.COMMENT_REACTION_REMOVED = 406] = \"COMMENT_REACTION_REMOVED\";\n    return ServerMsgCode2;\n  })(ServerMsgCode || {}), WebsocketCloseCodes = (WebsocketCloseCodes2 => {\n    WebsocketCloseCodes2[WebsocketCloseCodes2.CLOSE_NORMAL = 1e3] = \"CLOSE_NORMAL\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2.CLOSE_ABNORMAL = 1006] = \"CLOSE_ABNORMAL\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2.UNEXPECTED_CONDITION = 1011] = \"UNEXPECTED_CONDITION\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2.TRY_AGAIN_LATER = 1013] = \"TRY_AGAIN_LATER\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2.INVALID_MESSAGE_FORMAT = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2.NOT_ALLOWED = 4001] = \"NOT_ALLOWED\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2.MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2.MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2.MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2.ROOM_ID_UPDATED = 4006] = \"ROOM_ID_UPDATED\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2.KICKED = 4100] = \"KICKED\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2.TOKEN_EXPIRED = 4109] = \"TOKEN_EXPIRED\";\n    WebsocketCloseCodes2[WebsocketCloseCodes2.CLOSE_WITHOUT_RETRY = 4999] = \"CLOSE_WITHOUT_RETRY\";\n    return WebsocketCloseCodes2;\n  })(WebsocketCloseCodes || {}), BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4], RESET_DELAY = BACKOFF_DELAYS[0] - 1, BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5], StopRetrying = class extends Error {\n    constructor(reason) {\n      super(reason);\n    }\n  }, LiveblocksError = class extends Error {\n    constructor(message, code) {\n      super(message);\n      this.code = code;\n    }\n  }, logPermanentClose = log(1, \"Connection to WebSocket closed permanently. Won't retry.\"), assign = patch => ctx => ctx.patch(patch), ManagedSocket = class {\n    constructor(delegates, enableDebugLogging = !1, waitForActorId = !0) {\n      const {machine, events, cleanups} = createConnectionStateMachine(delegates, {waitForActorId, enableDebugLogging});\n      this.machine = machine;\n      this.events = events;\n      this.cleanups = cleanups;\n    }\n    getStatus() {\n      try {\n        return toNewConnectionStatus(this.machine);\n      } catch (e2) {\n        return \"initial\";\n      }\n    }\n    get authValue() {\n      return this.machine.context.authValue;\n    }\n    connect() {\n      this.machine.send({type:\"CONNECT\"});\n    }\n    reconnect() {\n      this.machine.send({type:\"RECONNECT\"});\n    }\n    disconnect() {\n      this.machine.send({type:\"DISCONNECT\"});\n    }\n    destroy() {\n      this.machine.stop();\n      let cleanup;\n      for (; cleanup = this.cleanups.pop();) {\n        cleanup();\n      }\n    }\n    send(data) {\n      const socket = _optionalChain([this, \"access\", _33 => _33.machine, \"access\", _34 => _34.context, \"optionalAccess\", _35 => _35.socket]);\n      null === socket ? warn(\"Cannot send: not connected yet\", data) : 1 !== socket.readyState ? warn(\"Cannot send: WebSocket no longer open\", data) : socket.send(data);\n    }\n    _privateSendMachineEvent(event) {\n      this.machine.send(event);\n    }\n  }, kInternal = Symbol(), _bridgeActive = !1, eventSource = makeEventSource();\n  \"undefined\" !== typeof window && window.addEventListener(\"message\", event => {\n    event.source === window && \"liveblocks-devtools-panel\" === _optionalChain([event, \"access\", _39 => _39.data, \"optionalAccess\", _40 => _40.source]) && eventSource.notify(event.data);\n  });\n  var onMessageFromPanel = eventSource.observable, _devtoolsSetupHasRun = !1, unsubsByRoomId = new Map(), loadedAt = Date.now(), eventCounter = 0, roomChannelListeners = new Map(), BatchCall = class {\n    constructor(input) {\n      this.input = input;\n      const {promise, resolve, reject} = Promise_withResolvers();\n      this.promise = promise;\n      this.resolve = resolve;\n      this.reject = reject;\n    }\n  }, Batch = class {\n    constructor(callback, options) {\n      this.queue = [];\n      this.error = !1;\n      this.callback = callback;\n      this.size = _nullishCoalesce(options.size, () => 50);\n      this.delay = options.delay;\n    }\n    clearDelayTimeout() {\n      void 0 !== this.delayTimeoutId && (clearTimeout(this.delayTimeoutId), this.delayTimeoutId = void 0);\n    }\n    schedule() {\n      this.queue.length === this.size ? this.flush() : 1 === this.queue.length && (this.clearDelayTimeout(), this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay));\n    }\n    async flush() {\n      if (0 !== this.queue.length) {\n        var calls = this.queue.splice(0), inputs = calls.map(call => call.input);\n        try {\n          const results = await this.callback(inputs);\n          this.error = !1;\n          calls.forEach((call, index) => {\n            const result = _optionalChain([results, \"optionalAccess\", _44 => _44[index]]);\n            Array.isArray(results) ? calls.length !== results.length ? call.reject(Error(`Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`)) : result instanceof Error ? call.reject(result) : call.resolve(result) : call.reject(Error(\"Callback must return an array.\"));\n          });\n        } catch (error3) {\n          this.error = !0, calls.forEach(call => {\n            call.reject(error3);\n          });\n        }\n      }\n    }\n    get(input) {\n      var existingCall = this.queue.find(call2 => stringify(call2.input) === stringify(input));\n      if (existingCall) {\n        return existingCall.promise;\n      }\n      existingCall = new BatchCall(input);\n      this.queue.push(existingCall);\n      this.schedule();\n      return existingCall.promise;\n    }\n    clear() {\n      this.queue = [];\n      this.error = !1;\n      this.clearDelayTimeout();\n    }\n  }, HttpError = class extends Error {\n    constructor(message, status, details) {\n      super(message);\n      this.message = message;\n      this.status = status;\n      this.details = details;\n    }\n  }, DONT_RETRY_4XX = x => x instanceof HttpError && 400 <= x.status && 500 > x.status, HttpClient = class {\n    constructor(baseUrl, fetchPolyfill, authCallback) {\n      this._baseUrl = baseUrl;\n      this._fetchPolyfill = fetchPolyfill;\n      this._authCallback = authCallback;\n    }\n    async rawFetch(endpoint, options, params) {\n      endpoint.startsWith(\"/v2/c/\") || raise(\"This client can only be used to make /v2/c/* requests\");\n      endpoint = urljoin(this._baseUrl, endpoint, params);\n      return await this._fetchPolyfill(endpoint, {...options, headers:{\"Content-Type\":\"application/json; charset\\x3dutf-8\", ..._optionalChain([options, \"optionalAccess\", _45 => _45.headers]), Authorization:`Bearer ${getBearerTokenFromAuthValue(await this._authCallback())}`, \"X-LB-Client\":\"2.10.2\"}});\n    }\n    async fetch(endpoint, options, params) {\n      endpoint = await this.rawFetch(endpoint, options, params);\n      if (!endpoint.ok) {\n        let error3;\n        try {\n          const errorBody = await endpoint.json();\n          error3 = new HttpError(errorBody.message, endpoint.status, errorBody);\n        } catch (e3) {\n          error3 = new HttpError(endpoint.statusText, endpoint.status);\n        }\n        throw error3;\n      }\n      let body;\n      try {\n        body = await endpoint.json();\n      } catch (e4) {\n        body = {};\n      }\n      return body;\n    }\n    async rawGet(endpoint, params, options) {\n      return await this.rawFetch(endpoint, options, params);\n    }\n    async rawPost(endpoint, body) {\n      return await this.rawFetch(endpoint, {method:\"POST\", body:JSON.stringify(body)});\n    }\n    async rawDelete(endpoint) {\n      return await this.rawFetch(endpoint, {method:\"DELETE\"});\n    }\n    async get(endpoint, params, options) {\n      return await this.fetch(endpoint, options, params);\n    }\n    async post(endpoint, body, options, params) {\n      return await this.fetch(endpoint, {...options, method:\"POST\", body:JSON.stringify(body)}, params);\n    }\n    async delete(endpoint) {\n      return await this.fetch(endpoint, {method:\"DELETE\"});\n    }\n    async putBlob(endpoint, blob, params, options) {\n      return await this.fetch(endpoint, {...options, method:\"PUT\", headers:{\"Content-Type\":\"application/octet-stream\"}, body:blob}, params);\n    }\n  }, ZERO = nthDigit(0), ONE = nthDigit(1), ZERO_NINE = ZERO + nthDigit(-1), OpCode = (OpCode2 => {\n    OpCode2[OpCode2.INIT = 0] = \"INIT\";\n    OpCode2[OpCode2.SET_PARENT_KEY = 1] = \"SET_PARENT_KEY\";\n    OpCode2[OpCode2.CREATE_LIST = 2] = \"CREATE_LIST\";\n    OpCode2[OpCode2.UPDATE_OBJECT = 3] = \"UPDATE_OBJECT\";\n    OpCode2[OpCode2.CREATE_OBJECT = 4] = \"CREATE_OBJECT\";\n    OpCode2[OpCode2.DELETE_CRDT = 5] = \"DELETE_CRDT\";\n    OpCode2[OpCode2.DELETE_OBJECT_KEY = 6] = \"DELETE_OBJECT_KEY\";\n    OpCode2[OpCode2.CREATE_MAP = 7] = \"CREATE_MAP\";\n    OpCode2[OpCode2.CREATE_REGISTER = 8] = \"CREATE_REGISTER\";\n    return OpCode2;\n  })(OpCode || {}), NoParent = Object.freeze({type:\"NoParent\"}), AbstractCrdt = class {\n    constructor() {\n      this._parent = NoParent;\n    }\n    _getParentKeyOrThrow() {\n      switch(this.parent.type) {\n        case \"HasParent\":\n          return this.parent.key;\n        case \"NoParent\":\n          throw Error(\"Parent key is missing\");\n        case \"Orphaned\":\n          return this.parent.oldKey;\n        default:\n          return assertNever(this.parent, \"Unknown state\");\n      }\n    }\n    get _parentPos() {\n      switch(this.parent.type) {\n        case \"HasParent\":\n          return this.parent.pos;\n        case \"NoParent\":\n          throw Error(\"Parent key is missing\");\n        case \"Orphaned\":\n          return this.parent.oldPos;\n        default:\n          return assertNever(this.parent, \"Unknown state\");\n      }\n    }\n    get _pool() {\n      return this.__pool;\n    }\n    get roomId() {\n      return this.__pool ? this.__pool.roomId : null;\n    }\n    get _id() {\n      return this.__id;\n    }\n    get parent() {\n      return this._parent;\n    }\n    get _parentKey() {\n      switch(this.parent.type) {\n        case \"HasParent\":\n          return this.parent.key;\n        case \"NoParent\":\n          return null;\n        case \"Orphaned\":\n          return this.parent.oldKey;\n        default:\n          return assertNever(this.parent, \"Unknown state\");\n      }\n    }\n    _apply(op, _isLocal) {\n      switch(op.type) {\n        case 5:\n          if (\"HasParent\" === this.parent.type) {\n            return this.parent.node._detachChild(this);\n          }\n      }\n      return {modified:!1};\n    }\n    _setParentLink(newParentNode, newParentKey) {\n      switch(this.parent.type) {\n        case \"HasParent\":\n          if (this.parent.node !== newParentNode) {\n            throw Error(\"Cannot set parent: node already has a parent\");\n          }\n          this._parent = HasParent(newParentNode, newParentKey);\n          break;\n        case \"Orphaned\":\n        case \"NoParent\":\n          this._parent = HasParent(newParentNode, newParentKey);\n          break;\n        default:\n          return assertNever(this.parent, \"Unknown state\");\n      }\n    }\n    _attach(id, pool) {\n      if (this.__id || this.__pool) {\n        throw Error(\"Cannot attach node: already attached\");\n      }\n      pool.addNode(id, this);\n      this.__id = id;\n      this.__pool = pool;\n    }\n    _detach() {\n      this.__pool && this.__id && this.__pool.deleteNode(this.__id);\n      switch(this.parent.type) {\n        case \"HasParent\":\n          this._parent = Orphaned(this.parent.key, this.parent.pos);\n          break;\n        case \"NoParent\":\n          this._parent = NoParent;\n          break;\n        case \"Orphaned\":\n          break;\n        default:\n          assertNever(this.parent, \"Unknown state\");\n      }\n      this.__pool = void 0;\n    }\n    invalidate() {\n      if (void 0 !== this._cachedImmutable || void 0 !== this._cachedTreeNode) {\n        this._cachedTreeNode = this._cachedImmutable = void 0, \"HasParent\" === this.parent.type && this.parent.node.invalidate();\n      }\n    }\n    toTreeNode(key) {\n      if (void 0 === this._cachedTreeNode || this._cachedTreeNodeKey !== key) {\n        this._cachedTreeNodeKey = key, this._cachedTreeNode = this._toTreeNode(key);\n      }\n      return this._cachedTreeNode;\n    }\n    toImmutable() {\n      void 0 === this._cachedImmutable && (this._cachedImmutable = this._toImmutable());\n      return this._cachedImmutable;\n    }\n  }, CrdtType = (CrdtType2 => {\n    CrdtType2[CrdtType2.OBJECT = 0] = \"OBJECT\";\n    CrdtType2[CrdtType2.LIST = 1] = \"LIST\";\n    CrdtType2[CrdtType2.MAP = 2] = \"MAP\";\n    CrdtType2[CrdtType2.REGISTER = 3] = \"REGISTER\";\n    return CrdtType2;\n  })(CrdtType || {}), nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce((t2, e) => t2 + (36 > (e &= 63) ? e.toString(36) : 62 > e ? (e - 26).toString(36).toUpperCase() : 63 > e ? \"_\" : \"-\"), \"\");\n  const node_modules$$liveblocks$core$dist$index$classdecl$var0 = class extends AbstractCrdt {\n    constructor(data) {\n      super();\n      this._data = data;\n    }\n    get data() {\n      return this._data;\n    }\n    static _deserialize([id, item], _parentToChildren, pool) {\n      item = new node_modules$$liveblocks$core$dist$index$classdecl$var0(item.data);\n      item._attach(id, pool);\n      return item;\n    }\n    _toOps(parentId, parentKey, pool) {\n      if (void 0 === this._id) {\n        throw Error(\"Cannot serialize register if parentId or parentKey is undefined\");\n      }\n      return [{type:8, opId:_optionalChain([pool, \"optionalAccess\", _49 => _49.generateOpId, \"call\", _50 => _50()]), id:this._id, parentId, parentKey, data:this.data}];\n    }\n    _serialize() {\n      if (\"HasParent\" !== this.parent.type) {\n        throw Error(\"Cannot serialize LiveRegister if parent is missing\");\n      }\n      return {type:3, parentId:nn(this.parent.node._id, \"Parent node expected to have ID\"), parentKey:this.parent.key, data:this.data};\n    }\n    _attachChild(_op) {\n      throw Error(\"Method not implemented.\");\n    }\n    _detachChild(_crdt) {\n      throw Error(\"Method not implemented.\");\n    }\n    _apply(op, isLocal) {\n      return super._apply(op, isLocal);\n    }\n    _toTreeNode(key) {\n      return {type:\"Json\", id:_nullishCoalesce(this._id, () => nanoid()), key, payload:this._data};\n    }\n    _toImmutable() {\n      return this._data;\n    }\n    clone() {\n      return deepClone(this.data);\n    }\n  };\n  var LiveRegister = node_modules$$liveblocks$core$dist$index$classdecl$var0;\n  const node_modules$$liveblocks$core$dist$index$classdecl$var1 = class extends AbstractCrdt {\n    constructor(items) {\n      super();\n      this._items = [];\n      this._implicitlyDeletedItems = new WeakSet();\n      this._unacknowledgedSets = new Map();\n      var position = void 0;\n      for (const item of items) {\n        items = makePosition(position), position = lsonToLiveNode(item), position._setParentLink(this, items), this._items.push(position), position = items;\n      }\n    }\n    static _deserialize([id], parentToChildren, pool) {\n      const list = new node_modules$$liveblocks$core$dist$index$classdecl$var1([]);\n      list._attach(id, pool);\n      id = parentToChildren.get(id);\n      if (void 0 === id) {\n        return list;\n      }\n      for (const [id2, crdt] of id) {\n        id = deserialize([id2, crdt], parentToChildren, pool), id._setParentLink(list, crdt.parentKey), list._insertAndSort(id);\n      }\n      return list;\n    }\n    _toOps(parentId, parentKey, pool) {\n      if (void 0 === this._id) {\n        throw Error(\"Cannot serialize item is not attached\");\n      }\n      const ops = [];\n      parentId = {id:this._id, opId:_optionalChain([pool, \"optionalAccess\", _51 => _51.generateOpId, \"call\", _52 => _52()]), type:2, parentId, parentKey};\n      ops.push(parentId);\n      for (const item of this._items) {\n        parentId = item._getParentKeyOrThrow();\n        parentKey = HACK_addIntentAndDeletedIdToOperation(item._toOps(this._id, parentId, pool), void 0);\n        const childOpId = parentKey[0].opId;\n        void 0 !== childOpId && this._unacknowledgedSets.set(parentId, childOpId);\n        ops.push(...parentKey);\n      }\n      return ops;\n    }\n    _insertAndSort(item) {\n      this._items.push(item);\n      this._sortItems();\n    }\n    _sortItems() {\n      this._items.sort(compareNodePosition);\n      this.invalidate();\n    }\n    _indexOfPosition(position) {\n      return this._items.findIndex(item => item._getParentKeyOrThrow() === position);\n    }\n    _attach(id, pool) {\n      super._attach(id, pool);\n      for (const item of this._items) {\n        item._attach(pool.generateId(), pool);\n      }\n    }\n    _detach() {\n      super._detach();\n      for (const item of this._items) {\n        item._detach();\n      }\n    }\n    _applySetRemote(op) {\n      if (void 0 === this._pool) {\n        throw Error(\"Can't attach child if managed pool is not present\");\n      }\n      const {id, parentKey:key} = op;\n      var child = lsonToLiveNode(creationOpToLson(op));\n      child._attach(id, this._pool);\n      child._setParentLink(this, key);\n      var deletedId = op.deletedId;\n      const indexOfItemWithSamePosition = this._indexOfPosition(key);\n      if (-1 !== indexOfItemWithSamePosition) {\n        const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n        if (itemWithSamePosition._id === deletedId) {\n          return itemWithSamePosition._detach(), this._items[indexOfItemWithSamePosition] = child, {modified:makeUpdate(this, [setDelta(indexOfItemWithSamePosition, child)]), reverse:[]};\n        }\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        child = [setDelta(indexOfItemWithSamePosition, child)];\n        (op = this._detachItemAssociatedToSetOperation(op.deletedId)) && child.push(op);\n        return {modified:makeUpdate(this, child), reverse:[]};\n      }\n      deletedId = [];\n      (op = this._detachItemAssociatedToSetOperation(op.deletedId)) && deletedId.push(op);\n      this._insertAndSort(child);\n      deletedId.push(insertDelta(this._indexOfPosition(key), child));\n      return {reverse:[], modified:makeUpdate(this, deletedId)};\n    }\n    _applySetAck(op) {\n      if (void 0 === this._pool) {\n        throw Error(\"Can't attach child if managed pool is not present\");\n      }\n      const delta = [];\n      var deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n      deletedDelta && delta.push(deletedDelta);\n      deletedDelta = this._unacknowledgedSets.get(op.parentKey);\n      if (void 0 !== deletedDelta) {\n        if (deletedDelta !== op.opId) {\n          return 0 === delta.length ? {modified:!1} : {modified:makeUpdate(this, delta), reverse:[]};\n        }\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n      deletedDelta = this._indexOfPosition(op.parentKey);\n      var existingItem = this._items.find(item => item._id === op.id);\n      if (void 0 !== existingItem) {\n        if (existingItem._parentKey === op.parentKey) {\n          return {modified:0 < delta.length ? makeUpdate(this, delta) : !1, reverse:[]};\n        }\n        if (-1 !== deletedDelta) {\n          this._implicitlyDeletedItems.add(this._items[deletedDelta]);\n          var [prevNode] = this._items.splice(deletedDelta, 1);\n          delta.push(deleteDelta(deletedDelta, prevNode));\n        }\n        deletedDelta = this._items.indexOf(existingItem);\n        existingItem._setParentLink(this, op.parentKey);\n        this._sortItems();\n        prevNode = this._items.indexOf(existingItem);\n        prevNode !== deletedDelta && delta.push(moveDelta(deletedDelta, prevNode, existingItem));\n        return {modified:0 < delta.length ? makeUpdate(this, delta) : !1, reverse:[]};\n      }\n      if ((existingItem = this._pool.getNode(op.id)) && this._implicitlyDeletedItems.has(existingItem)) {\n        return existingItem._setParentLink(this, op.parentKey), this._implicitlyDeletedItems.delete(existingItem), this._insertAndSort(existingItem), prevNode = this._items.indexOf(existingItem), {modified:makeUpdate(this, [-1 === deletedDelta ? insertDelta(prevNode, existingItem) : setDelta(prevNode, existingItem), ...delta]), reverse:[]};\n      }\n      -1 !== deletedDelta && this._items.splice(deletedDelta, 1);\n      const {newItem, newIndex} = this._createAttachItemAndSort(op, op.parentKey);\n      return {modified:makeUpdate(this, [-1 === deletedDelta ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem), ...delta]), reverse:[]};\n    }\n    _detachItemAssociatedToSetOperation(deletedId) {\n      if (void 0 === deletedId || void 0 === this._pool) {\n        return null;\n      }\n      deletedId = this._pool.getNode(deletedId);\n      if (void 0 === deletedId) {\n        return null;\n      }\n      deletedId = this._detachChild(deletedId);\n      return !1 === deletedId.modified ? null : deletedId.modified.updates[0];\n    }\n    _applyRemoteInsert(op) {\n      if (void 0 === this._pool) {\n        throw Error(\"Can't attach child if managed pool is not present\");\n      }\n      const key = asPos(op.parentKey), existingItemIndex = this._indexOfPosition(key);\n      -1 !== existingItemIndex && this._shiftItemPosition(existingItemIndex, key);\n      const {newItem, newIndex} = this._createAttachItemAndSort(op, key);\n      return {modified:makeUpdate(this, [insertDelta(newIndex, newItem)]), reverse:[]};\n    }\n    _applyInsertAck(op) {\n      var existingItem = this._items.find(item => item._id === op.id), key = asPos(op.parentKey);\n      const itemIndexAtPosition = this._indexOfPosition(key);\n      if (existingItem) {\n        if (existingItem._parentKey === key) {\n          return {modified:!1};\n        }\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        -1 !== itemIndexAtPosition && this._shiftItemPosition(itemIndexAtPosition, key);\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        key = this._indexOfPosition(key);\n        return key === oldPositionIndex ? {modified:!1} : {modified:makeUpdate(this, [moveDelta(oldPositionIndex, key, existingItem)]), reverse:[]};\n      }\n      if ((existingItem = nn(this._pool).getNode(op.id)) && this._implicitlyDeletedItems.has(existingItem)) {\n        return existingItem._setParentLink(this, key), this._implicitlyDeletedItems.delete(existingItem), this._insertAndSort(existingItem), key = this._indexOfPosition(key), {modified:makeUpdate(this, [insertDelta(key, existingItem)]), reverse:[]};\n      }\n      -1 !== itemIndexAtPosition && this._shiftItemPosition(itemIndexAtPosition, key);\n      const {newItem, newIndex} = this._createAttachItemAndSort(op, key);\n      return {modified:makeUpdate(this, [insertDelta(newIndex, newItem)]), reverse:[]};\n    }\n    _applyInsertUndoRedo(op) {\n      const {id, parentKey:key} = op;\n      op = lsonToLiveNode(creationOpToLson(op));\n      if (void 0 !== _optionalChain([this, \"access\", _53 => _53._pool, \"optionalAccess\", _54 => _54.getNode, \"call\", _55 => _55(id)])) {\n        return {modified:!1};\n      }\n      op._attach(id, nn(this._pool));\n      op._setParentLink(this, key);\n      const existingItemIndex = this._indexOfPosition(key);\n      var newKey = key;\n      if (-1 !== existingItemIndex) {\n        newKey = _optionalChain([this, \"access\", _56 => _56._items, \"access\", _57 => _57[existingItemIndex], \"optionalAccess\", _58 => _58._parentPos]);\n        const after2 = _optionalChain([this, \"access\", _59 => _59._items, \"access\", _60 => _60[existingItemIndex + 1], \"optionalAccess\", _61 => _61._parentPos]);\n        newKey = makePosition(newKey, after2);\n        op._setParentLink(this, newKey);\n      }\n      this._insertAndSort(op);\n      newKey = this._indexOfPosition(newKey);\n      return {modified:makeUpdate(this, [insertDelta(newKey, op)]), reverse:[{type:5, id}]};\n    }\n    _applySetUndoRedo(op) {\n      const {id, parentKey:key} = op;\n      var child = lsonToLiveNode(creationOpToLson(op));\n      if (void 0 !== _optionalChain([this, \"access\", _62 => _62._pool, \"optionalAccess\", _63 => _63.getNode, \"call\", _64 => _64(id)])) {\n        return {modified:!1};\n      }\n      this._unacknowledgedSets.set(key, nn(op.opId));\n      const indexOfItemWithSameKey = this._indexOfPosition(key);\n      child._attach(id, nn(this._pool));\n      child._setParentLink(this, key);\n      if (-1 !== indexOfItemWithSameKey) {\n        var existingItem = this._items[indexOfItemWithSameKey];\n        existingItem._detach();\n        this._items[indexOfItemWithSameKey] = child;\n        existingItem = HACK_addIntentAndDeletedIdToOperation(existingItem._toOps(nn(this._id), key, this._pool), op.id);\n        child = [setDelta(indexOfItemWithSameKey, child)];\n        (op = this._detachItemAssociatedToSetOperation(op.deletedId)) && child.push(op);\n        return {modified:makeUpdate(this, child), reverse:existingItem};\n      }\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      op = this._indexOfPosition(key);\n      return {reverse:[{type:5, id}], modified:makeUpdate(this, [insertDelta(op, child)])};\n    }\n    _attachChild(op, source) {\n      if (void 0 === this._pool) {\n        throw Error(\"Can't attach child if managed pool is not present\");\n      }\n      op = \"set\" === op.intent ? 1 === source ? this._applySetRemote(op) : 2 === source ? this._applySetAck(op) : this._applySetUndoRedo(op) : 1 === source ? this._applyRemoteInsert(op) : 2 === source ? this._applyInsertAck(op) : this._applyInsertUndoRedo(op);\n      !1 !== op.modified && this.invalidate();\n      return op;\n    }\n    _detachChild(child) {\n      if (child) {\n        var parentKey = nn(child._parentKey);\n        parentKey = child._toOps(nn(this._id), parentKey, this._pool);\n        const indexToDelete = this._items.indexOf(child);\n        if (-1 === indexToDelete) {\n          return {modified:!1};\n        }\n        const [previousNode] = this._items.splice(indexToDelete, 1);\n        this.invalidate();\n        child._detach();\n        return {modified:makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]), reverse:parentKey};\n      }\n      return {modified:!1};\n    }\n    _applySetChildKeyRemote(newKey, child) {\n      if (this._implicitlyDeletedItems.has(child)) {\n        return this._implicitlyDeletedItems.delete(child), child._setParentLink(this, newKey), this._insertAndSort(child), newKey = this._items.indexOf(child), {modified:makeUpdate(this, [insertDelta(newKey, child)]), reverse:[]};\n      }\n      if (newKey === child._parentKey) {\n        return {modified:!1};\n      }\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (-1 === existingItemIndex) {\n        var previousIndex = this._items.indexOf(child);\n        child._setParentLink(this, newKey);\n        this._sortItems();\n        newKey = this._items.indexOf(child);\n        return newKey === previousIndex ? {modified:!1} : {modified:makeUpdate(this, [moveDelta(previousIndex, newKey, child)]), reverse:[]};\n      }\n      this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, _optionalChain([this, \"access\", _65 => _65._items, \"access\", _66 => _66[existingItemIndex + 1], \"optionalAccess\", _67 => _67._parentPos])));\n      previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      newKey = this._items.indexOf(child);\n      return newKey === previousIndex ? {modified:!1} : {modified:makeUpdate(this, [moveDelta(previousIndex, newKey, child)]), reverse:[]};\n    }\n    _applySetChildKeyAck(newKey, child) {\n      var previousKey = nn(child._parentKey);\n      if (this._implicitlyDeletedItems.has(child)) {\n        const existingItemIndex = this._indexOfPosition(newKey);\n        this._implicitlyDeletedItems.delete(child);\n        -1 !== existingItemIndex && this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, _optionalChain([this, \"access\", _68 => _68._items, \"access\", _69 => _69[existingItemIndex + 1], \"optionalAccess\", _70 => _70._parentPos])));\n        child._setParentLink(this, newKey);\n        this._insertAndSort(child);\n        return {modified:!1};\n      }\n      if (newKey === previousKey) {\n        return {modified:!1};\n      }\n      previousKey = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      -1 !== existingItemIndex && this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, _optionalChain([this, \"access\", _71 => _71._items, \"access\", _72 => _72[existingItemIndex + 1], \"optionalAccess\", _73 => _73._parentPos])));\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      newKey = this._items.indexOf(child);\n      return previousKey === newKey ? {modified:!1} : {modified:makeUpdate(this, [moveDelta(previousKey, newKey, child)]), reverse:[]};\n    }\n    _applySetChildKeyUndoRedo(newKey, child) {\n      const previousKey = nn(child._parentKey), previousIndex = this._items.indexOf(child), existingItemIndex = this._indexOfPosition(newKey);\n      -1 !== existingItemIndex && this._items[existingItemIndex]._setParentLink(this, makePosition(newKey, _optionalChain([this, \"access\", _74 => _74._items, \"access\", _75 => _75[existingItemIndex + 1], \"optionalAccess\", _76 => _76._parentPos])));\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      newKey = this._items.indexOf(child);\n      return previousIndex === newKey ? {modified:!1} : {modified:makeUpdate(this, [moveDelta(previousIndex, newKey, child)]), reverse:[{type:1, id:nn(child._id), parentKey:previousKey}]};\n    }\n    _setChildKey(newKey, child, source) {\n      return 1 === source ? this._applySetChildKeyRemote(newKey, child) : 2 === source ? this._applySetChildKeyAck(newKey, child) : this._applySetChildKeyUndoRedo(newKey, child);\n    }\n    _apply(op, isLocal) {\n      return super._apply(op, isLocal);\n    }\n    _serialize() {\n      if (\"HasParent\" !== this.parent.type) {\n        throw Error(\"Cannot serialize LiveList if parent is missing\");\n      }\n      return {type:1, parentId:nn(this.parent.node._id, \"Parent node expected to have ID\"), parentKey:this.parent.key};\n    }\n    get length() {\n      return this._items.length;\n    }\n    push(element) {\n      _optionalChain([this, \"access\", _77 => _77._pool, \"optionalAccess\", _78 => _78.assertStorageIsWritable, \"call\", _79 => _79()]);\n      return this.insert(element, this.length);\n    }\n    insert(element, index) {\n      _optionalChain([this, \"access\", _80 => _80._pool, \"optionalAccess\", _81 => _81.assertStorageIsWritable, \"call\", _82 => _82()]);\n      if (0 > index || index > this._items.length) {\n        throw Error(`Cannot insert list item at index \"\u001D${index}\". index should be between 0 and ${this._items.length}`);\n      }\n      const position = makePosition(this._items[index - 1] ? this._items[index - 1]._parentPos : void 0, this._items[index] ? this._items[index]._parentPos : void 0);\n      element = lsonToLiveNode(element);\n      element._setParentLink(this, position);\n      this._insertAndSort(element);\n      if (this._pool && this._id) {\n        const id = this._pool.generateId();\n        element._attach(id, this._pool);\n        this._pool.dispatch(element._toOps(this._id, position, this._pool), [{type:5, id}], new Map([[this._id, makeUpdate(this, [insertDelta(index, element)])]]));\n      }\n    }\n    move(index, targetIndex) {\n      _optionalChain([this, \"access\", _83 => _83._pool, \"optionalAccess\", _84 => _84.assertStorageIsWritable, \"call\", _85 => _85()]);\n      if (0 > targetIndex) {\n        throw Error(\"targetIndex cannot be less than 0\");\n      }\n      if (targetIndex >= this._items.length) {\n        throw Error(\"targetIndex cannot be greater or equal than the list length\");\n      }\n      if (0 > index) {\n        throw Error(\"index cannot be less than 0\");\n      }\n      if (index >= this._items.length) {\n        throw Error(\"index cannot be greater or equal than the list length\");\n      }\n      var beforePosition = null, afterPosition = null;\n      index < targetIndex ? (afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos, beforePosition = this._items[targetIndex]._parentPos) : (afterPosition = this._items[targetIndex]._parentPos, beforePosition = 0 === targetIndex ? void 0 : this._items[targetIndex - 1]._parentPos);\n      beforePosition = makePosition(beforePosition, afterPosition);\n      afterPosition = this._items[index];\n      const previousPosition = afterPosition._getParentKeyOrThrow();\n      afterPosition._setParentLink(this, beforePosition);\n      this._sortItems();\n      this._pool && this._id && (index = new Map([[this._id, makeUpdate(this, [moveDelta(index, targetIndex, afterPosition)])]]), this._pool.dispatch([{type:1, id:nn(afterPosition._id), opId:this._pool.generateOpId(), parentKey:beforePosition}], [{type:1, id:nn(afterPosition._id), parentKey:previousPosition}], index));\n    }\n    delete(index) {\n      _optionalChain([this, \"access\", _86 => _86._pool, \"optionalAccess\", _87 => _87.assertStorageIsWritable, \"call\", _88 => _88()]);\n      if (0 > index || index >= this._items.length) {\n        throw Error(`Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`);\n      }\n      const item = this._items[index];\n      item._detach();\n      const [prev] = this._items.splice(index, 1);\n      this.invalidate();\n      if (this._pool) {\n        const childRecordId = item._id;\n        if (childRecordId) {\n          const storageUpdates = new Map();\n          storageUpdates.set(nn(this._id), makeUpdate(this, [deleteDelta(index, prev)]));\n          this._pool.dispatch([{id:childRecordId, opId:this._pool.generateOpId(), type:5}], item._toOps(nn(this._id), item._getParentKeyOrThrow()), storageUpdates);\n        }\n      }\n    }\n    clear() {\n      _optionalChain([this, \"access\", _89 => _89._pool, \"optionalAccess\", _90 => _90.assertStorageIsWritable, \"call\", _91 => _91()]);\n      if (this._pool) {\n        var ops = [];\n        const reverseOps = [], updateDelta = [];\n        for (var item of this._items) {\n          item._detach();\n          const childId = item._id;\n          childId && (ops.push({type:5, id:childId, opId:this._pool.generateOpId()}), reverseOps.push(...item._toOps(nn(this._id), item._getParentKeyOrThrow())), updateDelta.push(deleteDelta(0, item)));\n        }\n        this._items = [];\n        this.invalidate();\n        item = new Map();\n        item.set(nn(this._id), makeUpdate(this, updateDelta));\n        this._pool.dispatch(ops, reverseOps, item);\n      } else {\n        for (ops of this._items) {\n          ops._detach();\n        }\n        this._items = [];\n        this.invalidate();\n      }\n    }\n    set(index, item) {\n      _optionalChain([this, \"access\", _92 => _92._pool, \"optionalAccess\", _93 => _93.assertStorageIsWritable, \"call\", _94 => _94()]);\n      if (0 > index || index >= this._items.length) {\n        throw Error(`Cannot set list item at index \"\u001D${index}\". index should be between 0 and ${this._items.length - 1}`);\n      }\n      var existingItem = this._items[index];\n      const position = existingItem._getParentKeyOrThrow(), existingId = existingItem._id;\n      existingItem._detach();\n      const value = lsonToLiveNode(item);\n      value._setParentLink(this, position);\n      this._items[index] = value;\n      this.invalidate();\n      if (this._pool && this._id) {\n        const id = this._pool.generateId();\n        value._attach(id, this._pool);\n        item = new Map();\n        item.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n        index = HACK_addIntentAndDeletedIdToOperation(value._toOps(this._id, position, this._pool), existingId);\n        this._unacknowledgedSets.set(position, nn(index[0].opId));\n        existingItem = HACK_addIntentAndDeletedIdToOperation(existingItem._toOps(this._id, position, void 0), id);\n        this._pool.dispatch(index, existingItem, item);\n      }\n    }\n    toArray() {\n      return this._items.map(entry => liveNodeToLson(entry));\n    }\n    every(predicate) {\n      return this.toArray().every(predicate);\n    }\n    filter(predicate) {\n      return this.toArray().filter(predicate);\n    }\n    find(predicate) {\n      return this.toArray().find(predicate);\n    }\n    findIndex(predicate) {\n      return this.toArray().findIndex(predicate);\n    }\n    forEach(callbackfn) {\n      return this.toArray().forEach(callbackfn);\n    }\n    get(index) {\n      if (!(0 > index || index >= this._items.length)) {\n        return liveNodeToLson(this._items[index]);\n      }\n    }\n    indexOf(searchElement, fromIndex) {\n      return this.toArray().indexOf(searchElement, fromIndex);\n    }\n    lastIndexOf(searchElement, fromIndex) {\n      return this.toArray().lastIndexOf(searchElement, fromIndex);\n    }\n    map(callback) {\n      return this._items.map((entry, i) => callback(liveNodeToLson(entry), i));\n    }\n    some(predicate) {\n      return this.toArray().some(predicate);\n    }\n    [Symbol.iterator]() {\n      return new LiveListIterator(this._items);\n    }\n    _createAttachItemAndSort(op, key) {\n      const newItem = lsonToLiveNode(creationOpToLson(op));\n      newItem._attach(op.id, nn(this._pool));\n      newItem._setParentLink(this, key);\n      this._insertAndSort(newItem);\n      op = this._indexOfPosition(key);\n      return {newItem, newIndex:op};\n    }\n    _shiftItemPosition(index, key) {\n      key = makePosition(key, this._items.length > index + 1 ? _optionalChain([this, \"access\", _95 => _95._items, \"access\", _96 => _96[index + 1], \"optionalAccess\", _97 => _97._parentPos]) : void 0);\n      this._items[index]._setParentLink(this, key);\n    }\n    _toTreeNode(key) {\n      return {type:\"LiveList\", id:_nullishCoalesce(this._id, () => nanoid()), key, payload:this._items.map((item, index) => item.toTreeNode(index.toString()))};\n    }\n    toImmutable() {\n      return super.toImmutable();\n    }\n    _toImmutable() {\n      const result = this._items.map(node => node.toImmutable());\n      return Object.freeze(result);\n    }\n    clone() {\n      return new node_modules$$liveblocks$core$dist$index$classdecl$var1(this._items.map(item => item.clone()));\n    }\n  };\n  var LiveList = node_modules$$liveblocks$core$dist$index$classdecl$var1, LiveListIterator = class {\n    constructor(items) {\n      this._innerIterator = items[Symbol.iterator]();\n    }\n    [Symbol.iterator]() {\n      return this;\n    }\n    next() {\n      const result = this._innerIterator.next();\n      return result.done ? {done:!0, value:void 0} : {value:liveNodeToLson(result.value)};\n    }\n  }, freeze = Object.freeze;\n  const node_modules$$liveblocks$core$dist$index$classdecl$var2 = class extends AbstractCrdt {\n    constructor(entries2) {\n      super();\n      this.unacknowledgedSet = new Map();\n      if (entries2) {\n        const mappedEntries = [];\n        for (const [key, value] of entries2) {\n          entries2 = lsonToLiveNode(value), entries2._setParentLink(this, key), mappedEntries.push([key, entries2]);\n        }\n        this._map = new Map(mappedEntries);\n      } else {\n        this._map = new Map();\n      }\n    }\n    _toOps(parentId, parentKey, pool) {\n      if (void 0 === this._id) {\n        throw Error(\"Cannot serialize item is not attached\");\n      }\n      const ops = [];\n      parentId = {id:this._id, opId:_optionalChain([pool, \"optionalAccess\", _98 => _98.generateOpId, \"call\", _99 => _99()]), type:7, parentId, parentKey};\n      ops.push(parentId);\n      for (const [key, value] of this._map) {\n        ops.push(...value._toOps(this._id, key, pool));\n      }\n      return ops;\n    }\n    static _deserialize([id], parentToChildren, pool) {\n      const map = new node_modules$$liveblocks$core$dist$index$classdecl$var2();\n      map._attach(id, pool);\n      id = parentToChildren.get(id);\n      if (void 0 === id) {\n        return map;\n      }\n      for (const [id2, crdt] of id) {\n        id = deserialize([id2, crdt], parentToChildren, pool), id._setParentLink(map, crdt.parentKey), map._map.set(crdt.parentKey, id), map.invalidate();\n      }\n      return map;\n    }\n    _attach(id, pool) {\n      super._attach(id, pool);\n      for (const [, value] of this._map) {\n        isLiveNode(value) && value._attach(pool.generateId(), pool);\n      }\n    }\n    _attachChild(op, source) {\n      if (void 0 === this._pool) {\n        throw Error(\"Can't attach child if managed pool is not present\");\n      }\n      const {id, parentKey, opId} = op;\n      op = lsonToLiveNode(creationOpToLson(op));\n      if (void 0 !== this._pool.getNode(id)) {\n        return {modified:!1};\n      }\n      if (2 === source) {\n        source = this.unacknowledgedSet.get(parentKey);\n        if (source === opId) {\n          return this.unacknowledgedSet.delete(parentKey), {modified:!1};\n        }\n        if (void 0 !== source) {\n          return {modified:!1};\n        }\n      } else {\n        1 === source && this.unacknowledgedSet.delete(parentKey);\n      }\n      source = this._map.get(parentKey);\n      if (source) {\n        var reverse = nn(this._id);\n        reverse = source._toOps(reverse, parentKey);\n        source._detach();\n      } else {\n        reverse = [{type:5, id}];\n      }\n      op._setParentLink(this, parentKey);\n      op._attach(id, this._pool);\n      this._map.set(parentKey, op);\n      this.invalidate();\n      return {modified:{node:this, type:\"LiveMap\", updates:{[parentKey]:{type:\"update\"}}}, reverse};\n    }\n    _detach() {\n      super._detach();\n      for (const item of this._map.values()) {\n        item._detach();\n      }\n    }\n    _detachChild(child) {\n      var id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      id = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        value === child && (this._map.delete(key), this.invalidate());\n      }\n      child._detach();\n      return {modified:{node:this, type:\"LiveMap\", updates:{[parentKey]:{type:\"delete\"}}}, reverse:id};\n    }\n    _serialize() {\n      if (\"HasParent\" !== this.parent.type) {\n        throw Error(\"Cannot serialize LiveMap if parent is missing\");\n      }\n      return {type:2, parentId:nn(this.parent.node._id, \"Parent node expected to have ID\"), parentKey:this.parent.key};\n    }\n    get(key) {\n      key = this._map.get(key);\n      if (void 0 !== key) {\n        return liveNodeToLson(key);\n      }\n    }\n    set(key, value) {\n      _optionalChain([this, \"access\", _100 => _100._pool, \"optionalAccess\", _101 => _101.assertStorageIsWritable, \"call\", _102 => _102()]);\n      const oldValue = this._map.get(key);\n      oldValue && oldValue._detach();\n      value = lsonToLiveNode(value);\n      value._setParentLink(this, key);\n      this._map.set(key, value);\n      this.invalidate();\n      if (this._pool && this._id) {\n        const id = this._pool.generateId();\n        value._attach(id, this._pool);\n        const storageUpdates = new Map();\n        storageUpdates.set(this._id, {node:this, type:\"LiveMap\", updates:{[key]:{type:\"update\"}}});\n        const ops = value._toOps(this._id, key, this._pool);\n        this.unacknowledgedSet.set(key, nn(ops[0].opId));\n        this._pool.dispatch(value._toOps(this._id, key, this._pool), oldValue ? oldValue._toOps(this._id, key) : [{type:5, id}], storageUpdates);\n      }\n    }\n    get size() {\n      return this._map.size;\n    }\n    has(key) {\n      return this._map.has(key);\n    }\n    delete(key) {\n      _optionalChain([this, \"access\", _103 => _103._pool, \"optionalAccess\", _104 => _104.assertStorageIsWritable, \"call\", _105 => _105()]);\n      const item = this._map.get(key);\n      if (void 0 === item) {\n        return !1;\n      }\n      item._detach();\n      this._map.delete(key);\n      this.invalidate();\n      if (this._pool && item._id) {\n        const thisId = nn(this._id), storageUpdates = new Map();\n        storageUpdates.set(thisId, {node:this, type:\"LiveMap\", updates:{[key]:{type:\"delete\"}}});\n        this._pool.dispatch([{type:5, id:item._id, opId:this._pool.generateOpId()}], item._toOps(thisId, key), storageUpdates);\n      }\n      return !0;\n    }\n    entries() {\n      const innerIterator = this._map.entries();\n      return {[Symbol.iterator]() {\n        return this;\n      }, next() {\n        var iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {done:!0, value:void 0};\n        }\n        const key = iteratorValue.value[0];\n        iteratorValue = liveNodeToLson(iteratorValue.value[1]);\n        return {value:[key, iteratorValue]};\n      }};\n    }\n    [Symbol.iterator]() {\n      return this.entries();\n    }\n    keys() {\n      return this._map.keys();\n    }\n    values() {\n      const innerIterator = this._map.values();\n      return {[Symbol.iterator]() {\n        return this;\n      }, next() {\n        const iteratorValue = innerIterator.next();\n        return iteratorValue.done ? {done:!0, value:void 0} : {value:liveNodeToLson(iteratorValue.value)};\n      }};\n    }\n    forEach(callback) {\n      for (const entry of this) {\n        callback(entry[1], entry[0], this);\n      }\n    }\n    _toTreeNode(key) {\n      return {type:\"LiveMap\", id:_nullishCoalesce(this._id, () => nanoid()), key, payload:Array.from(this._map.entries()).map(([key2, val]) => val.toTreeNode(key2))};\n    }\n    toImmutable() {\n      return super.toImmutable();\n    }\n    _toImmutable() {\n      const result = new Map();\n      for (const [key, value] of this._map) {\n        result.set(key, value.toImmutable());\n      }\n      return freeze(result);\n    }\n    clone() {\n      return new node_modules$$liveblocks$core$dist$index$classdecl$var2(Array.from(this._map).map(([key, node]) => [key, node.clone()]));\n    }\n  };\n  var LiveMap = node_modules$$liveblocks$core$dist$index$classdecl$var2;\n  const node_modules$$liveblocks$core$dist$index$classdecl$var3 = class extends AbstractCrdt {\n    static _buildRootAndParentToChildren(items) {\n      const parentToChildren = new Map();\n      let root = null;\n      for (const [id, crdt] of items) {\n        if (isRootCrdt(crdt)) {\n          root = [id, crdt];\n        } else {\n          items = [id, crdt];\n          const children = parentToChildren.get(crdt.parentId);\n          void 0 !== children ? children.push(items) : parentToChildren.set(crdt.parentId, [items]);\n        }\n      }\n      if (null === root) {\n        throw Error(\"Root can't be null\");\n      }\n      return [root, parentToChildren];\n    }\n    static _fromItems(items, pool) {\n      const [root, parentToChildren] = node_modules$$liveblocks$core$dist$index$classdecl$var3._buildRootAndParentToChildren(items);\n      return node_modules$$liveblocks$core$dist$index$classdecl$var3._deserialize(root, parentToChildren, pool);\n    }\n    constructor(obj = {}) {\n      super();\n      this._propToLastUpdate = new Map();\n      obj = compactObject(obj);\n      for (const key of Object.keys(obj)) {\n        const value = obj[key];\n        isLiveNode(value) && value._setParentLink(this, key);\n      }\n      this._map = new Map(Object.entries(obj));\n    }\n    _toOps(parentId, parentKey, pool) {\n      if (void 0 === this._id) {\n        throw Error(\"Cannot serialize item is not attached\");\n      }\n      const opId = _optionalChain([pool, \"optionalAccess\", _106 => _106.generateOpId, \"call\", _107 => _107()]), ops = [];\n      parentId = {type:4, id:this._id, opId, parentId, parentKey, data:{}};\n      ops.push(parentId);\n      for (const [key, value] of this._map) {\n        isLiveNode(value) ? ops.push(...value._toOps(this._id, key, pool)) : parentId.data[key] = value;\n      }\n      return ops;\n    }\n    static _deserialize([id, item], parentToChildren, pool) {\n      item = new node_modules$$liveblocks$core$dist$index$classdecl$var3(item.data);\n      item._attach(id, pool);\n      return this._deserializeChildren(item, parentToChildren, pool);\n    }\n    static _deserializeChildren(liveObj, parentToChildren, pool) {\n      var children = parentToChildren.get(nn(liveObj._id));\n      if (void 0 === children) {\n        return liveObj;\n      }\n      for (const [id, crdt] of children) {\n        children = deserializeToLson([id, crdt], parentToChildren, pool), isLiveStructure(children) && children._setParentLink(liveObj, crdt.parentKey), liveObj._map.set(crdt.parentKey, children), liveObj.invalidate();\n      }\n      return liveObj;\n    }\n    _attach(id, pool) {\n      super._attach(id, pool);\n      for (const [, value] of this._map) {\n        isLiveNode(value) && value._attach(pool.generateId(), pool);\n      }\n    }\n    _attachChild(op, source) {\n      if (void 0 === this._pool) {\n        throw Error(\"Can't attach child if managed pool is not present\");\n      }\n      const {id, opId, parentKey:key} = op;\n      op = creationOpToLson(op);\n      if (void 0 !== this._pool.getNode(id)) {\n        return this._propToLastUpdate.get(key) === opId && this._propToLastUpdate.delete(key), {modified:!1};\n      }\n      if (0 === source) {\n        this._propToLastUpdate.set(key, nn(opId));\n      } else if (void 0 !== this._propToLastUpdate.get(key)) {\n        return this._propToLastUpdate.get(key) === opId && this._propToLastUpdate.delete(key), {modified:!1};\n      }\n      var thisId = nn(this._id);\n      source = this._map.get(key);\n      isLiveNode(source) ? (thisId = source._toOps(thisId, key), source._detach()) : thisId = void 0 === source ? [{type:6, id:thisId, key}] : [{type:3, id:thisId, data:{[key]:source}}];\n      this._map.set(key, op);\n      this.invalidate();\n      isLiveStructure(op) && (op._setParentLink(this, key), op._attach(id, this._pool));\n      return {reverse:thisId, modified:{node:this, type:\"LiveObject\", updates:{[key]:{type:\"update\"}}}};\n    }\n    _detachChild(child) {\n      if (child) {\n        var id = nn(this._id);\n        const parentKey = nn(child._parentKey);\n        id = child._toOps(id, parentKey, this._pool);\n        for (const [key, value] of this._map) {\n          value === child && (this._map.delete(key), this.invalidate());\n        }\n        child._detach();\n        return {modified:{node:this, type:\"LiveObject\", updates:{[parentKey]:{type:\"delete\"}}}, reverse:id};\n      }\n      return {modified:!1};\n    }\n    _detach() {\n      super._detach();\n      for (const value of this._map.values()) {\n        isLiveNode(value) && value._detach();\n      }\n    }\n    _apply(op, isLocal) {\n      return 3 === op.type ? this._applyUpdate(op, isLocal) : 6 === op.type ? this._applyDeleteObjectKey(op, isLocal) : super._apply(op, isLocal);\n    }\n    _serialize() {\n      const data = {};\n      for (const [key, value] of this._map) {\n        isLiveNode(value) || (data[key] = value);\n      }\n      return \"HasParent\" === this.parent.type && this.parent.node._id ? {type:0, parentId:this.parent.node._id, parentKey:this.parent.key, data} : {type:0, data};\n    }\n    _applyUpdate(op, isLocal) {\n      var isModified = !1, id = nn(this._id);\n      const reverse = [], reverseUpdate = {type:3, id, data:{}};\n      for (var key$jscomp$0 in op.data) {\n        const oldValue = this._map.get(key$jscomp$0);\n        isLiveNode(oldValue) ? (reverse.push(...oldValue._toOps(id, key$jscomp$0)), oldValue._detach()) : void 0 !== oldValue ? reverseUpdate.data[key$jscomp$0] = oldValue : void 0 === oldValue && reverse.push({type:6, id, key:key$jscomp$0});\n      }\n      id = {};\n      for (const key in op.data) {\n        if (key$jscomp$0 = op.data[key], void 0 !== key$jscomp$0) {\n          if (isLocal) {\n            this._propToLastUpdate.set(key, nn(op.opId));\n          } else if (void 0 !== this._propToLastUpdate.get(key)) {\n            this._propToLastUpdate.get(key) === op.opId && this._propToLastUpdate.delete(key);\n            continue;\n          }\n          isModified = this._map.get(key);\n          isLiveNode(isModified) && isModified._detach();\n          isModified = !0;\n          id[key] = {type:\"update\"};\n          this._map.set(key, key$jscomp$0);\n          this.invalidate();\n        }\n      }\n      0 !== Object.keys(reverseUpdate.data).length && reverse.unshift(reverseUpdate);\n      return isModified ? {modified:{node:this, type:\"LiveObject\", updates:id}, reverse} : {modified:!1};\n    }\n    _applyDeleteObjectKey(op, isLocal) {\n      const key = op.key;\n      if (!1 === this._map.has(key) || !isLocal && void 0 !== this._propToLastUpdate.get(key)) {\n        return {modified:!1};\n      }\n      isLocal = this._map.get(key);\n      const id = nn(this._id);\n      let reverse = [];\n      isLiveNode(isLocal) ? (reverse = isLocal._toOps(id, op.key), isLocal._detach()) : void 0 !== isLocal && (reverse = [{type:3, id, data:{[key]:isLocal}}]);\n      this._map.delete(key);\n      this.invalidate();\n      return {modified:{node:this, type:\"LiveObject\", updates:{[op.key]:{type:\"delete\"}}}, reverse};\n    }\n    toObject() {\n      return Object.fromEntries(this._map);\n    }\n    set(key, value) {\n      _optionalChain([this, \"access\", _108 => _108._pool, \"optionalAccess\", _109 => _109.assertStorageIsWritable, \"call\", _110 => _110()]);\n      this.update({[key]:value});\n    }\n    get(key) {\n      return this._map.get(key);\n    }\n    delete(key) {\n      _optionalChain([this, \"access\", _111 => _111._pool, \"optionalAccess\", _112 => _112.assertStorageIsWritable, \"call\", _113 => _113()]);\n      var oldValue = this._map.get(key);\n      if (void 0 !== oldValue) {\n        if (void 0 === this._pool || void 0 === this._id) {\n          isLiveNode(oldValue) && oldValue._detach(), this._map.delete(key), this.invalidate();\n        } else {\n          isLiveNode(oldValue) ? (oldValue._detach(), oldValue = oldValue._toOps(this._id, key)) : oldValue = [{type:3, data:{[key]:oldValue}, id:this._id}];\n          this._map.delete(key);\n          this.invalidate();\n          var storageUpdates = new Map();\n          storageUpdates.set(this._id, {node:this, type:\"LiveObject\", updates:{[key]:{type:\"delete\"}}});\n          this._pool.dispatch([{type:6, key, id:this._id, opId:this._pool.generateOpId()}], oldValue, storageUpdates);\n        }\n      }\n    }\n    update(patch) {\n      _optionalChain([this, \"access\", _114 => _114._pool, \"optionalAccess\", _115 => _115.assertStorageIsWritable, \"call\", _116 => _116()]);\n      if (void 0 === this._pool || void 0 === this._id) {\n        for (var key$jscomp$0 in patch) {\n          var newValue$jscomp$0 = patch[key$jscomp$0];\n          if (void 0 !== newValue$jscomp$0) {\n            var oldValue = this._map.get(key$jscomp$0);\n            isLiveNode(oldValue) && oldValue._detach();\n            isLiveNode(newValue$jscomp$0) && newValue$jscomp$0._setParentLink(this, key$jscomp$0);\n            this._map.set(key$jscomp$0, newValue$jscomp$0);\n            this.invalidate();\n          }\n        }\n      } else {\n        key$jscomp$0 = [];\n        newValue$jscomp$0 = [];\n        var opId = this._pool.generateOpId(), updatedProps = {}, reverseUpdateOp = {id:this._id, type:3, data:{}};\n        oldValue = {};\n        for (const key in patch) {\n          const newValue = patch[key];\n          if (void 0 !== newValue) {\n            var oldValue$jscomp$0 = this._map.get(key);\n            isLiveNode(oldValue$jscomp$0) ? (newValue$jscomp$0.push(...oldValue$jscomp$0._toOps(this._id, key)), oldValue$jscomp$0._detach()) : void 0 === oldValue$jscomp$0 ? newValue$jscomp$0.push({type:6, id:this._id, key}) : reverseUpdateOp.data[key] = oldValue$jscomp$0;\n            if (isLiveNode(newValue)) {\n              newValue._setParentLink(this, key);\n              newValue._attach(this._pool.generateId(), this._pool);\n              oldValue$jscomp$0 = newValue._toOps(this._id, key, this._pool);\n              const createCrdtOp = oldValue$jscomp$0.find(op => op.parentId === this._id);\n              createCrdtOp && this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n              key$jscomp$0.push(...oldValue$jscomp$0);\n            } else {\n              updatedProps[key] = newValue, this._propToLastUpdate.set(key, opId);\n            }\n            this._map.set(key, newValue);\n            this.invalidate();\n            oldValue[key] = {type:\"update\"};\n          }\n        }\n        0 !== Object.keys(reverseUpdateOp.data).length && newValue$jscomp$0.unshift(reverseUpdateOp);\n        0 !== Object.keys(updatedProps).length && key$jscomp$0.unshift({opId, id:this._id, type:3, data:updatedProps});\n        patch = new Map();\n        patch.set(this._id, {node:this, type:\"LiveObject\", updates:oldValue});\n        this._pool.dispatch(key$jscomp$0, newValue$jscomp$0, patch);\n      }\n    }\n    toImmutable() {\n      return super.toImmutable();\n    }\n    toTreeNode(key) {\n      return super.toTreeNode(key);\n    }\n    _toTreeNode(key) {\n      const nodeId = _nullishCoalesce(this._id, () => nanoid());\n      return {type:\"LiveObject\", id:nodeId, key, payload:Array.from(this._map.entries()).map(([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : {type:\"Json\", id:`${nodeId}:${key2}`, key:key2, payload:value})};\n    }\n    _toImmutable() {\n      const result = {};\n      for (const [key, val] of this._map) {\n        result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n      }\n      return Object.freeze(result);\n    }\n    clone() {\n      return new node_modules$$liveblocks$core$dist$index$classdecl$var3(Object.fromEntries(Array.from(this._map).map(([key, value]) => [key, isLiveStructure(value) ? value.clone() : deepClone(value)])));\n    }\n  };\n  var LiveObject = node_modules$$liveblocks$core$dist$index$classdecl$var3, identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/, getFiltersFromKeyValuePairs = keyValuePairs => {\n    const filters = [];\n    keyValuePairs.forEach(([key, value]) => {\n      filters.push({key, operator:\":\", value});\n    });\n    return filters;\n  }, getFiltersFromKeyValuePairsWithOperator = keyValuePairsWithOperator => {\n    const filters = [];\n    keyValuePairsWithOperator.forEach(([key, value]) => {\n      \"startsWith\" in value && \"string\" === typeof value.startsWith && filters.push({key, operator:\"^\", value:value.startsWith});\n    });\n    return filters;\n  }, isSimpleValue = value => \"string\" === typeof value || \"number\" === typeof value || \"boolean\" === typeof value ? !0 : !1, isValueWithOperator = value => \"object\" === typeof value && null !== value && \"startsWith\" in value ? !0 : !1, ClientMsgCode = (ClientMsgCode2 => {\n    ClientMsgCode2[ClientMsgCode2.UPDATE_PRESENCE = 100] = \"UPDATE_PRESENCE\";\n    ClientMsgCode2[ClientMsgCode2.BROADCAST_EVENT = 103] = \"BROADCAST_EVENT\";\n    ClientMsgCode2[ClientMsgCode2.FETCH_STORAGE = 200] = \"FETCH_STORAGE\";\n    ClientMsgCode2[ClientMsgCode2.UPDATE_STORAGE = 201] = \"UPDATE_STORAGE\";\n    ClientMsgCode2[ClientMsgCode2.FETCH_YDOC = 300] = \"FETCH_YDOC\";\n    ClientMsgCode2[ClientMsgCode2.UPDATE_YDOC = 301] = \"UPDATE_YDOC\";\n    return ClientMsgCode2;\n  })(ClientMsgCode || {}), ImmutableRef = class {\n    constructor() {\n      this._ev = makeEventSource();\n    }\n    get didInvalidate() {\n      return this._ev.observable;\n    }\n    invalidate() {\n      void 0 !== this._cache && (this._cache = void 0, this._ev.notify());\n    }\n    get current() {\n      return _nullishCoalesce(this._cache, () => this._cache = this._toImmutable());\n    }\n  }, OthersRef = class extends ImmutableRef {\n    constructor() {\n      super();\n      this._connections = new Map();\n      this._presences = new Map();\n      this._users = new Map();\n    }\n    connectionIds() {\n      return this._connections.keys();\n    }\n    _toImmutable() {\n      return compact(Array.from(this._presences.keys()).map(connectionId => this.getUser(Number(connectionId))));\n    }\n    clearOthers() {\n      this._connections = new Map();\n      this._presences = new Map();\n      this._users = new Map();\n      this.invalidate();\n    }\n    _getUser(connectionId$jscomp$0) {\n      const conn = this._connections.get(connectionId$jscomp$0);\n      connectionId$jscomp$0 = this._presences.get(connectionId$jscomp$0);\n      if (void 0 !== conn && void 0 !== connectionId$jscomp$0) {\n        const {connectionId, id, info} = conn, canWrite = conn.scopes.includes(\"room:write\");\n        return freeze(compactObject({connectionId, id, info, canWrite, canComment:canComment(conn.scopes), isReadOnly:!canWrite, presence:connectionId$jscomp$0}));\n      }\n    }\n    getUser(connectionId) {\n      var cachedUser = this._users.get(connectionId);\n      if (cachedUser) {\n        return cachedUser;\n      }\n      if (cachedUser = this._getUser(connectionId)) {\n        return this._users.set(connectionId, cachedUser), cachedUser;\n      }\n    }\n    _invalidateUser(connectionId) {\n      this._users.has(connectionId) && this._users.delete(connectionId);\n      this.invalidate();\n    }\n    setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n      this._connections.set(connectionId, freeze({connectionId, id:metaUserId, info:metaUserInfo, scopes}));\n      this._presences.has(connectionId) && this._invalidateUser(connectionId);\n    }\n    removeConnection(connectionId) {\n      this._connections.delete(connectionId);\n      this._presences.delete(connectionId);\n      this._invalidateUser(connectionId);\n    }\n    setOther(connectionId, presence) {\n      this._presences.set(connectionId, freeze(compactObject(presence)));\n      this._connections.has(connectionId) && this._invalidateUser(connectionId);\n    }\n    patchOther(connectionId, patch) {\n      const oldPresence = this._presences.get(connectionId);\n      void 0 !== oldPresence && (patch = merge(oldPresence, patch), oldPresence !== patch && (this._presences.set(connectionId, freeze(patch)), this._invalidateUser(connectionId)));\n    }\n  }, PatchableRef = class extends ImmutableRef {\n    constructor(data) {\n      super();\n      this._data = freeze(compactObject(data));\n    }\n    _toImmutable() {\n      return this._data;\n    }\n    patch(patch) {\n      const oldData = this._data;\n      patch = merge(oldData, patch);\n      oldData !== patch && (this._data = freeze(patch), this.invalidate());\n    }\n  }, ValueRef = class extends ImmutableRef {\n    constructor(initialValue) {\n      super();\n      this._value = freeze(initialValue);\n    }\n    _toImmutable() {\n      return this._value;\n    }\n    set(newValue) {\n      this._value = freeze(newValue);\n      this.invalidate();\n    }\n  }, DerivedRef = class extends ImmutableRef {\n    constructor(...args) {\n      super();\n      const transformFn = args.pop();\n      this._refs = args;\n      this._refs.forEach(ref => {\n        ref.didInvalidate.subscribe(() => this.invalidate());\n      });\n      this._transform = transformFn;\n    }\n    _toImmutable() {\n      return this._transform(...this._refs.map(ref => ref.current));\n    }\n  }, RETRY_DELAYS = [2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3, 2e3], commentBodyElementsGuards = {paragraph:function(element) {\n    return \"type\" in element && \"paragraph\" === element.type;\n  }, text:isCommentBodyText, link:isCommentBodyLink, mention:isCommentBodyMention}, commentBodyElementsTypes = {paragraph:\"block\", text:\"inline\", link:\"inline\", mention:\"inline\"}, htmlEscapables = {\"\\x26\":\"\\x26amp;\", \"\\x3c\":\"\\x26lt;\", \"\\x3e\":\"\\x26gt;\", '\"':\"\\x26quot;\", \"'\":\"\\x26#39;\"}, htmlEscapablesRegex = new RegExp(Object.keys(htmlEscapables).map(entity => `\\\\${entity}`).join(\"|\"), \"g\"), HtmlSafeString = class {\n    constructor(strings, values) {\n      this._strings = strings;\n      this._values = values;\n    }\n    toString() {\n      return this._strings.reduce((result, str, i) => result + escapeHtml(nn(this._values[i - 1])) + str);\n    }\n  }, markdownEscapables = {_:\"\\\\_\", \"*\":\"\\\\*\", \"#\":\"\\\\#\", \"`\":\"\\\\`\", \"~\":\"\\\\~\", \"!\":\"\\\\!\", \"|\":\"\\\\|\", \"(\":\"\\\\(\", \")\":\"\\\\)\", \"{\":\"\\\\{\", \"}\":\"\\\\}\", \"[\":\"\\\\[\", \"]\":\"\\\\]\"}, markdownEscapablesRegex = new RegExp(Object.keys(markdownEscapables).map(entity => `\\\\${entity}`).join(\"|\"), \"g\"), MarkdownSafeString = class {\n    constructor(strings, values) {\n      this._strings = strings;\n      this._values = values;\n    }\n    toString() {\n      return this._strings.reduce((result, str, i) => result + escapeMarkdown(nn(this._values[i - 1])) + str);\n    }\n  }, stringifyCommentBodyPlainElements = {paragraph:({children}) => children, text:({element}) => element.text, link:({element}) => _nullishCoalesce(element.text, () => element.url), mention:({element, user}) => `@${_nullishCoalesce(_optionalChain([user, \"optionalAccess\", _175 => _175.name]), () => element.id)}`}, stringifyCommentBodyHtmlElements = {paragraph:({children}) => children ? html`<p>${new HtmlSafeString([String(children)], [])}</p>` : children, text:({element}) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    element.bold && (children = html`<strong>${children}</strong>`);\n    element.italic && (children = html`<em>${children}</em>`);\n    element.strikethrough && (children = html`<s>${children}</s>`);\n    element.code && (children = html`<code>${children}</code>`);\n    return children;\n  }, link:({element, href}) => html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${_nullishCoalesce(element.text, () => element.url)}</a>`, mention:({element, user}) => html`<span data-mention>@${_nullishCoalesce(_optionalChain([user, \"optionalAccess\", _176 => _176.name]), () => element.id)}</span>`}, stringifyCommentBodyMarkdownElements = {paragraph:({children}) => children, text:({element}) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    element.bold && (children = markdown`**${children}**`);\n    element.italic && (children = markdown`_${children}_`);\n    element.strikethrough && (children = markdown`~~${children}~~`);\n    element.code && (children = markdown`\\`${children}\\``);\n    return children;\n  }, link:({element, href}) => markdown`[${_nullishCoalesce(element.text, () => element.url)}](${href})`, mention:({element, user}) => markdown`@${_nullishCoalesce(_optionalChain([user, \"optionalAccess\", _177 => _177.name]), () => element.id)}`}, _emittedDeprecationWarnings = new Set(), BACKOFF_DELAYS2 = [1e3, 2e3, 4e3, 8e3, 1e4];\n  const node_modules$$liveblocks$core$dist$index$classdecl$var4 = class {\n    constructor(alreadySortedList, lt) {\n      this._lt = lt;\n      this._data = alreadySortedList;\n    }\n    static from(arr, lt) {\n      lt = new node_modules$$liveblocks$core$dist$index$classdecl$var4([], lt);\n      for (const item of arr) {\n        lt.add(item);\n      }\n      return lt;\n    }\n    static fromAlreadySorted(alreadySorted, lt) {\n      return new node_modules$$liveblocks$core$dist$index$classdecl$var4(alreadySorted, lt);\n    }\n    clone() {\n      return new node_modules$$liveblocks$core$dist$index$classdecl$var4(this._data.slice(), this._lt);\n    }\n    add(value) {\n      var arr = this._data, lt = this._lt;\n      let lo = 0, hi = arr.length;\n      for (; lo < hi;) {\n        const mid = lo + (hi - lo >> 1);\n        lt(value, arr[mid]) ? hi = mid : lo = mid + 1;\n      }\n      this._data.splice(lo, 0, value);\n    }\n    remove(value) {\n      value = this._data.indexOf(value);\n      return 0 <= value ? (this._data.splice(value, 1), !0) : !1;\n    }\n    get length() {\n      return this._data.length;\n    }\n    *filter(predicate) {\n      for (const item of this._data) {\n        predicate(item) && (yield item);\n      }\n    }\n    [Symbol.iterator]() {\n      return this._data[Symbol.iterator]();\n    }\n  };\n  var SortedList = node_modules$$liveblocks$core$dist$index$classdecl$var4;\n  detectDupes(\"@liveblocks/core\", \"2.10.2\", \"cjs\");\n  var CommentsApiError = HttpError, NotificationsApiError = HttpError;\n  exports.ClientMsgCode = ClientMsgCode;\n  exports.CommentsApiError = CommentsApiError;\n  exports.CrdtType = CrdtType;\n  exports.HttpError = HttpError;\n  exports.LiveList = LiveList;\n  exports.LiveMap = LiveMap;\n  exports.LiveObject = LiveObject;\n  exports.NotificationsApiError = NotificationsApiError;\n  exports.OpCode = OpCode;\n  exports.ServerMsgCode = ServerMsgCode;\n  exports.SortedList = SortedList;\n  exports.WebsocketCloseCodes = WebsocketCloseCodes;\n  exports.ackOp = function(opId) {\n    return {type:5, id:\"ACK\", opId};\n  };\n  exports.asPos = asPos;\n  exports.assert = assert;\n  exports.assertNever = assertNever;\n  exports.autoRetry = autoRetry;\n  exports.b64decode = b64decode;\n  exports.chunk = chunk;\n  exports.cloneLson = cloneLson;\n  exports.compactObject = compactObject;\n  exports.console = fancy_console_exports;\n  exports.convertToCommentData = convertToCommentData;\n  exports.convertToCommentUserReaction = convertToCommentUserReaction;\n  exports.convertToInboxNotificationData = convertToInboxNotificationData;\n  exports.convertToThreadData = convertToThreadData;\n  exports.createClient = function(options) {\n    function leaseRoom(details) {\n      const leave = () => {\n        if (!details.unsubs.delete(leave)) {\n          warn(\"This leave function was already called. Calling it more than once has no effect.\");\n        } else {\n          if (0 === details.unsubs.size) {\n            var room = details.room, roomId = room.id;\n            \"undefined\" !== typeof window && (stopSyncStream(roomId), stopRoomChannelListener(roomId), sendToPanel({msg:\"room::unavailable\", roomId}));\n            roomsById.delete(room.id);\n            room.destroy();\n          }\n        }\n      };\n      details.unsubs.add(leave);\n      return {room:details.room, leave};\n    }\n    const throttleDelay = checkBounds(\"throttle\", _nullishCoalesce(options.throttle, () => 100), 16, 1e3), lostConnectionTimeout = checkBounds(\"lostConnectionTimeout\", _nullishCoalesce(options.lostConnectionTimeout, () => 5e3), 200, 3e4, 1e3), backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(options.backgroundKeepAliveTimeout), baseUrl = getBaseUrl(options.baseUrl), authManager = createAuthManager(options), roomsById = new Map(), currentUserIdStore = createStore(null);\n    var fetchPolyfill = _optionalChain([options, \"access\", _164 => _164.polyfills, \"optionalAccess\", _165 => _165.fetch]) || _optionalChain([globalThis, \"access\", _166 => _166.fetch, \"optionalAccess\", _167 => _167.bind, \"call\", _168 => _168(globalThis)]);\n    fetchPolyfill = createNotificationsApi({baseUrl, fetchPolyfill, authManager, currentUserIdStore});\n    const resolveUsers = options.resolveUsers, warnIfNoResolveUsers = createDevelopmentWarning(() => !resolveUsers, \"Set the resolveUsers option in createClient to specify user info.\");\n    var batchedResolveUsers = new Batch(async batchedUserIds => {\n      const userIds = batchedUserIds.flat();\n      batchedUserIds = await _optionalChain([resolveUsers, \"optionalCall\", _169 => _169({userIds})]);\n      warnIfNoResolveUsers();\n      return _nullishCoalesce(batchedUserIds, () => userIds.map(() => {\n      }));\n    }, {delay:50});\n    const usersStore = createBatchStore(batchedResolveUsers), resolveRoomsInfo = options.resolveRoomsInfo, warnIfNoResolveRoomsInfo = createDevelopmentWarning(() => !resolveRoomsInfo, \"Set the resolveRoomsInfo option in createClient to specify room info.\");\n    batchedResolveUsers = new Batch(async batchedRoomIds => {\n      const roomIds = batchedRoomIds.flat();\n      batchedRoomIds = await _optionalChain([resolveRoomsInfo, \"optionalCall\", _170 => _170({roomIds})]);\n      warnIfNoResolveRoomsInfo();\n      return _nullishCoalesce(batchedRoomIds, () => roomIds.map(() => {\n      }));\n    }, {delay:50});\n    const roomsInfoStore = createBatchStore(batchedResolveUsers), mentionSuggestionsCache = new Map(), client = Object.defineProperty({enterRoom:function(roomId, ...args) {\n      var existing = roomsById.get(roomId);\n      if (void 0 !== existing) {\n        return leaseRoom(existing);\n      }\n      args = _nullishCoalesce(args[0], () => ({}));\n      existing = _nullishCoalesce(\"function\" === typeof args.initialPresence ? args.initialPresence(roomId) : args.initialPresence, () => ({}));\n      var initialStorage = _nullishCoalesce(\"function\" === typeof args.initialStorage ? args.initialStorage(roomId) : args.initialStorage, () => ({}));\n      existing = createRoom({initialPresence:existing, initialStorage}, {roomId, throttleDelay, lostConnectionTimeout, backgroundKeepAliveTimeout, polyfills:options.polyfills, delegates:_nullishCoalesce(options.mockedDelegates, () => ({createSocket:makeCreateSocketDelegateForRoom(roomId, baseUrl, _optionalChain([options, \"access\", _156 => _156.polyfills, \"optionalAccess\", _157 => _157.WebSocket])), authenticate:makeAuthDelegateForRoom(roomId, authManager)})), enableDebugLogging:options.enableDebugLogging, \n      unstable_batchedUpdates:_optionalChain([args, \"optionalAccess\", _158 => _158.unstable_batchedUpdates]), baseUrl, unstable_fallbackToHTTP:!!options.unstable_fallbackToHTTP, unstable_streamData:!!options.unstable_streamData});\n      initialStorage = {room:existing, unsubs:new Set()};\n      roomsById.set(roomId, initialStorage);\n      setupDevTools(() => Array.from(roomsById.keys()));\n      linkDevTools(roomId, existing);\n      if (_nullishCoalesce(args.autoConnect, () => !0)) {\n        if (\"undefined\" === typeof atob) {\n          if (void 0 === _optionalChain([options, \"access\", _159 => _159.polyfills, \"optionalAccess\", _160 => _160.atob])) {\n            throw Error(\"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\");\n          }\n          global.atob = options.polyfills.atob;\n        }\n        existing.connect();\n      }\n      return leaseRoom(initialStorage);\n    }, getRoom:function(roomId) {\n      const room = _optionalChain([roomsById, \"access\", _161 => _161.get, \"call\", _162 => _162(roomId), \"optionalAccess\", _163 => _163.room]);\n      return room ? room : null;\n    }, logout:function() {\n      authManager.reset();\n      for (const {room} of roomsById.values()) {\n        var status = room.getStatus();\n        \"initial\" === status || \"disconnected\" === status || room.reconnect();\n      }\n    }, ...fetchPolyfill, resolvers:{invalidateUsers:function(userIds) {\n      usersStore.invalidate(userIds);\n    }, invalidateRoomsInfo:function(roomIds) {\n      roomsInfoStore.invalidate(roomIds);\n    }, invalidateMentionSuggestions:function() {\n      mentionSuggestionsCache.clear();\n    }}, [kInternal]:{currentUserIdStore, mentionSuggestionsCache, resolveMentionSuggestions:options.resolveMentionSuggestions, usersStore, roomsInfoStore, getRoomIds() {\n      return Array.from(roomsById.keys());\n    }, getUserThreads_experimental:fetchPolyfill.getUserThreads_experimental, getUserThreadsSince_experimental:fetchPolyfill.getUserThreadsSince_experimental, as:() => client}}, kInternal, {enumerable:!1});\n    return client;\n  };\n  exports.createCommentId = createCommentId;\n  exports.createInboxNotificationId = function() {\n    return `${\"in\"}_${nanoid()}`;\n  };\n  exports.createStore = createStore;\n  exports.createThreadId = createThreadId;\n  exports.deprecate = deprecate;\n  exports.deprecateIf = function(condition, message, key = message) {\n    condition && deprecate(message, key);\n  };\n  exports.detectDupes = detectDupes;\n  exports.errorIf = function(condition, message) {\n    condition && throwUsageError(message);\n  };\n  exports.freeze = freeze;\n  exports.getMentionedIdsFromCommentBody = getMentionedIdsFromCommentBody;\n  exports.isChildCrdt = isChildCrdt;\n  exports.isJsonArray = isJsonArray;\n  exports.isJsonObject = isJsonObject;\n  exports.isJsonScalar = isJsonScalar;\n  exports.isLiveNode = isLiveNode;\n  exports.isPlainObject = isPlainObject;\n  exports.isRootCrdt = isRootCrdt;\n  exports.kInternal = kInternal;\n  exports.legacy_patchImmutableObject = function(state, updates) {\n    return updates.reduce((state2, update) => {\n      var node = update.node;\n      const path = [];\n      for (; \"HasParent\" === node.parent.type;) {\n        node.parent.node instanceof LiveList ? path.push(node.parent.node._indexOfPosition(node.parent.key)) : path.push(node.parent.key), node = node.parent.node;\n      }\n      return legacy_patchImmutableNode(state2, path, update);\n    }, state);\n  };\n  exports.lsonToJson = lsonToJson;\n  exports.makeEventSource = makeEventSource;\n  exports.makePoller = function(callback, intervalMs, options) {\n    function startOrStop() {\n      0 < context.count && context.inForeground ? fsm.send({type:\"START\"}) : fsm.send({type:\"STOP\"});\n    }\n    function pollNowIfStale() {\n      performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs && fsm.send({type:\"POLL\"});\n    }\n    function setInForeground(inForeground) {\n      context.inForeground = inForeground;\n      startOrStop();\n      pollNowIfStale();\n    }\n    function onVisibilityChange() {\n      setInForeground(\"hidden\" !== _optionalChain([doc, \"optionalAccess\", _196 => _196.visibilityState]));\n    }\n    const startTime = performance.now(), doc = \"undefined\" !== typeof document ? document : void 0, win = \"undefined\" !== typeof window ? window : void 0, maxStaleTimeMs = _nullishCoalesce(_optionalChain([options, \"optionalAccess\", _194 => _194.maxStaleTimeMs]), () => Number.POSITIVE_INFINITY), context = {inForeground:\"hidden\" !== _optionalChain([doc, \"optionalAccess\", _195 => _195.visibilityState]), lastSuccessfulPollAt:startTime, count:0, backoff:0}, fsm = (new FSM({})).addState(\"@idle\").addState(\"@enabled\").addState(\"@polling\");\n    fsm.addTransitions(\"@idle\", {START:\"@enabled\"});\n    fsm.addTransitions(\"@enabled\", {STOP:\"@idle\", POLL:\"@polling\"});\n    fsm.addTimedTransition(\"@enabled\", () => Math.max(0, context.lastSuccessfulPollAt + intervalMs - performance.now()) + context.backoff, \"@polling\");\n    fsm.onEnterAsync(\"@polling\", async(_ctx, signal) => {\n      await callback(signal);\n      signal.aborted || (context.lastSuccessfulPollAt = performance.now());\n    }, () => ({target:0 < context.count && context.inForeground ? \"@enabled\" : \"@idle\", effect:() => {\n      context.backoff = 0;\n    }}), () => ({target:0 < context.count && context.inForeground ? \"@enabled\" : \"@idle\", effect:() => {\n      context.backoff = _nullishCoalesce(BACKOFF_DELAYS2.find(delay => delay > context.backoff), () => BACKOFF_DELAYS2[BACKOFF_DELAYS2.length - 1]);\n    }}), 3e4);\n    _optionalChain([doc, \"optionalAccess\", _197 => _197.addEventListener, \"call\", _198 => _198(\"visibilitychange\", onVisibilityChange)]);\n    _optionalChain([win, \"optionalAccess\", _199 => _199.addEventListener, \"call\", _200 => _200(\"online\", onVisibilityChange)]);\n    fsm.start();\n    return {inc:function() {\n      context.count++;\n      startOrStop();\n    }, dec:function() {\n      context.count--;\n      0 > context.count && (context.count = 0);\n      startOrStop();\n    }, pollNowIfStale, setInForeground};\n  };\n  exports.makePosition = makePosition;\n  exports.mapValues = function(obj, mapFn) {\n    const result = {};\n    for (const pair of Object.entries(obj)) {\n      obj = pair[0], \"__proto__\" !== obj && (result[obj] = mapFn(pair[1], obj));\n    }\n    return result;\n  };\n  exports.memoizeOnSuccess = memoizeOnSuccess;\n  exports.nanoid = nanoid;\n  exports.nn = nn;\n  exports.objectToQuery = objectToQuery;\n  exports.patchLiveObjectKey = patchLiveObjectKey;\n  exports.raise = raise;\n  exports.shallow = function(a, b) {\n    if (Object.is(a, b)) {\n      return !0;\n    }\n    var isArrayA = Array.isArray(a);\n    const isArrayB = Array.isArray(b);\n    if (isArrayA || isArrayB) {\n      if (!isArrayA || !isArrayB) {\n        return !1;\n      }\n      a: {\n        if (a.length !== b.length) {\n          a = !1;\n        } else {\n          for (isArrayA = 0; isArrayA < a.length; isArrayA++) {\n            if (!Object.is(a[isArrayA], b[isArrayA])) {\n              a = !1;\n              break a;\n            }\n          }\n          a = !0;\n        }\n      }\n      return a;\n    }\n    return shallowObj(a, b);\n  };\n  exports.stringify = stringify;\n  exports.stringifyCommentBody = async function(body, options) {\n    const format = _nullishCoalesce(_optionalChain([options, \"optionalAccess\", _178 => _178.format]), () => \"plain\"), separator = _nullishCoalesce(_optionalChain([options, \"optionalAccess\", _179 => _179.separator]), () => \"markdown\" === format ? \"\\n\\n\" : \"\\n\"), elements = {...(\"html\" === format ? stringifyCommentBodyHtmlElements : \"markdown\" === format ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements), ..._optionalChain([options, \"optionalAccess\", _180 => _180.elements])}, \n    resolvedUsers = await resolveUsersInCommentBody(body, _optionalChain([options, \"optionalAccess\", _181 => _181.resolveUsers]));\n    return body.content.flatMap((block, blockIndex) => {\n      switch(block.type) {\n        case \"paragraph\":\n          const inlines = block.children.flatMap((inline, inlineIndex) => isCommentBodyMention(inline) ? inline.id ? [elements.mention({element:inline, user:resolvedUsers.get(inline.id)}, inlineIndex)] : [] : isCommentBodyLink(inline) ? [elements.link({element:inline, href:_nullishCoalesce(toAbsoluteUrl(inline.url), () => inline.url)}, inlineIndex)] : isCommentBodyText(inline) ? [elements.text({element:inline}, inlineIndex)] : []);\n          return [elements.paragraph({element:block, children:inlines.join(\"\")}, blockIndex)];\n        default:\n          return [];\n      }\n    }).join(separator);\n  };\n  exports.throwUsageError = throwUsageError;\n  exports.toPlainLson = toPlainLson;\n  exports.tryParseJson = tryParseJson;\n  exports.url = url;\n  exports.urljoin = urljoin;\n  exports.wait = wait;\n  exports.withTimeout = withTimeout;\n};\n","~:source","shadow$provide[\"module$node_modules$$liveblocks$core$dist$index\"] = function(global,require,module,exports) {\n\"use strict\";Object.defineProperty(exports, \"__esModule\", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/version.ts\nvar PKG_NAME = \"@liveblocks/core\";\nvar PKG_VERSION = \"2.10.2\";\nvar PKG_FORMAT = \"cjs\";\n\n// src/dupe-detection.ts\nvar g = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {};\nvar crossLinkedDocs = \"https://liveblocks.io/docs/errors/cross-linked\";\nvar dupesDocs = \"https://liveblocks.io/docs/errors/dupes\";\nvar SPACE = \" \";\nfunction error(msg) {\n  if (process.env.NODE_ENV === \"production\") {\n    console.error(msg);\n  } else {\n    throw new Error(msg);\n  }\n}\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\n  const pkgId = Symbol.for(pkgName);\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \"dev\"} (${pkgFormat})` : pkgVersion || \"dev\";\n  if (!g[pkgId]) {\n    g[pkgId] = pkgBuildInfo;\n  } else if (g[pkgId] === pkgBuildInfo) {\n  } else {\n    const msg = [\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\n      \"\",\n      \"Conflicts:\",\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\n    ].join(\"\\n\");\n    error(msg);\n  }\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\n    error(\n      [\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\n        \"\",\n        \"Conflicts:\",\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\n        `- ${pkgName} is at ${pkgVersion}`,\n        \"\",\n        \"Always upgrade all Liveblocks packages to the same version number.\"\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// src/lib/assert.ts\nfunction assertNever(_value, errmsg) {\n  throw new Error(errmsg);\n}\nfunction assert(condition, errmsg) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!condition) {\n      const err = new Error(errmsg);\n      err.name = \"Assertion failure\";\n      throw err;\n    }\n  }\n}\nfunction nn(value, errmsg = \"Expected value to be non-nullable\") {\n  assert(value !== null && value !== void 0, errmsg);\n  return value;\n}\n\n// src/lib/controlledPromise.ts\nfunction controlledPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return [promise, resolve, reject];\n}\nfunction Promise_withResolvers() {\n  const [promise, resolve, reject] = controlledPromise();\n  return { promise, resolve, reject };\n}\n\n// src/lib/EventSource.ts\nfunction makeEventSource() {\n  const _onetimeObservers = /* @__PURE__ */ new Set();\n  const _observers = /* @__PURE__ */ new Set();\n  let _buffer = null;\n  function pause() {\n    _buffer = [];\n  }\n  function unpause() {\n    if (_buffer === null) {\n      return;\n    }\n    for (const event of _buffer) {\n      notify(event);\n    }\n    _buffer = null;\n  }\n  function subscribe(callback) {\n    _observers.add(callback);\n    return () => _observers.delete(callback);\n  }\n  function subscribeOnce(callback) {\n    _onetimeObservers.add(callback);\n    return () => _onetimeObservers.delete(callback);\n  }\n  async function waitUntil(predicate) {\n    let unsub;\n    return new Promise((res) => {\n      unsub = subscribe((event) => {\n        if (predicate === void 0 || predicate(event)) {\n          res(event);\n        }\n      });\n    }).finally(() => _optionalChain([unsub, 'optionalCall', _2 => _2()]));\n  }\n  function notifyOrBuffer(event) {\n    if (_buffer !== null) {\n      _buffer.push(event);\n    } else {\n      notify(event);\n    }\n  }\n  function notify(event) {\n    _onetimeObservers.forEach((callback) => callback(event));\n    _onetimeObservers.clear();\n    _observers.forEach((callback) => callback(event));\n  }\n  function _forceClear() {\n    _onetimeObservers.clear();\n    _observers.clear();\n  }\n  function count() {\n    return _onetimeObservers.size + _observers.size;\n  }\n  return {\n    // Private/internal control over event emission\n    notify: notifyOrBuffer,\n    subscribe,\n    subscribeOnce,\n    _forceClear,\n    count,\n    waitUntil,\n    pause,\n    unpause,\n    // Publicly exposable subscription API\n    observable: {\n      subscribe,\n      subscribeOnce,\n      waitUntil\n    }\n  };\n}\n\n// src/lib/fancy-console.ts\nvar fancy_console_exports = {};\n__export(fancy_console_exports, {\n  error: () => error2,\n  errorWithTitle: () => errorWithTitle,\n  warn: () => warn,\n  warnWithTitle: () => warnWithTitle\n});\nvar badge = \"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\";\nvar bold = \"font-weight:600\";\nfunction wrap(method) {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (message, ...args) => console[method](\"%cLiveblocks\", badge, message, ...args)\n  );\n}\nvar warn = wrap(\"warn\");\nvar error2 = wrap(\"error\");\nfunction wrapWithTitle(method) {\n  return typeof window === \"undefined\" || process.env.NODE_ENV === \"test\" ? console[method] : (\n    /* istanbul ignore next */\n    (title, message, ...args) => console[method](\n      `%cLiveblocks%c ${title}`,\n      badge,\n      bold,\n      message,\n      ...args\n    )\n  );\n}\nvar warnWithTitle = wrapWithTitle(\"warn\");\nvar errorWithTitle = wrapWithTitle(\"error\");\n\n// src/lib/fsm.ts\nfunction distance(state1, state2) {\n  if (state1 === state2) {\n    return [0, 0];\n  }\n  const chunks1 = state1.split(\".\");\n  const chunks2 = state2.split(\".\");\n  const minLen = Math.min(chunks1.length, chunks2.length);\n  let shared = 0;\n  for (; shared < minLen; shared++) {\n    if (chunks1[shared] !== chunks2[shared]) {\n      break;\n    }\n  }\n  const up = chunks1.length - shared;\n  const down = chunks2.length - shared;\n  return [up, down];\n}\nfunction patterns(targetState, levels) {\n  const parts = targetState.split(\".\");\n  if (levels < 1 || levels > parts.length + 1) {\n    throw new Error(\"Invalid number of levels\");\n  }\n  const result = [];\n  if (levels > parts.length) {\n    result.push(\"*\");\n  }\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\n    const slice = parts.slice(0, i);\n    if (slice.length > 0) {\n      result.push(slice.join(\".\") + \".*\");\n    }\n  }\n  result.push(targetState);\n  return result;\n}\nvar SafeContext = class {\n  constructor(initialContext) {\n    this.curr = initialContext;\n  }\n  get current() {\n    return this.curr;\n  }\n  /**\n   * Call a callback function that allows patching of the context, by\n   * calling `context.patch()`. Patching is only allowed for the duration\n   * of this window.\n   */\n  allowPatching(callback) {\n    const self = this;\n    let allowed = true;\n    const patchableContext = {\n      ...this.curr,\n      patch(patch) {\n        if (allowed) {\n          self.curr = Object.assign({}, self.curr, patch);\n          for (const pair of Object.entries(patch)) {\n            const [key, value] = pair;\n            if (key !== \"patch\") {\n              this[key] = value;\n            }\n          }\n        } else {\n          throw new Error(\"Can no longer patch stale context\");\n        }\n      }\n    };\n    callback(patchableContext);\n    allowed = false;\n    return;\n  }\n};\nvar nextId = 1;\nvar FSM = class {\n  /**\n   * Returns the initial state, which is defined by the first call made to\n   * .addState().\n   */\n  get initialState() {\n    const result = this.states.values()[Symbol.iterator]().next();\n    if (result.done) {\n      throw new Error(\"No states defined yet\");\n    } else {\n      return result.value;\n    }\n  }\n  get currentState() {\n    if (this.currentStateOrNull === null) {\n      if (this.runningState === 0 /* NOT_STARTED_YET */) {\n        throw new Error(\"Not started yet\");\n      } else {\n        throw new Error(\"Already stopped\");\n      }\n    }\n    return this.currentStateOrNull;\n  }\n  /**\n   * Starts the machine by entering the initial state.\n   */\n  start() {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"State machine has already started\");\n    }\n    this.runningState = 1 /* STARTED */;\n    this.currentStateOrNull = this.initialState;\n    this.enter(null);\n    return this;\n  }\n  /**\n   * Stops the state machine. Stopping the state machine will call exit\n   * handlers for the current state, but not enter a new state.\n   */\n  stop() {\n    if (this.runningState !== 1 /* STARTED */) {\n      throw new Error(\"Cannot stop a state machine that hasn't started yet\");\n    }\n    this.exit(null);\n    this.runningState = 2 /* STOPPED */;\n    this.currentStateOrNull = null;\n  }\n  constructor(initialContext) {\n    this.id = nextId++;\n    this.runningState = 0 /* NOT_STARTED_YET */;\n    this.currentStateOrNull = null;\n    this.states = /* @__PURE__ */ new Set();\n    this.enterFns = /* @__PURE__ */ new Map();\n    this.cleanupStack = [];\n    this.knownEventTypes = /* @__PURE__ */ new Set();\n    this.allowedTransitions = /* @__PURE__ */ new Map();\n    this.currentContext = new SafeContext(initialContext);\n    this.eventHub = {\n      didReceiveEvent: makeEventSource(),\n      willTransition: makeEventSource(),\n      didIgnoreEvent: makeEventSource(),\n      willExitState: makeEventSource(),\n      didEnterState: makeEventSource()\n    };\n    this.events = {\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\n      willTransition: this.eventHub.willTransition.observable,\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\n      willExitState: this.eventHub.willExitState.observable,\n      didEnterState: this.eventHub.didEnterState.observable\n    };\n  }\n  get context() {\n    return this.currentContext.current;\n  }\n  /**\n   * Define an explicit finite state in the state machine.\n   */\n  addState(state) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    this.states.add(state);\n    return this;\n  }\n  onEnter(nameOrPattern, enterFn) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    } else if (this.enterFns.has(nameOrPattern)) {\n      throw new Error(\n        // TODO We _currently_ don't support multiple .onEnters() for the same\n        // state, but this is not a fundamental limitation. Just not\n        // implemented yet. If we wanted to, we could make this an array.\n        `enter/exit function for ${nameOrPattern} already exists`\n      );\n    }\n    this.enterFns.set(nameOrPattern, enterFn);\n    return this;\n  }\n  /**\n   * Defines a promise-based state. When the state is entered, the promise is\n   * created. When the promise resolves, the machine will transition to the\n   * provided `onOK` target state. When the promise rejects, the machine will\n   * transition to the `onError` target state.\n   *\n   * Optionally, a `maxTimeout` can be set. If the timeout happens before the\n   * promise is settled, then the machine will also transition to the `onError`\n   * target state.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param promiseFn       The callback to be invoked when the state is entered.\n   * @param onOK            The state to transition to when the promise resolves.\n   * @param onError         The state to transition to when the promise\n   *                        rejects, or when the timeout happens before the\n   *                        promise has been settled.\n   * @param maxTimeout      Optional timeout in milliseconds.\n   *\n   * When the promise callback function is invoked, it's provided with an\n   * AbortSignal (2nd argument).\n   * If a state transition happens while the promise is pending (for example,\n   * an event, or a timeout happens), then an abort signal will be used to\n   * indicate this. Implementers can use this abort signal to terminate the\n   * in-flight promise, or ignore its results, etc.\n   */\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError, maxTimeout) {\n    return this.onEnter(nameOrPattern, () => {\n      const abortController = new AbortController();\n      const signal = abortController.signal;\n      const timeoutId = maxTimeout ? setTimeout(() => {\n        const reason = new Error(\"Timed out\");\n        this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n      }, maxTimeout) : void 0;\n      let done = false;\n      void promiseFn(this.currentContext.current, signal).then(\n        // On OK\n        (data) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_OK\", data }, onOK);\n          }\n        },\n        // On Error\n        (reason) => {\n          if (!signal.aborted) {\n            done = true;\n            this.transition({ type: \"ASYNC_ERROR\", reason }, onError);\n          }\n        }\n      );\n      return () => {\n        clearTimeout(timeoutId);\n        if (!done) {\n          abortController.abort();\n        }\n      };\n    });\n  }\n  getStatesMatching(nameOrPattern) {\n    const matches = [];\n    if (nameOrPattern === \"*\") {\n      for (const state of this.states) {\n        matches.push(state);\n      }\n    } else if (nameOrPattern.endsWith(\".*\")) {\n      const prefix = nameOrPattern.slice(0, -1);\n      for (const state of this.states) {\n        if (state.startsWith(prefix)) {\n          matches.push(state);\n        }\n      }\n    } else {\n      const name = nameOrPattern;\n      if (this.states.has(name)) {\n        matches.push(name);\n      }\n    }\n    if (matches.length === 0) {\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\n    }\n    return matches;\n  }\n  /**\n   * Define all allowed outgoing transitions for a state.\n   *\n   * The targets for each event can be defined as a function which returns the\n   * next state to transition to. These functions can look at the `event` or\n   * `context` params to conditionally decide which next state to transition\n   * to.\n   *\n   * If you set it to `null`, then the transition will be explicitly forbidden\n   * and throw an error. If you don't define a target for a transition, then\n   * such events will get ignored.\n   */\n  addTransitions(nameOrPattern, mapping) {\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\n      throw new Error(\"Already started\");\n    }\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\n      let map = this.allowedTransitions.get(srcState);\n      if (map === void 0) {\n        map = /* @__PURE__ */ new Map();\n        this.allowedTransitions.set(srcState, map);\n      }\n      for (const [type, target_] of Object.entries(mapping)) {\n        if (map.has(type)) {\n          throw new Error(\n            `Trying to set transition \"${type}\" on \"${srcState}\" (via \"${nameOrPattern}\"), but a transition already exists there.`\n          );\n        }\n        const target = target_;\n        this.knownEventTypes.add(type);\n        if (target !== void 0) {\n          const targetFn = typeof target === \"function\" ? target : () => target;\n          map.set(type, targetFn);\n        }\n      }\n    }\n    return this;\n  }\n  /**\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\n   * timer fires.\n   *\n   * @param stateOrPattern  The state name, or state group pattern name.\n   * @param after           Number of milliseconds after which to take the\n   *                        transition. If in the mean time, another transition\n   *                        is taken, the timer will get cancelled.\n   * @param target          The target state to go to.\n   */\n  addTimedTransition(stateOrPattern, after2, target) {\n    return this.onEnter(stateOrPattern, () => {\n      const ms = typeof after2 === \"function\" ? after2(this.currentContext.current) : after2;\n      const timeoutID = setTimeout(() => {\n        this.transition({ type: \"TIMER\" }, target);\n      }, ms);\n      return () => {\n        clearTimeout(timeoutID);\n      };\n    });\n  }\n  getTargetFn(eventName) {\n    return _optionalChain([this, 'access', _3 => _3.allowedTransitions, 'access', _4 => _4.get, 'call', _5 => _5(this.currentState), 'optionalAccess', _6 => _6.get, 'call', _7 => _7(eventName)]);\n  }\n  /**\n   * Exits the current state, and executes any necessary cleanup functions.\n   * Call this before changing the current state to the next state.\n   *\n   * @param levels Defines how many \"levels\" of nesting will be\n   * exited. For example, if you transition from `foo.bar.qux` to\n   * `foo.bar.baz`, then the level is 1. But if you transition from\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\n   * If `null`, it will exit all levels.\n   */\n  exit(levels) {\n    this.eventHub.willExitState.notify(this.currentState);\n    this.currentContext.allowPatching((patchableContext) => {\n      levels = _nullishCoalesce(levels, () => ( this.cleanupStack.length));\n      for (let i = 0; i < levels; i++) {\n        _optionalChain([this, 'access', _8 => _8.cleanupStack, 'access', _9 => _9.pop, 'call', _10 => _10(), 'optionalCall', _11 => _11(patchableContext)]);\n      }\n    });\n  }\n  /**\n   * Enters the current state, and executes any necessary onEnter handlers.\n   * Call this directly _after_ setting the current state to the next state.\n   */\n  enter(levels) {\n    const enterPatterns = patterns(\n      this.currentState,\n      _nullishCoalesce(levels, () => ( this.currentState.split(\".\").length + 1))\n    );\n    this.currentContext.allowPatching((patchableContext) => {\n      for (const pattern of enterPatterns) {\n        const enterFn = this.enterFns.get(pattern);\n        const cleanupFn = _optionalChain([enterFn, 'optionalCall', _12 => _12(patchableContext)]);\n        if (typeof cleanupFn === \"function\") {\n          this.cleanupStack.push(cleanupFn);\n        } else {\n          this.cleanupStack.push(null);\n        }\n      }\n    });\n    this.eventHub.didEnterState.notify(this.currentState);\n  }\n  /**\n   * Sends an event to the machine, which may cause an internal state\n   * transition to happen. When that happens, will trigger side effects.\n   */\n  send(event) {\n    if (!this.knownEventTypes.has(event.type)) {\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\n    }\n    if (this.runningState === 2 /* STOPPED */) {\n      return;\n    }\n    const targetFn = this.getTargetFn(event.type);\n    if (targetFn !== void 0) {\n      return this.transition(event, targetFn);\n    } else {\n      this.eventHub.didIgnoreEvent.notify(event);\n    }\n  }\n  transition(event, target) {\n    this.eventHub.didReceiveEvent.notify(event);\n    const oldState = this.currentState;\n    const targetFn = typeof target === \"function\" ? target : () => target;\n    const nextTarget = targetFn(event, this.currentContext.current);\n    let nextState;\n    let effects = void 0;\n    if (nextTarget === null) {\n      this.eventHub.didIgnoreEvent.notify(event);\n      return;\n    }\n    if (typeof nextTarget === \"string\") {\n      nextState = nextTarget;\n    } else {\n      nextState = nextTarget.target;\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\n    }\n    if (!this.states.has(nextState)) {\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\n    }\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\n    const [up, down] = distance(this.currentState, nextState);\n    if (up > 0) {\n      this.exit(up);\n    }\n    this.currentStateOrNull = nextState;\n    if (effects !== void 0) {\n      const effectsToRun = effects;\n      this.currentContext.allowPatching((patchableContext) => {\n        for (const effect of effectsToRun) {\n          if (typeof effect === \"function\") {\n            effect(patchableContext, event);\n          } else {\n            patchableContext.patch(effect);\n          }\n        }\n      });\n    }\n    if (down > 0) {\n      this.enter(down);\n    }\n  }\n};\n\n// src/lib/utils.ts\nfunction raise(msg) {\n  throw new Error(msg);\n}\nfunction isPlainObject(blob) {\n  return blob !== null && typeof blob === \"object\" && Object.prototype.toString.call(blob) === \"[object Object]\";\n}\nfunction entries(obj) {\n  return Object.entries(obj);\n}\nfunction mapValues(obj, mapFn) {\n  const result = {};\n  for (const pair of Object.entries(obj)) {\n    const key = pair[0];\n    if (key === \"__proto__\") {\n      continue;\n    }\n    const value = pair[1];\n    result[key] = mapFn(value, key);\n  }\n  return result;\n}\nfunction tryParseJson(rawMessage) {\n  try {\n    return JSON.parse(rawMessage);\n  } catch (e) {\n    return void 0;\n  }\n}\nfunction deepClone(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction b64decode(b64value) {\n  try {\n    const formattedValue = b64value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const decodedValue = decodeURIComponent(\n      atob(formattedValue).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\")\n    );\n    return decodedValue;\n  } catch (err) {\n    return atob(b64value);\n  }\n}\nfunction compact(items) {\n  return items.filter(\n    (item) => item !== null && item !== void 0\n  );\n}\nfunction compactObject(obj) {\n  const newObj = { ...obj };\n  Object.keys(obj).forEach((k) => {\n    const key = k;\n    if (newObj[key] === void 0) {\n      delete newObj[key];\n    }\n  });\n  return newObj;\n}\nfunction wait(millis) {\n  return new Promise((res) => setTimeout(res, millis));\n}\nasync function withTimeout(promise, millis, errmsg) {\n  let timerID;\n  const timer$ = new Promise((_, reject) => {\n    timerID = setTimeout(() => {\n      reject(new Error(errmsg));\n    }, millis);\n  });\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\n}\nfunction memoizeOnSuccess(factoryFn) {\n  let cached = null;\n  return () => {\n    if (cached === null) {\n      cached = factoryFn().catch((err) => {\n        setTimeout(() => {\n          cached = null;\n        }, 5e3);\n        throw err;\n      });\n    }\n    return cached;\n  };\n}\n\n// src/protocol/ServerMsg.ts\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_JOINED\"] = 101] = \"USER_JOINED\";\n  ServerMsgCode2[ServerMsgCode2[\"USER_LEFT\"] = 102] = \"USER_LEFT\";\n  ServerMsgCode2[ServerMsgCode2[\"BROADCASTED_EVENT\"] = 103] = \"BROADCASTED_EVENT\";\n  ServerMsgCode2[ServerMsgCode2[\"ROOM_STATE\"] = 104] = \"ROOM_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"INITIAL_STORAGE_STATE\"] = 200] = \"INITIAL_STORAGE_STATE\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ServerMsgCode2[ServerMsgCode2[\"REJECT_STORAGE_OP\"] = 299] = \"REJECT_STORAGE_OP\";\n  ServerMsgCode2[ServerMsgCode2[\"UPDATE_YDOC\"] = 300] = \"UPDATE_YDOC\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_CREATED\"] = 400] = \"THREAD_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_DELETED\"] = 407] = \"THREAD_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_METADATA_UPDATED\"] = 401] = \"THREAD_METADATA_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"THREAD_UPDATED\"] = 408] = \"THREAD_UPDATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_CREATED\"] = 402] = \"COMMENT_CREATED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_EDITED\"] = 403] = \"COMMENT_EDITED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_DELETED\"] = 404] = \"COMMENT_DELETED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_ADDED\"] = 405] = \"COMMENT_REACTION_ADDED\";\n  ServerMsgCode2[ServerMsgCode2[\"COMMENT_REACTION_REMOVED\"] = 406] = \"COMMENT_REACTION_REMOVED\";\n  return ServerMsgCode2;\n})(ServerMsgCode || {});\n\n// src/types/IWebSocket.ts\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_NORMAL\"] = 1e3] = \"CLOSE_NORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"UNEXPECTED_CONDITION\"] = 1011] = \"UNEXPECTED_CONDITION\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TRY_AGAIN_LATER\"] = 1013] = \"TRY_AGAIN_LATER\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"INVALID_MESSAGE_FORMAT\"] = 4e3] = \"INVALID_MESSAGE_FORMAT\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"ROOM_ID_UPDATED\"] = 4006] = \"ROOM_ID_UPDATED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"KICKED\"] = 4100] = \"KICKED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"TOKEN_EXPIRED\"] = 4109] = \"TOKEN_EXPIRED\";\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\"CLOSE_WITHOUT_RETRY\"] = 4999] = \"CLOSE_WITHOUT_RETRY\";\n  return WebsocketCloseCodes2;\n})(WebsocketCloseCodes || {});\nfunction shouldDisconnect(code) {\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\n}\nfunction shouldReauth(code) {\n  return code >= 4100 && code < 4200;\n}\nfunction shouldRetryWithoutReauth(code) {\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\n}\n\n// src/connection.ts\nfunction isIdle(status) {\n  return status === \"initial\" || status === \"disconnected\";\n}\nfunction toNewConnectionStatus(machine) {\n  const state = machine.currentState;\n  switch (state) {\n    case \"@ok.connected\":\n    case \"@ok.awaiting-pong\":\n      return \"connected\";\n    case \"@idle.initial\":\n      return \"initial\";\n    case \"@auth.busy\":\n    case \"@auth.backoff\":\n    case \"@connecting.busy\":\n    case \"@connecting.backoff\":\n    case \"@idle.zombie\":\n      return machine.context.successCount > 0 ? \"reconnecting\" : \"connecting\";\n    case \"@idle.failed\":\n      return \"disconnected\";\n    default:\n      return assertNever(state, \"Unknown state\");\n  }\n}\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\nvar HEARTBEAT_INTERVAL = 3e4;\nvar PONG_TIMEOUT = 2e3;\nvar AUTH_TIMEOUT = 1e4;\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\nvar StopRetrying = class extends Error {\n  constructor(reason) {\n    super(reason);\n  }\n};\nvar LiveblocksError = class extends Error {\n  /** @internal */\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n};\nfunction nextBackoffDelay(currentDelay, delays) {\n  return _nullishCoalesce(delays.find((delay) => delay > currentDelay), () => ( delays[delays.length - 1]));\n}\nfunction increaseBackoffDelay(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\n  });\n}\nfunction increaseBackoffDelayAggressively(context) {\n  context.patch({\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\n  });\n}\nfunction resetSuccessCount(context) {\n  context.patch({ successCount: 0 });\n}\nfunction log(level, message) {\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\n    /* black hole */\n    () => {\n    }\n  );\n  return () => {\n    logger(message);\n  };\n}\nfunction logPrematureErrorOrCloseEvent(e) {\n  const conn = \"Connection to Liveblocks websocket server\";\n  return (ctx) => {\n    if (e instanceof Error) {\n      warn(`${conn} could not be established. ${String(e)}`);\n    } else {\n      warn(\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\n      );\n    }\n  };\n}\nfunction logCloseEvent(event) {\n  const details = [`code: ${event.code}`];\n  if (event.reason) {\n    details.push(`reason: ${event.reason}`);\n  }\n  return (ctx) => {\n    warn(\n      `Connection to Liveblocks websocket server closed (${details.join(\", \")}). Retrying in ${ctx.backoffDelay}ms.`\n    );\n  };\n}\nvar logPermanentClose = log(\n  1 /* WARN */,\n  \"Connection to WebSocket closed permanently. Won't retry.\"\n);\nfunction isCloseEvent(error3) {\n  return !(error3 instanceof Error) && error3.type === \"close\";\n}\nfunction enableTracing(machine) {\n  const start = (/* @__PURE__ */ new Date()).getTime();\n  function log2(...args) {\n    warn(\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\n      ...args\n    );\n  }\n  const unsubs = [\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\n    machine.events.willTransition.subscribe(\n      ({ from, to }) => log2(\"Transitioning\", from, \"\\u2192\", to)\n    ),\n    machine.events.didIgnoreEvent.subscribe(\n      (e) => log2(\"Ignored event\", e.type, e, \"(current state won't handle it)\")\n    )\n    // machine.events.willExitState.subscribe((s) => log(\"Exiting state\", s)),\n    // machine.events.didEnterState.subscribe((s) => log(\"Entering state\", s)),\n  ];\n  return () => {\n    for (const unsub of unsubs) {\n      unsub();\n    }\n  };\n}\nfunction defineConnectivityEvents(machine) {\n  const statusDidChange = makeEventSource();\n  const didConnect = makeEventSource();\n  const didDisconnect = makeEventSource();\n  let lastStatus = null;\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\n    const currStatus = toNewConnectionStatus(machine);\n    if (currStatus !== lastStatus) {\n      statusDidChange.notify(currStatus);\n    }\n    if (lastStatus === \"connected\" && currStatus !== \"connected\") {\n      didDisconnect.notify();\n    } else if (lastStatus !== \"connected\" && currStatus === \"connected\") {\n      didConnect.notify();\n    }\n    lastStatus = currStatus;\n  });\n  return {\n    statusDidChange: statusDidChange.observable,\n    didConnect: didConnect.observable,\n    didDisconnect: didDisconnect.observable,\n    unsubscribe\n  };\n}\nvar assign = (patch) => (ctx) => ctx.patch(patch);\nfunction createConnectionStateMachine(delegates, options) {\n  const onMessage = makeEventSource();\n  onMessage.pause();\n  const onLiveblocksError = makeEventSource();\n  function fireErrorEvent(errmsg, errcode) {\n    return () => {\n      const err = new LiveblocksError(errmsg, errcode);\n      onLiveblocksError.notify(err);\n    };\n  }\n  const initialContext = {\n    successCount: 0,\n    authValue: null,\n    socket: null,\n    backoffDelay: RESET_DELAY\n  };\n  const machine = new FSM(initialContext).addState(\"@idle.initial\").addState(\"@idle.failed\").addState(\"@idle.zombie\").addState(\"@auth.busy\").addState(\"@auth.backoff\").addState(\"@connecting.busy\").addState(\"@connecting.backoff\").addState(\"@ok.connected\").addState(\"@ok.awaiting-pong\");\n  machine.addTransitions(\"*\", {\n    RECONNECT: {\n      target: \"@auth.backoff\",\n      effect: [increaseBackoffDelay, resetSuccessCount]\n    },\n    DISCONNECT: \"@idle.initial\"\n  });\n  machine.onEnter(\"@idle.*\", resetSuccessCount).addTransitions(\"@idle.*\", {\n    CONNECT: (_, ctx) => (\n      // If we still have a known authValue, try to reconnect to the socket directly,\n      // otherwise, try to obtain a new authValue\n      ctx.authValue !== null ? \"@connecting.busy\" : \"@auth.busy\"\n    )\n  });\n  machine.addTransitions(\"@auth.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@auth.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@auth.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@auth.busy\"\n  ).onEnterAsync(\n    \"@auth.busy\",\n    () => withTimeout(\n      delegates.authenticate(),\n      AUTH_TIMEOUT,\n      \"Timed out during auth\"\n    ),\n    // On successful authentication\n    (okEvent) => ({\n      target: \"@connecting.busy\",\n      effect: assign({\n        authValue: okEvent.data\n      })\n    }),\n    // Auth failed\n    (failedEvent) => {\n      if (failedEvent.reason instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, failedEvent.reason.message),\n            fireErrorEvent(failedEvent.reason.message, -1)\n          ]\n        };\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [\n          increaseBackoffDelay,\n          log(\n            2 /* ERROR */,\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\n          )\n        ]\n      };\n    }\n  );\n  const onSocketError = (event) => machine.send({ type: \"EXPLICIT_SOCKET_ERROR\", event });\n  const onSocketClose = (event) => machine.send({ type: \"EXPLICIT_SOCKET_CLOSE\", event });\n  const onSocketMessage = (event) => event.data === \"pong\" ? machine.send({ type: \"PONG\" }) : onMessage.notify(event);\n  function teardownSocket(socket) {\n    if (socket) {\n      socket.removeEventListener(\"error\", onSocketError);\n      socket.removeEventListener(\"close\", onSocketClose);\n      socket.removeEventListener(\"message\", onSocketMessage);\n      socket.close();\n    }\n  }\n  machine.addTransitions(\"@connecting.backoff\", {\n    NAVIGATOR_ONLINE: {\n      target: \"@connecting.busy\",\n      effect: assign({ backoffDelay: RESET_DELAY })\n    }\n  }).addTimedTransition(\n    \"@connecting.backoff\",\n    (ctx) => ctx.backoffDelay,\n    \"@connecting.busy\"\n  ).onEnterAsync(\n    \"@connecting.busy\",\n    //\n    // Use the \"createSocket\" delegate function (provided to the\n    // ManagedSocket) to create the actual WebSocket connection instance.\n    // Then, set up all the necessary event listeners, and wait for the\n    // \"open\" event to occur.\n    //\n    // When the \"open\" event happens, we're ready to transition to the\n    // OK state. This is done by resolving the Promise.\n    //\n    async (ctx, signal) => {\n      let capturedPrematureEvent = null;\n      let unconfirmedSocket = null;\n      const connect$ = new Promise(\n        (resolve, rej) => {\n          if (ctx.authValue === null) {\n            throw new Error(\"No auth authValue\");\n          }\n          const socket = delegates.createSocket(ctx.authValue);\n          unconfirmedSocket = socket;\n          function reject(event) {\n            capturedPrematureEvent = event;\n            socket.removeEventListener(\"message\", onSocketMessage);\n            rej(event);\n          }\n          const [actor$, didReceiveActor] = controlledPromise();\n          if (!options.waitForActorId) {\n            didReceiveActor();\n          }\n          function waitForActorId(event) {\n            const serverMsg = tryParseJson(event.data);\n            if (_optionalChain([serverMsg, 'optionalAccess', _13 => _13.type]) === 104 /* ROOM_STATE */) {\n              didReceiveActor();\n            }\n          }\n          socket.addEventListener(\"message\", onSocketMessage);\n          if (options.waitForActorId) {\n            socket.addEventListener(\"message\", waitForActorId);\n          }\n          socket.addEventListener(\"error\", reject);\n          socket.addEventListener(\"close\", reject);\n          socket.addEventListener(\"open\", () => {\n            socket.addEventListener(\"error\", onSocketError);\n            socket.addEventListener(\"close\", onSocketClose);\n            const unsub = () => {\n              socket.removeEventListener(\"error\", reject);\n              socket.removeEventListener(\"close\", reject);\n              socket.removeEventListener(\"message\", waitForActorId);\n            };\n            void actor$.then(() => {\n              resolve([socket, unsub]);\n            });\n          });\n        }\n      );\n      return withTimeout(\n        connect$,\n        SOCKET_CONNECT_TIMEOUT,\n        \"Timed out during websocket connection\"\n      ).then(\n        //\n        // Part 3:\n        // By now, our \"open\" event has fired, and the promise has been\n        // resolved. Two possible scenarios:\n        //\n        // 1. The happy path. Most likely.\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\n        //    reject the promise after all.\n        //\n        // Any close/error event that will get scheduled after this point\n        // onwards, will be caught in the OK state, and dealt with\n        // accordingly.\n        //\n        ([socket, unsub]) => {\n          unsub();\n          if (signal.aborted) {\n            throw new Error(\"Aborted\");\n          }\n          if (capturedPrematureEvent) {\n            throw capturedPrematureEvent;\n          }\n          return socket;\n        }\n      ).catch((e) => {\n        teardownSocket(unconfirmedSocket);\n        throw e;\n      });\n    },\n    // Only transition to OK state after a successfully opened WebSocket connection\n    (okEvent) => ({\n      target: \"@ok.connected\",\n      effect: assign({\n        socket: okEvent.data,\n        backoffDelay: RESET_DELAY\n      })\n    }),\n    // If the WebSocket connection cannot be established\n    (failure) => {\n      const err = failure.reason;\n      if (err instanceof StopRetrying) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            log(2 /* ERROR */, err.message),\n            fireErrorEvent(err.message, -1)\n          ]\n        };\n      }\n      if (isCloseEvent(err)) {\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        }\n        if (shouldRetryWithoutReauth(err.code)) {\n          return {\n            target: \"@connecting.backoff\",\n            effect: [\n              increaseBackoffDelayAggressively,\n              logPrematureErrorOrCloseEvent(err)\n            ]\n          };\n        }\n        if (shouldDisconnect(err.code)) {\n          return {\n            target: \"@idle.failed\",\n            effect: [\n              log(2 /* ERROR */, err.reason),\n              fireErrorEvent(err.reason, err.code)\n            ]\n          };\n        }\n      }\n      return {\n        target: \"@auth.backoff\",\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\n      };\n    }\n  );\n  const sendHeartbeat = {\n    target: \"@ok.awaiting-pong\",\n    effect: (ctx) => {\n      _optionalChain([ctx, 'access', _14 => _14.socket, 'optionalAccess', _15 => _15.send, 'call', _16 => _16(\"ping\")]);\n    }\n  };\n  const maybeHeartbeat = () => {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const canZombie = _optionalChain([doc, 'optionalAccess', _17 => _17.visibilityState]) === \"hidden\" && delegates.canZombie();\n    return canZombie ? \"@idle.zombie\" : sendHeartbeat;\n  };\n  machine.addTimedTransition(\"@ok.connected\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\"@ok.connected\", {\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\n    WINDOW_GOT_FOCUS: sendHeartbeat\n  });\n  machine.addTransitions(\"@idle.zombie\", {\n    WINDOW_GOT_FOCUS: \"@connecting.backoff\"\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\n  });\n  machine.onEnter(\"@ok.*\", (ctx) => {\n    ctx.patch({ successCount: ctx.successCount + 1 });\n    const timerID = setTimeout(\n      // On the next tick, start delivering all messages that have already\n      // been received, and continue synchronous delivery of all future\n      // incoming messages.\n      onMessage.unpause,\n      0\n    );\n    return (ctx2) => {\n      teardownSocket(ctx2.socket);\n      ctx2.patch({ socket: null });\n      clearTimeout(timerID);\n      onMessage.pause();\n    };\n  }).addTransitions(\"@ok.awaiting-pong\", { PONG: \"@ok.connected\" }).addTimedTransition(\"@ok.awaiting-pong\", PONG_TIMEOUT, {\n    target: \"@connecting.busy\",\n    // Log implicit connection loss and drop the current open socket\n    effect: log(\n      1 /* WARN */,\n      \"Received no pong from server, assume implicit connection loss.\"\n    )\n  }).addTransitions(\"@ok.*\", {\n    // When a socket receives an error, this can cause the closing of the\n    // socket, or not. So always check to see if the socket is still OPEN or\n    // not. When still OPEN, don't transition.\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\n      if (_optionalChain([context, 'access', _18 => _18.socket, 'optionalAccess', _19 => _19.readyState]) === 1) {\n        return null;\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: increaseBackoffDelay\n      };\n    },\n    EXPLICIT_SOCKET_CLOSE: (e) => {\n      if (shouldDisconnect(e.event.code)) {\n        return {\n          target: \"@idle.failed\",\n          effect: [\n            logPermanentClose,\n            fireErrorEvent(e.event.reason, e.event.code)\n          ]\n        };\n      }\n      if (shouldReauth(e.event.code)) {\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\n          return \"@auth.busy\";\n        } else {\n          return {\n            target: \"@auth.backoff\",\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n          };\n        }\n      }\n      if (shouldRetryWithoutReauth(e.event.code)) {\n        return {\n          target: \"@connecting.backoff\",\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\n        };\n      }\n      return {\n        target: \"@connecting.backoff\",\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\n      };\n    }\n  });\n  if (typeof document !== \"undefined\") {\n    const doc = typeof document !== \"undefined\" ? document : void 0;\n    const win = typeof window !== \"undefined\" ? window : void 0;\n    const root = _nullishCoalesce(win, () => ( doc));\n    machine.onEnter(\"*\", (ctx) => {\n      function onNetworkOffline() {\n        machine.send({ type: \"NAVIGATOR_OFFLINE\" });\n      }\n      function onNetworkBackOnline() {\n        machine.send({ type: \"NAVIGATOR_ONLINE\" });\n      }\n      function onVisibilityChange() {\n        if (_optionalChain([doc, 'optionalAccess', _20 => _20.visibilityState]) === \"visible\") {\n          machine.send({ type: \"WINDOW_GOT_FOCUS\" });\n        }\n      }\n      _optionalChain([win, 'optionalAccess', _21 => _21.addEventListener, 'call', _22 => _22(\"online\", onNetworkBackOnline)]);\n      _optionalChain([win, 'optionalAccess', _23 => _23.addEventListener, 'call', _24 => _24(\"offline\", onNetworkOffline)]);\n      _optionalChain([root, 'optionalAccess', _25 => _25.addEventListener, 'call', _26 => _26(\"visibilitychange\", onVisibilityChange)]);\n      return () => {\n        _optionalChain([root, 'optionalAccess', _27 => _27.removeEventListener, 'call', _28 => _28(\"visibilitychange\", onVisibilityChange)]);\n        _optionalChain([win, 'optionalAccess', _29 => _29.removeEventListener, 'call', _30 => _30(\"online\", onNetworkBackOnline)]);\n        _optionalChain([win, 'optionalAccess', _31 => _31.removeEventListener, 'call', _32 => _32(\"offline\", onNetworkOffline)]);\n        teardownSocket(ctx.socket);\n      };\n    });\n  }\n  const cleanups = [];\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\n  cleanups.push(unsubscribe);\n  if (options.enableDebugLogging) {\n    cleanups.push(enableTracing(machine));\n  }\n  machine.start();\n  return {\n    machine,\n    cleanups,\n    // Observable events that will be emitted by this machine\n    events: {\n      statusDidChange,\n      didConnect,\n      didDisconnect,\n      onMessage: onMessage.observable,\n      onLiveblocksError: onLiveblocksError.observable\n    }\n  };\n}\nvar ManagedSocket = class {\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\n    const { machine, events, cleanups } = createConnectionStateMachine(\n      delegates,\n      { waitForActorId, enableDebugLogging }\n    );\n    this.machine = machine;\n    this.events = events;\n    this.cleanups = cleanups;\n  }\n  getStatus() {\n    try {\n      return toNewConnectionStatus(this.machine);\n    } catch (e2) {\n      return \"initial\";\n    }\n  }\n  /**\n   * Returns the current auth authValue.\n   */\n  get authValue() {\n    return this.machine.context.authValue;\n  }\n  /**\n   * Call this method to try to connect to a WebSocket. This only has an effect\n   * if the machine is idle at the moment, otherwise this is a no-op.\n   */\n  connect() {\n    this.machine.send({ type: \"CONNECT\" });\n  }\n  /**\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\n   * the socket, potentially obtaining a new authValue first, if needed.\n   */\n  reconnect() {\n    this.machine.send({ type: \"RECONNECT\" });\n  }\n  /**\n   * Call this method to disconnect from the current WebSocket. Is going to be\n   * a no-op if there is no active connection.\n   */\n  disconnect() {\n    this.machine.send({ type: \"DISCONNECT\" });\n  }\n  /**\n   * Call this to stop the machine and run necessary cleanup functions. After\n   * calling destroy(), you can no longer use this instance. Call this before\n   * letting the instance get garbage collected.\n   */\n  destroy() {\n    this.machine.stop();\n    let cleanup;\n    while (cleanup = this.cleanups.pop()) {\n      cleanup();\n    }\n  }\n  /**\n   * Safely send a message to the current WebSocket connection. Will emit a log\n   * message if this is somehow impossible.\n   */\n  send(data) {\n    const socket = _optionalChain([this, 'access', _33 => _33.machine, 'access', _34 => _34.context, 'optionalAccess', _35 => _35.socket]);\n    if (socket === null) {\n      warn(\"Cannot send: not connected yet\", data);\n    } else if (socket.readyState !== 1) {\n      warn(\"Cannot send: WebSocket no longer open\", data);\n    } else {\n      socket.send(data);\n    }\n  }\n  /**\n   * NOTE: Used by the E2E app only, to simulate explicit events.\n   * Not ideal to keep exposed :(\n   */\n  _privateSendMachineEvent(event) {\n    this.machine.send(event);\n  }\n};\n\n// src/protocol/AuthToken.ts\nfunction canWriteStorage(scopes) {\n  return scopes.includes(\"room:write\" /* Write */);\n}\nfunction canComment(scopes) {\n  return scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:write\" /* Write */);\n}\nfunction isValidAuthTokenPayload(data) {\n  return isPlainObject(data) && (data.k === \"acc\" /* ACCESS_TOKEN */ || data.k === \"id\" /* ID_TOKEN */ || data.k === \"sec-legacy\" /* SECRET_LEGACY */);\n}\nfunction parseAuthToken(rawTokenString) {\n  const tokenParts = rawTokenString.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new Error(\"Authentication error: invalid JWT token\");\n  }\n  const payload = tryParseJson(b64decode(tokenParts[1]));\n  if (!(payload && isValidAuthTokenPayload(payload))) {\n    throw new Error(\n      \"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\"\n    );\n  }\n  return {\n    raw: rawTokenString,\n    parsed: payload\n  };\n}\n\n// src/auth-manager.ts\nfunction createAuthManager(authOptions) {\n  const authentication = prepareAuthentication(authOptions);\n  const seenTokens = /* @__PURE__ */ new Set();\n  const tokens = [];\n  const expiryTimes = [];\n  const requestPromises = /* @__PURE__ */ new Map();\n  function reset() {\n    seenTokens.clear();\n    tokens.length = 0;\n    expiryTimes.length = 0;\n    requestPromises.clear();\n  }\n  function hasCorrespondingScopes(requestedScope, scopes) {\n    if (requestedScope === \"comments:read\") {\n      return scopes.includes(\"comments:read\" /* CommentsRead */) || scopes.includes(\"comments:write\" /* CommentsWrite */) || scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    } else if (requestedScope === \"room:read\") {\n      return scopes.includes(\"room:read\" /* Read */) || scopes.includes(\"room:write\" /* Write */);\n    }\n    return false;\n  }\n  function getCachedToken(requestOptions) {\n    const now = Math.ceil(Date.now() / 1e3);\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const token = tokens[i];\n      const expiresAt = expiryTimes[i];\n      if (expiresAt <= now) {\n        tokens.splice(i, 1);\n        expiryTimes.splice(i, 1);\n        continue;\n      }\n      if (token.parsed.k === \"id\" /* ID_TOKEN */) {\n        return token;\n      } else if (token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\n          return token;\n        }\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\n          if (!requestOptions.roomId) {\n            if (resource.includes(\"*\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n              return token;\n            }\n          } else if (resource.includes(\"*\") && requestOptions.roomId.startsWith(resource.replace(\"*\", \"\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\n            return token;\n          }\n        }\n      }\n    }\n    return void 0;\n  }\n  async function makeAuthRequest(options) {\n    const fetcher = _nullishCoalesce(_optionalChain([authOptions, 'access', _36 => _36.polyfills, 'optionalAccess', _37 => _37.fetch]), () => ( (typeof window === \"undefined\" ? void 0 : window.fetch)));\n    if (authentication.type === \"private\") {\n      if (fetcher === void 0) {\n        throw new StopRetrying(\n          \"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\"\n        );\n      }\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\n        room: options.roomId\n      });\n      const parsed = parseAuthToken(response.token);\n      if (seenTokens.has(parsed.raw)) {\n        throw new StopRetrying(\n          \"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\"\n        );\n      }\n      return parsed;\n    }\n    if (authentication.type === \"custom\") {\n      const response = await authentication.callback(options.roomId);\n      if (response && typeof response === \"object\") {\n        if (typeof response.token === \"string\") {\n          const parsed = parseAuthToken(response.token);\n          return parsed;\n        } else if (typeof response.error === \"string\") {\n          const reason = `Authentication failed: ${\"reason\" in response && typeof response.reason === \"string\" ? response.reason : \"Forbidden\"}`;\n          if (response.error === \"forbidden\") {\n            throw new StopRetrying(reason);\n          } else {\n            throw new Error(reason);\n          }\n        }\n      }\n      throw new Error(\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \"...\" }'\n      );\n    }\n    throw new Error(\n      \"Unexpected authentication type. Must be private or custom.\"\n    );\n  }\n  async function getAuthValue(requestOptions) {\n    if (authentication.type === \"public\") {\n      return { type: \"public\", publicApiKey: authentication.publicApiKey };\n    }\n    const cachedToken = getCachedToken(requestOptions);\n    if (cachedToken !== void 0) {\n      return { type: \"secret\", token: cachedToken };\n    }\n    let currentPromise;\n    if (requestOptions.roomId) {\n      currentPromise = requestPromises.get(requestOptions.roomId);\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(requestOptions.roomId, currentPromise);\n      }\n    } else {\n      currentPromise = requestPromises.get(\"liveblocks-user-token\");\n      if (currentPromise === void 0) {\n        currentPromise = makeAuthRequest(requestOptions);\n        requestPromises.set(\"liveblocks-user-token\", currentPromise);\n      }\n    }\n    try {\n      const token = await currentPromise;\n      const BUFFER = 30;\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\n      seenTokens.add(token.raw);\n      if (token.parsed.k !== \"sec-legacy\" /* SECRET_LEGACY */) {\n        tokens.push(token);\n        expiryTimes.push(expiresAt);\n      }\n      return { type: \"secret\", token };\n    } finally {\n      if (requestOptions.roomId) {\n        requestPromises.delete(requestOptions.roomId);\n      } else {\n        requestPromises.delete(\"liveblocks-user-token\");\n      }\n    }\n  }\n  return {\n    reset,\n    getAuthValue\n  };\n}\nfunction prepareAuthentication(authOptions) {\n  const { publicApiKey, authEndpoint } = authOptions;\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\n    throw new Error(\n      \"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n    );\n  }\n  if (typeof publicApiKey === \"string\") {\n    if (publicApiKey.startsWith(\"sk_\")) {\n      throw new Error(\n        \"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    } else if (!publicApiKey.startsWith(\"pk_\")) {\n      throw new Error(\n        \"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\"\n      );\n    }\n    return {\n      type: \"public\",\n      publicApiKey\n    };\n  }\n  if (typeof authEndpoint === \"string\") {\n    return {\n      type: \"private\",\n      url: authEndpoint\n    };\n  } else if (typeof authEndpoint === \"function\") {\n    return {\n      type: \"custom\",\n      callback: authEndpoint\n    };\n  } else if (authEndpoint !== void 0) {\n    throw new Error(\n      \"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\"\n    );\n  }\n  throw new Error(\n    \"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\"\n  );\n}\nasync function fetchAuthEndpoint(fetch, endpoint, body) {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(body)\n  });\n  if (!res.ok) {\n    const reason = `${(await res.text()).trim() || \"reason not provided in auth response\"} (${res.status} returned by POST ${endpoint})`;\n    if (res.status === 401 || res.status === 403) {\n      throw new StopRetrying(`Unauthorized: ${reason}`);\n    } else {\n      throw new Error(`Failed to authenticate: ${reason}`);\n    }\n  }\n  let data;\n  try {\n    data = await res.json();\n  } catch (er) {\n    throw new Error(\n      `Expected a JSON response when doing a POST request on \"${endpoint}\". ${String(\n        er\n      )}`\n    );\n  }\n  if (!isPlainObject(data) || typeof data.token !== \"string\") {\n    throw new Error(\n      `Expected a JSON response of the form \\`{ token: \"...\" }\\` when doing a POST request on \"${endpoint}\", but got ${JSON.stringify(\n        data\n      )}`\n    );\n  }\n  const { token } = data;\n  return { token };\n}\n\n// src/constants.ts\nvar DEFAULT_BASE_URL = \"https://api.liveblocks.io\";\n\n// src/internal.ts\nvar kInternal = Symbol();\n\n// src/devtools/bridge.ts\nvar _bridgeActive = false;\nfunction activateBridge(allowed) {\n  _bridgeActive = allowed;\n}\nfunction sendToPanel(message, options) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  const fullMsg = {\n    ...message,\n    source: \"liveblocks-devtools-client\"\n  };\n  if (!(_optionalChain([options, 'optionalAccess', _38 => _38.force]) || _bridgeActive)) {\n    return;\n  }\n  window.postMessage(fullMsg, \"*\");\n}\nvar eventSource = makeEventSource();\nif (process.env.NODE_ENV !== \"production\" && typeof window !== \"undefined\") {\n  window.addEventListener(\"message\", (event) => {\n    if (event.source === window && _optionalChain([event, 'access', _39 => _39.data, 'optionalAccess', _40 => _40.source]) === \"liveblocks-devtools-panel\") {\n      eventSource.notify(event.data);\n    } else {\n    }\n  });\n}\nvar onMessageFromPanel = eventSource.observable;\n\n// src/devtools/index.ts\nvar VERSION = PKG_VERSION || \"dev\";\nvar _devtoolsSetupHasRun = false;\nfunction setupDevTools(getAllRooms) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  if (_devtoolsSetupHasRun) {\n    return;\n  }\n  _devtoolsSetupHasRun = true;\n  onMessageFromPanel.subscribe((msg) => {\n    switch (msg.msg) {\n      case \"connect\": {\n        activateBridge(true);\n        for (const roomId of getAllRooms()) {\n          sendToPanel({\n            msg: \"room::available\",\n            roomId,\n            clientVersion: VERSION\n          });\n        }\n        break;\n      }\n    }\n  });\n  sendToPanel({ msg: \"wake-up-devtools\" }, { force: true });\n}\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\nfunction stopSyncStream(roomId) {\n  const unsubs = _nullishCoalesce(unsubsByRoomId.get(roomId), () => ( []));\n  unsubsByRoomId.delete(roomId);\n  for (const unsub of unsubs) {\n    unsub();\n  }\n}\nfunction startSyncStream(room) {\n  stopSyncStream(room.id);\n  fullSync(room);\n  unsubsByRoomId.set(room.id, [\n    // When the connection status changes\n    room.events.status.subscribe(() => partialSyncConnection(room)),\n    // When storage initializes, send the update\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\n    // Any time storage updates, send the new storage root\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\n    // Any time \"me\" or \"others\" updates, send the new values accordingly\n    room.events.self.subscribe(() => partialSyncMe(room)),\n    room.events.others.subscribe(() => partialSyncOthers(room)),\n    // Any time ydoc is updated, forward the update\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\n    // Any time a custom room event is received, forward it\n    room.events.customEvent.subscribe(\n      (eventData) => forwardEvent(room, eventData)\n    )\n  ]);\n}\nfunction syncYdocUpdate(room, update) {\n  sendToPanel({\n    msg: \"room::sync::ydoc\",\n    roomId: room.id,\n    update\n  });\n}\nvar loadedAt = Date.now();\nvar eventCounter = 0;\nfunction nextEventId() {\n  return `event-${loadedAt}-${eventCounter++}`;\n}\nfunction forwardEvent(room, eventData) {\n  sendToPanel({\n    msg: \"room::events::custom-event\",\n    roomId: room.id,\n    event: {\n      type: \"CustomEvent\",\n      id: nextEventId(),\n      key: \"Event\",\n      connectionId: eventData.connectionId,\n      payload: eventData.event\n    }\n  });\n}\nfunction partialSyncConnection(room) {\n  sendToPanel({\n    msg: \"room::sync::partial\",\n    roomId: room.id,\n    status: room.getStatus()\n  });\n}\nfunction partialSyncStorage(room) {\n  const root = room.getStorageSnapshot();\n  if (root) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      storage: root.toTreeNode(\"root\").payload\n    });\n  }\n}\nfunction partialSyncMe(room) {\n  const me = room[kInternal].getSelf_forDevTools();\n  if (me) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      me\n    });\n  }\n}\nfunction partialSyncOthers(room) {\n  const others = room[kInternal].getOthers_forDevTools();\n  if (others) {\n    sendToPanel({\n      msg: \"room::sync::partial\",\n      roomId: room.id,\n      others\n    });\n  }\n}\nfunction fullSync(room) {\n  const root = room.getStorageSnapshot();\n  const me = room[kInternal].getSelf_forDevTools();\n  const others = room[kInternal].getOthers_forDevTools();\n  room.fetchYDoc(\"\");\n  sendToPanel({\n    msg: \"room::sync::full\",\n    roomId: room.id,\n    status: room.getStatus(),\n    storage: _nullishCoalesce(_optionalChain([root, 'optionalAccess', _41 => _41.toTreeNode, 'call', _42 => _42(\"root\"), 'access', _43 => _43.payload]), () => ( null)),\n    me,\n    others\n  });\n}\nvar roomChannelListeners = /* @__PURE__ */ new Map();\nfunction stopRoomChannelListener(roomId) {\n  const listener = roomChannelListeners.get(roomId);\n  roomChannelListeners.delete(roomId);\n  if (listener) {\n    listener();\n  }\n}\nfunction linkDevTools(roomId, room) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  sendToPanel({ msg: \"room::available\", roomId, clientVersion: VERSION });\n  stopRoomChannelListener(roomId);\n  roomChannelListeners.set(\n    roomId,\n    // Returns the unsubscribe callback, that we store in the\n    // roomChannelListeners registry\n    onMessageFromPanel.subscribe((msg) => {\n      switch (msg.msg) {\n        case \"room::subscribe\": {\n          if (msg.roomId === roomId) {\n            startSyncStream(room);\n          }\n          break;\n        }\n        case \"room::unsubscribe\": {\n          if (msg.roomId === roomId) {\n            stopSyncStream(roomId);\n          }\n          break;\n        }\n      }\n    })\n  );\n}\nfunction unlinkDevTools(roomId) {\n  if (process.env.NODE_ENV === \"production\" || typeof window === \"undefined\") {\n    return;\n  }\n  stopSyncStream(roomId);\n  stopRoomChannelListener(roomId);\n  sendToPanel({\n    msg: \"room::unavailable\",\n    roomId\n  });\n}\n\n// src/lib/stringify.ts\nfunction stringify(object, ...args) {\n  if (typeof object !== \"object\" || object === null || Array.isArray(object)) {\n    return JSON.stringify(object, ...args);\n  }\n  const sortedObject = Object.keys(object).sort().reduce(\n    (sortedObject2, key) => {\n      sortedObject2[key] = object[key];\n      return sortedObject2;\n    },\n    {}\n  );\n  return JSON.stringify(sortedObject, ...args);\n}\n\n// src/lib/batch.ts\nvar DEFAULT_SIZE = 50;\nvar BatchCall = class {\n  constructor(input) {\n    this.input = input;\n    const { promise, resolve, reject } = Promise_withResolvers();\n    this.promise = promise;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\nvar Batch = class {\n  constructor(callback, options) {\n    this.queue = [];\n    this.error = false;\n    this.callback = callback;\n    this.size = _nullishCoalesce(options.size, () => ( DEFAULT_SIZE));\n    this.delay = options.delay;\n  }\n  clearDelayTimeout() {\n    if (this.delayTimeoutId !== void 0) {\n      clearTimeout(this.delayTimeoutId);\n      this.delayTimeoutId = void 0;\n    }\n  }\n  schedule() {\n    if (this.queue.length === this.size) {\n      void this.flush();\n    } else if (this.queue.length === 1) {\n      this.clearDelayTimeout();\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\n    }\n  }\n  async flush() {\n    if (this.queue.length === 0) {\n      return;\n    }\n    const calls = this.queue.splice(0);\n    const inputs = calls.map((call) => call.input);\n    try {\n      const results = await this.callback(inputs);\n      this.error = false;\n      calls.forEach((call, index) => {\n        const result = _optionalChain([results, 'optionalAccess', _44 => _44[index]]);\n        if (!Array.isArray(results)) {\n          call.reject(new Error(\"Callback must return an array.\"));\n        } else if (calls.length !== results.length) {\n          call.reject(\n            new Error(\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\n            )\n          );\n        } else if (result instanceof Error) {\n          call.reject(result);\n        } else {\n          call.resolve(result);\n        }\n      });\n    } catch (error3) {\n      this.error = true;\n      calls.forEach((call) => {\n        call.reject(error3);\n      });\n    }\n  }\n  get(input) {\n    const existingCall = this.queue.find(\n      (call2) => stringify(call2.input) === stringify(input)\n    );\n    if (existingCall) {\n      return existingCall.promise;\n    }\n    const call = new BatchCall(input);\n    this.queue.push(call);\n    this.schedule();\n    return call.promise;\n  }\n  clear() {\n    this.queue = [];\n    this.error = false;\n    this.clearDelayTimeout();\n  }\n};\nfunction createBatchStore(batch) {\n  const cache = /* @__PURE__ */ new Map();\n  const eventSource2 = makeEventSource();\n  function getCacheKey(args) {\n    return stringify(args);\n  }\n  function setStateAndNotify(cacheKey, state) {\n    cache.set(cacheKey, state);\n    eventSource2.notify();\n  }\n  function invalidate(inputs) {\n    if (Array.isArray(inputs)) {\n      for (const input of inputs) {\n        cache.delete(getCacheKey(input));\n      }\n    } else {\n      cache.clear();\n    }\n    eventSource2.notify();\n  }\n  async function get(input) {\n    const cacheKey = getCacheKey(input);\n    if (cache.has(cacheKey)) {\n      return;\n    }\n    try {\n      setStateAndNotify(cacheKey, { isLoading: true });\n      const result = await batch.get(input);\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\n    } catch (error3) {\n      setStateAndNotify(cacheKey, {\n        isLoading: false,\n        error: error3\n      });\n    }\n  }\n  function getState(input) {\n    const cacheKey = getCacheKey(input);\n    return cache.get(cacheKey);\n  }\n  function _cacheKeys() {\n    return [...cache.keys()];\n  }\n  return {\n    ...eventSource2.observable,\n    get,\n    getState,\n    invalidate,\n    _cacheKeys\n  };\n}\n\n// src/lib/create-store.ts\nfunction createStore(initialState) {\n  let notifyImmediately = true;\n  let dirty = false;\n  let state = initialState;\n  const subscribers = /* @__PURE__ */ new Set();\n  function get() {\n    return state;\n  }\n  function set(callback) {\n    const oldState = state;\n    const newState = callback(oldState);\n    if (newState !== oldState) {\n      state = newState;\n      dirty = true;\n    }\n    if (notifyImmediately) {\n      notify();\n    }\n  }\n  function notify() {\n    if (!dirty) {\n      return;\n    }\n    dirty = false;\n    for (const subscriber of subscribers) {\n      subscriber(state);\n    }\n  }\n  function batch(cb) {\n    if (notifyImmediately === false) {\n      return cb();\n    }\n    notifyImmediately = false;\n    try {\n      cb();\n    } finally {\n      notifyImmediately = true;\n      notify();\n    }\n  }\n  function subscribe(callback) {\n    subscribers.add(callback);\n    return () => {\n      subscribers.delete(callback);\n    };\n  }\n  return {\n    get,\n    set,\n    batch,\n    subscribe\n  };\n}\n\n// src/convert-plain-data.ts\nfunction convertToCommentData(data) {\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\n  const createdAt = new Date(data.createdAt);\n  const reactions = data.reactions.map((reaction) => ({\n    ...reaction,\n    createdAt: new Date(reaction.createdAt)\n  }));\n  if (data.body) {\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt\n    };\n  } else {\n    const deletedAt = new Date(data.deletedAt);\n    return {\n      ...data,\n      reactions,\n      createdAt,\n      editedAt,\n      deletedAt\n    };\n  }\n}\nfunction convertToThreadData(data) {\n  const createdAt = new Date(data.createdAt);\n  const updatedAt = new Date(data.updatedAt);\n  const comments = data.comments.map(\n    (comment) => convertToCommentData(comment)\n  );\n  return {\n    ...data,\n    createdAt,\n    updatedAt,\n    comments\n  };\n}\nfunction convertToCommentUserReaction(data) {\n  return {\n    ...data,\n    createdAt: new Date(data.createdAt)\n  };\n}\nfunction convertToInboxNotificationData(data) {\n  const notifiedAt = new Date(data.notifiedAt);\n  const readAt = data.readAt ? new Date(data.readAt) : null;\n  if (\"activities\" in data) {\n    const activities = data.activities.map((activity) => ({\n      ...activity,\n      createdAt: new Date(activity.createdAt)\n    }));\n    return {\n      ...data,\n      notifiedAt,\n      readAt,\n      activities\n    };\n  }\n  return {\n    ...data,\n    notifiedAt,\n    readAt\n  };\n}\nfunction convertToThreadDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\nfunction convertToInboxNotificationDeleteInfo(data) {\n  const deletedAt = new Date(data.deletedAt);\n  return {\n    ...data,\n    deletedAt\n  };\n}\n\n// src/lib/autoRetry.ts\nvar HttpError = class extends Error {\n  constructor(message, status, details) {\n    super(message);\n    this.message = message;\n    this.status = status;\n    this.details = details;\n  }\n};\nvar DONT_RETRY_4XX = (x) => x instanceof HttpError && x.status >= 400 && x.status < 500;\nasync function autoRetry(promiseFn, maxTries, backoff, shouldStopRetrying = DONT_RETRY_4XX) {\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\n  let attempt = 0;\n  while (true) {\n    attempt++;\n    try {\n      return await promiseFn();\n    } catch (err) {\n      if (shouldStopRetrying(err)) {\n        throw err;\n      }\n      if (attempt >= maxTries) {\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\n      }\n    }\n    const delay = _nullishCoalesce(backoff[attempt - 1], () => ( fallbackBackoff));\n    warn(\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\n    );\n    await wait(delay);\n  }\n}\n\n// src/lib/url.ts\nfunction toURLSearchParams(params) {\n  const result = new URLSearchParams();\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== void 0 && value !== null) {\n      result.set(key, value.toString());\n    }\n  }\n  return result;\n}\nfunction urljoin(baseUrl, path, params) {\n  const url2 = new URL(path, baseUrl);\n  if (params !== void 0) {\n    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\n  }\n  return url2.toString();\n}\nfunction url(strings, ...values) {\n  return strings.reduce(\n    (result, str, i) => result + encodeURIComponent(_nullishCoalesce(values[i - 1], () => ( \"\"))) + str\n  );\n}\n\n// src/http-client.ts\nfunction getBearerTokenFromAuthValue(authValue) {\n  if (authValue.type === \"public\") {\n    return authValue.publicApiKey;\n  } else {\n    return authValue.token.raw;\n  }\n}\nvar HttpClient = class {\n  constructor(baseUrl, fetchPolyfill, authCallback) {\n    this._baseUrl = baseUrl;\n    this._fetchPolyfill = fetchPolyfill;\n    this._authCallback = authCallback;\n  }\n  // ------------------------------------------------------------------\n  // Public methods\n  // ------------------------------------------------------------------\n  /**\n   * Constructs and makes the HTTP request, but does not handle the response.\n   *\n   * This is what .rawFetch() does:    \uD83D\uDC48 This method!\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails\n   *   6. Throw HttpError if response is an error\n   */\n  async rawFetch(endpoint, options, params) {\n    if (!endpoint.startsWith(\"/v2/c/\")) {\n      raise(\"This client can only be used to make /v2/c/* requests\");\n    }\n    const url2 = urljoin(this._baseUrl, endpoint, params);\n    return await this._fetchPolyfill(url2, {\n      ...options,\n      headers: {\n        // These headers are default, but can be overriden by custom headers\n        \"Content-Type\": \"application/json; charset=utf-8\",\n        // Possible header overrides\n        ..._optionalChain([options, 'optionalAccess', _45 => _45.headers]),\n        // Cannot be overriden by custom headers\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(await this._authCallback())}`,\n        \"X-LB-Client\": PKG_VERSION || \"dev\"\n      }\n    });\n  }\n  /**\n   * Constructs, makes the HTTP request, and handles the response by parsing\n   * JSON and/or throwing an HttpError if it failed.\n   *\n   * This is what .rawFetch() does:\n   *   1. Set Content-Type header\n   *   2. Set Authorization header\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\n   *\n   * This is what .fetch() does ON TOP of that:   \uD83D\uDC48 This method!\n   *   4. Parse response body as Json\n   *   5. ...but silently return `{}` if that parsing fails (\uD83E\uDD14)\n   *   6. Throw HttpError if response is an error\n   */\n  async fetch(endpoint, options, params) {\n    const response = await this.rawFetch(endpoint, options, params);\n    if (!response.ok) {\n      let error3;\n      try {\n        const errorBody = await response.json();\n        error3 = new HttpError(errorBody.message, response.status, errorBody);\n      } catch (e3) {\n        error3 = new HttpError(response.statusText, response.status);\n      }\n      throw error3;\n    }\n    let body;\n    try {\n      body = await response.json();\n    } catch (e4) {\n      body = {};\n    }\n    return body;\n  }\n  /**\n   * Makes a GET request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .get() instead.\n   */\n  async rawGet(endpoint, params, options) {\n    return await this.rawFetch(endpoint, options, params);\n  }\n  /**\n   * Makes a POST request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .post() instead.\n   */\n  async rawPost(endpoint, body) {\n    return await this.rawFetch(endpoint, {\n      method: \"POST\",\n      body: JSON.stringify(body)\n    });\n  }\n  /**\n   * Makes a DELETE request and returns the raw response.\n   * Won't throw if the reponse is a non-2xx.\n   * @deprecated Ideally, use .delete() instead.\n   */\n  async rawDelete(endpoint) {\n    return await this.rawFetch(endpoint, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a GET request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async get(endpoint, params, options) {\n    return await this.fetch(endpoint, options, params);\n  }\n  /**\n   * Makes a POST request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async post(endpoint, body, options, params) {\n    return await this.fetch(\n      endpoint,\n      {\n        ...options,\n        method: \"POST\",\n        body: JSON.stringify(body)\n      },\n      params\n    );\n  }\n  /**\n   * Makes a DELETE request, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async delete(endpoint) {\n    return await this.fetch(endpoint, { method: \"DELETE\" });\n  }\n  /**\n   * Makes a PUT request for a Blob body, and return the JSON response.\n   * Will throw if the reponse is a non-2xx.\n   */\n  async putBlob(endpoint, blob, params, options) {\n    return await this.fetch(\n      endpoint,\n      {\n        ...options,\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/octet-stream\"\n        },\n        body: blob\n      },\n      params\n    );\n  }\n};\n\n// src/notifications.ts\nfunction createNotificationsApi({\n  baseUrl,\n  authManager,\n  currentUserIdStore,\n  fetchPolyfill\n}) {\n  async function getAuthValue() {\n    const authValue = await authManager.getAuthValue({\n      requestedScope: \"comments:read\"\n    });\n    if (authValue.type === \"secret\" && authValue.token.parsed.k === \"acc\" /* ACCESS_TOKEN */) {\n      const userId = authValue.token.parsed.uid;\n      currentUserIdStore.set(() => userId);\n    }\n    return authValue;\n  }\n  const httpClient = new HttpClient(baseUrl, fetchPolyfill, getAuthValue);\n  async function getInboxNotifications(options) {\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(url`/v2/c/inbox-notifications`, {\n      cursor: _optionalChain([options, 'optionalAccess', _46 => _46.cursor]),\n      limit: PAGE_SIZE\n    });\n    return {\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      threads: json.threads.map(convertToThreadData),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getInboxNotificationsSince(options) {\n    const json = await httpClient.get(\n      url`/v2/c/inbox-notifications/delta`,\n      { since: options.since.toISOString() },\n      { signal: _optionalChain([options, 'optionalAccess', _47 => _47.signal]) }\n    );\n    return {\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUnreadInboxNotificationsCount() {\n    const { count } = await httpClient.get(\n      url`/v2/c/inbox-notifications/count`\n    );\n    return count;\n  }\n  async function markAllInboxNotificationsAsRead() {\n    await httpClient.post(url`/v2/c/inbox-notifications/read`, {\n      inboxNotificationIds: \"all\"\n    });\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await httpClient.post(url`/v2/c/inbox-notifications/read`, {\n      inboxNotificationIds\n    });\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  async function deleteAllInboxNotifications() {\n    await httpClient.delete(url`/v2/c/inbox-notifications`);\n  }\n  async function deleteInboxNotification(inboxNotificationId) {\n    await httpClient.delete(\n      url`/v2/c/inbox-notifications/${inboxNotificationId}`\n    );\n  }\n  async function getUserThreads_experimental(options) {\n    let query;\n    if (_optionalChain([options, 'optionalAccess', _48 => _48.query])) {\n      query = objectToQuery(options.query);\n    }\n    const PAGE_SIZE = 50;\n    const json = await httpClient.get(url`/v2/c/threads`, {\n      cursor: options.cursor,\n      query,\n      limit: PAGE_SIZE\n    });\n    return {\n      threads: json.threads.map(convertToThreadData),\n      inboxNotifications: json.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      nextCursor: json.meta.nextCursor,\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  async function getUserThreadsSince_experimental(options) {\n    const json = await httpClient.get(\n      url`/v2/c/threads/delta`,\n      { since: options.since.toISOString() },\n      { signal: options.signal }\n    );\n    return {\n      threads: {\n        updated: json.threads.map(convertToThreadData),\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: json.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(json.meta.requestedAt)\n    };\n  }\n  return {\n    getInboxNotifications,\n    getInboxNotificationsSince,\n    getUnreadInboxNotificationsCount,\n    markAllInboxNotificationsAsRead,\n    markInboxNotificationAsRead,\n    deleteAllInboxNotifications,\n    deleteInboxNotification,\n    getUserThreads_experimental,\n    getUserThreadsSince_experimental\n  };\n}\n\n// src/lib/position.ts\nvar MIN_CODE = 32;\nvar MAX_CODE = 126;\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\nvar ZERO = nthDigit(0);\nvar ONE = nthDigit(1);\nvar ZERO_NINE = ZERO + nthDigit(-1);\nfunction nthDigit(n) {\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\n  if (code < MIN_CODE || code > MAX_CODE) {\n    throw new Error(`Invalid n value: ${n}`);\n  }\n  return String.fromCharCode(code);\n}\nfunction makePosition(x, y) {\n  if (x !== void 0 && y !== void 0) {\n    return between(x, y);\n  } else if (x !== void 0) {\n    return after(x);\n  } else if (y !== void 0) {\n    return before(y);\n  } else {\n    return ONE;\n  }\n}\nfunction before(pos) {\n  const lastIndex = pos.length - 1;\n  for (let i = 0; i <= lastIndex; i++) {\n    const code = pos.charCodeAt(i);\n    if (code <= MIN_CODE) {\n      continue;\n    }\n    if (i === lastIndex) {\n      if (code === MIN_CODE + 1) {\n        return pos.substring(0, i) + ZERO_NINE;\n      } else {\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\n      }\n    } else {\n      return pos.substring(0, i + 1);\n    }\n  }\n  return ONE;\n}\nfunction after(pos) {\n  for (let i = 0; i <= pos.length - 1; i++) {\n    const code = pos.charCodeAt(i);\n    if (code >= MAX_CODE) {\n      continue;\n    }\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\n  }\n  return pos + ONE;\n}\nfunction between(lo, hi) {\n  if (lo < hi) {\n    return _between(lo, hi);\n  } else if (lo > hi) {\n    return _between(hi, lo);\n  } else {\n    throw new Error(\"Cannot compute value between two equal positions\");\n  }\n}\nfunction _between(lo, hi) {\n  let index = 0;\n  const loLen = lo.length;\n  const hiLen = hi.length;\n  while (true) {\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\n    if (loCode === hiCode) {\n      index++;\n      continue;\n    }\n    if (hiCode - loCode === 1) {\n      const size = index + 1;\n      let prefix = lo.substring(0, size);\n      if (prefix.length < size) {\n        prefix += ZERO.repeat(size - prefix.length);\n      }\n      const suffix = lo.substring(size);\n      const nines = \"\";\n      return prefix + _between(suffix, nines);\n    } else {\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\n    }\n  }\n}\nfunction takeN(pos, n) {\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\n}\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\nfunction isPos(str) {\n  if (str === \"\") {\n    return false;\n  }\n  const lastIdx = str.length - 1;\n  const last = str.charCodeAt(lastIdx);\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\n    return false;\n  }\n  for (let i = 0; i < lastIdx; i++) {\n    const code = str.charCodeAt(i);\n    if (code < MIN_CODE || code > MAX_CODE) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction convertToPos(str) {\n  const codes = [];\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\n  }\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\n    codes.length--;\n  }\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\n    ONE\n  );\n}\nfunction asPos(str) {\n  return isPos(str) ? str : convertToPos(str);\n}\n\n// src/protocol/Op.ts\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\n  OpCode2[OpCode2[\"INIT\"] = 0] = \"INIT\";\n  OpCode2[OpCode2[\"SET_PARENT_KEY\"] = 1] = \"SET_PARENT_KEY\";\n  OpCode2[OpCode2[\"CREATE_LIST\"] = 2] = \"CREATE_LIST\";\n  OpCode2[OpCode2[\"UPDATE_OBJECT\"] = 3] = \"UPDATE_OBJECT\";\n  OpCode2[OpCode2[\"CREATE_OBJECT\"] = 4] = \"CREATE_OBJECT\";\n  OpCode2[OpCode2[\"DELETE_CRDT\"] = 5] = \"DELETE_CRDT\";\n  OpCode2[OpCode2[\"DELETE_OBJECT_KEY\"] = 6] = \"DELETE_OBJECT_KEY\";\n  OpCode2[OpCode2[\"CREATE_MAP\"] = 7] = \"CREATE_MAP\";\n  OpCode2[OpCode2[\"CREATE_REGISTER\"] = 8] = \"CREATE_REGISTER\";\n  return OpCode2;\n})(OpCode || {});\nfunction ackOp(opId) {\n  return {\n    type: 5 /* DELETE_CRDT */,\n    id: \"ACK\",\n    // (H)ACK\n    opId\n  };\n}\nfunction isAckOp(op) {\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \"ACK\";\n}\n\n// src/crdts/AbstractCrdt.ts\nfunction crdtAsLiveNode(value) {\n  return value;\n}\nfunction HasParent(node, key, pos = asPos(key)) {\n  return Object.freeze({ type: \"HasParent\", node, key, pos });\n}\nvar NoParent = Object.freeze({ type: \"NoParent\" });\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\n  return Object.freeze({ type: \"Orphaned\", oldKey, oldPos });\n}\nvar AbstractCrdt = class {\n  constructor() {\n    /** @internal */\n    this._parent = NoParent;\n  }\n  /** @internal */\n  _getParentKeyOrThrow() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _parentPos() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.pos;\n      case \"NoParent\":\n        throw new Error(\"Parent key is missing\");\n      case \"Orphaned\":\n        return this.parent.oldPos;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  get _pool() {\n    return this.__pool;\n  }\n  get roomId() {\n    return this.__pool ? this.__pool.roomId : null;\n  }\n  /** @internal */\n  get _id() {\n    return this.__id;\n  }\n  /** @internal */\n  get parent() {\n    return this._parent;\n  }\n  /** @internal */\n  get _parentKey() {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        return this.parent.key;\n      case \"NoParent\":\n        return null;\n      case \"Orphaned\":\n        return this.parent.oldKey;\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _apply(op, _isLocal) {\n    switch (op.type) {\n      case 5 /* DELETE_CRDT */: {\n        if (this.parent.type === \"HasParent\") {\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\n        }\n        return { modified: false };\n      }\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _setParentLink(newParentNode, newParentKey) {\n    switch (this.parent.type) {\n      case \"HasParent\":\n        if (this.parent.node !== newParentNode) {\n          throw new Error(\"Cannot set parent: node already has a parent\");\n        } else {\n          this._parent = HasParent(newParentNode, newParentKey);\n          return;\n        }\n      case \"Orphaned\":\n      case \"NoParent\": {\n        this._parent = HasParent(newParentNode, newParentKey);\n        return;\n      }\n      default:\n        return assertNever(this.parent, \"Unknown state\");\n    }\n  }\n  /** @internal */\n  _attach(id, pool) {\n    if (this.__id || this.__pool) {\n      throw new Error(\"Cannot attach node: already attached\");\n    }\n    pool.addNode(id, crdtAsLiveNode(this));\n    this.__id = id;\n    this.__pool = pool;\n  }\n  /** @internal */\n  _detach() {\n    if (this.__pool && this.__id) {\n      this.__pool.deleteNode(this.__id);\n    }\n    switch (this.parent.type) {\n      case \"HasParent\": {\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\n        break;\n      }\n      case \"NoParent\": {\n        this._parent = NoParent;\n        break;\n      }\n      case \"Orphaned\": {\n        break;\n      }\n      default:\n        assertNever(this.parent, \"Unknown state\");\n    }\n    this.__pool = void 0;\n  }\n  /**\n   * @internal\n   *\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\n   * recompute the equivalent Immutable value again.  Call this after every\n   * mutation to the Live node.\n   */\n  invalidate() {\n    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\n      this._cachedImmutable = void 0;\n      this._cachedTreeNode = void 0;\n      if (this.parent.type === \"HasParent\") {\n        this.parent.node.invalidate();\n      }\n    }\n  }\n  /**\n   * @internal\n   *\n   * Return an snapshot of this Live tree for use in DevTools.\n   */\n  toTreeNode(key) {\n    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\n      this._cachedTreeNodeKey = key;\n      this._cachedTreeNode = this._toTreeNode(key);\n    }\n    return this._cachedTreeNode;\n  }\n  /**\n   * Return an immutable snapshot of this Live node and its children.\n   */\n  toImmutable() {\n    if (this._cachedImmutable === void 0) {\n      this._cachedImmutable = this._toImmutable();\n    }\n    return this._cachedImmutable;\n  }\n};\n\n// src/protocol/SerializedCrdt.ts\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\n  CrdtType2[CrdtType2[\"OBJECT\"] = 0] = \"OBJECT\";\n  CrdtType2[CrdtType2[\"LIST\"] = 1] = \"LIST\";\n  CrdtType2[CrdtType2[\"MAP\"] = 2] = \"MAP\";\n  CrdtType2[CrdtType2[\"REGISTER\"] = 3] = \"REGISTER\";\n  return CrdtType2;\n})(CrdtType || {});\nfunction isRootCrdt(crdt) {\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\n}\nfunction isChildCrdt(crdt) {\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\n}\n\n// src/lib/nanoid.ts\nvar nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce(\n  (t2, e) => t2 += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? \"_\" : \"-\",\n  \"\"\n);\n\n// src/crdts/LiveRegister.ts\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\n  constructor(data) {\n    super();\n    this._data = data;\n  }\n  get data() {\n    return this._data;\n  }\n  /** @internal */\n  static _deserialize([id, item], _parentToChildren, pool) {\n    const register = new _LiveRegister(item.data);\n    register._attach(id, pool);\n    return register;\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\n        \"Cannot serialize register if parentId or parentKey is undefined\"\n      );\n    }\n    return [\n      {\n        type: 8 /* CREATE_REGISTER */,\n        opId: _optionalChain([pool, 'optionalAccess', _49 => _49.generateOpId, 'call', _50 => _50()]),\n        id: this._id,\n        parentId,\n        parentKey,\n        data: this.data\n      }\n    ];\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveRegister if parent is missing\");\n    }\n    return {\n      type: 3 /* REGISTER */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key,\n      data: this.data\n    };\n  }\n  /** @internal */\n  _attachChild(_op) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _detachChild(_crdt) {\n    throw new Error(\"Method not implemented.\");\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"Json\",\n      id: _nullishCoalesce(this._id, () => ( nanoid())),\n      key,\n      payload: this._data\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  clone() {\n    return deepClone(this.data);\n  }\n};\n\n// src/crdts/LiveList.ts\nfunction compareNodePosition(itemA, itemB) {\n  const posA = itemA._parentPos;\n  const posB = itemB._parentPos;\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\n}\nvar LiveList = class _LiveList extends AbstractCrdt {\n  constructor(items) {\n    super();\n    this._items = [];\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\n    let position = void 0;\n    for (const item of items) {\n      const newPosition = makePosition(position);\n      const node = lsonToLiveNode(item);\n      node._setParentLink(this, newPosition);\n      this._items.push(node);\n      position = newPosition;\n    }\n  }\n  /** @internal */\n  static _deserialize([id], parentToChildren, pool) {\n    const list = new _LiveList([]);\n    list._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return list;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(list, crdt.parentKey);\n      list._insertAndSort(child);\n    }\n    return list;\n  }\n  /**\n   * @internal\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\n   * so we mutate _unacknowledgedSets to avoid potential flickering\n   * https://github.com/liveblocks/liveblocks/pull/1177\n   *\n   * This is quite unintuitive and should disappear as soon as\n   * we introduce an explicit LiveList.Set operation\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: _optionalChain([pool, 'optionalAccess', _51 => _51.generateOpId, 'call', _52 => _52()]),\n      type: 2 /* CREATE_LIST */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const item of this._items) {\n      const parentKey2 = item._getParentKeyOrThrow();\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\n        item._toOps(this._id, parentKey2, pool),\n        void 0\n      );\n      const childOpId = childOps[0].opId;\n      if (childOpId !== void 0) {\n        this._unacknowledgedSets.set(parentKey2, childOpId);\n      }\n      ops.push(...childOps);\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   *\n   * Adds a new item into the sorted list, in the correct position.\n   */\n  _insertAndSort(item) {\n    this._items.push(item);\n    this._sortItems();\n  }\n  /** @internal */\n  _sortItems() {\n    this._items.sort(compareNodePosition);\n    this.invalidate();\n  }\n  /** @internal */\n  _indexOfPosition(position) {\n    return this._items.findIndex(\n      (item) => item._getParentKeyOrThrow() === position\n    );\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const item of this._items) {\n      item._attach(pool.generateId(), pool);\n    }\n  }\n  /** @internal */\n  _detach() {\n    super._detach();\n    for (const item of this._items) {\n      item._detach();\n    }\n  }\n  /** @internal */\n  _applySetRemote(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    child._attach(id, this._pool);\n    child._setParentLink(this, key);\n    const deletedId = op.deletedId;\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\n    if (indexOfItemWithSamePosition !== -1) {\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\n      if (itemWithSamePosition._id === deletedId) {\n        itemWithSamePosition._detach();\n        this._items[indexOfItemWithSamePosition] = child;\n        return {\n          modified: makeUpdate(this, [\n            setDelta(indexOfItemWithSamePosition, child)\n          ]),\n          reverse: []\n        };\n      } else {\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\n        this._items[indexOfItemWithSamePosition] = child;\n        const delta = [\n          setDelta(indexOfItemWithSamePosition, child)\n        ];\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n          op.deletedId\n        );\n        if (deleteDelta2) {\n          delta.push(deleteDelta2);\n        }\n        return {\n          modified: makeUpdate(this, delta),\n          reverse: []\n        };\n      }\n    } else {\n      const updates = [];\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deleteDelta2) {\n        updates.push(deleteDelta2);\n      }\n      this._insertAndSort(child);\n      updates.push(insertDelta(this._indexOfPosition(key), child));\n      return {\n        reverse: [],\n        modified: makeUpdate(this, updates)\n      };\n    }\n  }\n  /** @internal */\n  _applySetAck(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const delta = [];\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\n    if (deletedDelta) {\n      delta.push(deletedDelta);\n    }\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\n    if (unacknowledgedOpId !== void 0) {\n      if (unacknowledgedOpId !== op.opId) {\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\n      } else {\n        this._unacknowledgedSets.delete(op.parentKey);\n      }\n    }\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\n    const existingItem = this._items.find((item) => item._id === op.id);\n    if (existingItem !== void 0) {\n      if (existingItem._parentKey === op.parentKey) {\n        return {\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n          reverse: []\n        };\n      }\n      if (indexOfItemWithSamePosition !== -1) {\n        this._implicitlyDeletedItems.add(\n          this._items[indexOfItemWithSamePosition]\n        );\n        const [prevNode] = this._items.splice(indexOfItemWithSamePosition, 1);\n        delta.push(deleteDelta(indexOfItemWithSamePosition, prevNode));\n      }\n      const prevIndex = this._items.indexOf(existingItem);\n      existingItem._setParentLink(this, op.parentKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(existingItem);\n      if (newIndex !== prevIndex) {\n        delta.push(moveDelta(prevIndex, newIndex, existingItem));\n      }\n      return {\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\n        reverse: []\n      };\n    } else {\n      const orphan = this._pool.getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, op.parentKey);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const recreatedItemIndex = this._items.indexOf(orphan);\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\n            ...delta\n          ]),\n          reverse: []\n        };\n      } else {\n        if (indexOfItemWithSamePosition !== -1) {\n          this._items.splice(indexOfItemWithSamePosition, 1);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(\n          op,\n          op.parentKey\n        );\n        return {\n          modified: makeUpdate(this, [\n            // If there is an item at this position, update is a set, else it's an insert\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\n            ...delta\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /**\n   * Returns the update delta of the deletion or null\n   * @internal\n   */\n  _detachItemAssociatedToSetOperation(deletedId) {\n    if (deletedId === void 0 || this._pool === void 0) {\n      return null;\n    }\n    const deletedItem = this._pool.getNode(deletedId);\n    if (deletedItem === void 0) {\n      return null;\n    }\n    const result = this._detachChild(deletedItem);\n    if (result.modified === false) {\n      return null;\n    }\n    return result.modified.updates[0];\n  }\n  /** @internal */\n  _applyRemoteInsert(op) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const key = asPos(op.parentKey);\n    const existingItemIndex = this._indexOfPosition(key);\n    if (existingItemIndex !== -1) {\n      this._shiftItemPosition(existingItemIndex, key);\n    }\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n      reverse: []\n    };\n  }\n  /** @internal */\n  _applyInsertAck(op) {\n    const existingItem = this._items.find((item) => item._id === op.id);\n    const key = asPos(op.parentKey);\n    const itemIndexAtPosition = this._indexOfPosition(key);\n    if (existingItem) {\n      if (existingItem._parentKey === key) {\n        return {\n          modified: false\n        };\n      } else {\n        const oldPositionIndex = this._items.indexOf(existingItem);\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        existingItem._setParentLink(this, key);\n        this._sortItems();\n        const newIndex = this._indexOfPosition(key);\n        if (newIndex === oldPositionIndex) {\n          return { modified: false };\n        }\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(oldPositionIndex, newIndex, existingItem)\n          ]),\n          reverse: []\n        };\n      }\n    } else {\n      const orphan = nn(this._pool).getNode(op.id);\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\n        orphan._setParentLink(this, key);\n        this._implicitlyDeletedItems.delete(orphan);\n        this._insertAndSort(orphan);\n        const newIndex = this._indexOfPosition(key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\n          reverse: []\n        };\n      } else {\n        if (itemIndexAtPosition !== -1) {\n          this._shiftItemPosition(itemIndexAtPosition, key);\n        }\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\n        return {\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applyInsertUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (_optionalChain([this, 'access', _53 => _53._pool, 'optionalAccess', _54 => _54.getNode, 'call', _55 => _55(id)]) !== void 0) {\n      return { modified: false };\n    }\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const existingItemIndex = this._indexOfPosition(key);\n    let newKey = key;\n    if (existingItemIndex !== -1) {\n      const before2 = _optionalChain([this, 'access', _56 => _56._items, 'access', _57 => _57[existingItemIndex], 'optionalAccess', _58 => _58._parentPos]);\n      const after2 = _optionalChain([this, 'access', _59 => _59._items, 'access', _60 => _60[existingItemIndex + 1], 'optionalAccess', _61 => _61._parentPos]);\n      newKey = makePosition(before2, after2);\n      child._setParentLink(this, newKey);\n    }\n    this._insertAndSort(child);\n    const newIndex = this._indexOfPosition(newKey);\n    return {\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\n    };\n  }\n  /** @internal */\n  _applySetUndoRedo(op) {\n    const { id, parentKey: key } = op;\n    const child = creationOpToLiveNode(op);\n    if (_optionalChain([this, 'access', _62 => _62._pool, 'optionalAccess', _63 => _63.getNode, 'call', _64 => _64(id)]) !== void 0) {\n      return { modified: false };\n    }\n    this._unacknowledgedSets.set(key, nn(op.opId));\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\n    child._attach(id, nn(this._pool));\n    child._setParentLink(this, key);\n    const newKey = key;\n    if (indexOfItemWithSameKey !== -1) {\n      const existingItem = this._items[indexOfItemWithSameKey];\n      existingItem._detach();\n      this._items[indexOfItemWithSameKey] = child;\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(nn(this._id), key, this._pool),\n        op.id\n      );\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\n        op.deletedId\n      );\n      if (deletedDelta) {\n        delta.push(deletedDelta);\n      }\n      return {\n        modified: makeUpdate(this, delta),\n        reverse\n      };\n    } else {\n      this._insertAndSort(child);\n      this._detachItemAssociatedToSetOperation(op.deletedId);\n      const newIndex = this._indexOfPosition(newKey);\n      return {\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\n      };\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    let result;\n    if (op.intent === \"set\") {\n      if (source === 1 /* REMOTE */) {\n        result = this._applySetRemote(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applySetAck(op);\n      } else {\n        result = this._applySetUndoRedo(op);\n      }\n    } else {\n      if (source === 1 /* REMOTE */) {\n        result = this._applyRemoteInsert(op);\n      } else if (source === 2 /* ACK */) {\n        result = this._applyInsertAck(op);\n      } else {\n        result = this._applyInsertUndoRedo(op);\n      }\n    }\n    if (result.modified !== false) {\n      this.invalidate();\n    }\n    return result;\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\n      const indexToDelete = this._items.indexOf(child);\n      if (indexToDelete === -1) {\n        return {\n          modified: false\n        };\n      }\n      const [previousNode] = this._items.splice(indexToDelete, 1);\n      this.invalidate();\n      child._detach();\n      return {\n        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),\n        reverse\n      };\n    }\n    return { modified: false };\n  }\n  /** @internal */\n  _applySetChildKeyRemote(newKey, child) {\n    if (this._implicitlyDeletedItems.has(child)) {\n      this._implicitlyDeletedItems.delete(child);\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      const newIndex = this._items.indexOf(child);\n      return {\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\n        reverse: []\n      };\n    }\n    const previousKey = child._parentKey;\n    if (newKey === previousKey) {\n      return {\n        modified: false\n      };\n    }\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex === -1) {\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    } else {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, _optionalChain([this, 'access', _65 => _65._items, 'access', _66 => _66[existingItemIndex + 1], 'optionalAccess', _67 => _67._parentPos]))\n      );\n      const previousIndex = this._items.indexOf(child);\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (newIndex === previousIndex) {\n        return {\n          modified: false\n        };\n      }\n      return {\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n        reverse: []\n      };\n    }\n  }\n  /** @internal */\n  _applySetChildKeyAck(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    if (this._implicitlyDeletedItems.has(child)) {\n      const existingItemIndex = this._indexOfPosition(newKey);\n      this._implicitlyDeletedItems.delete(child);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, _optionalChain([this, 'access', _68 => _68._items, 'access', _69 => _69[existingItemIndex + 1], 'optionalAccess', _70 => _70._parentPos]))\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._insertAndSort(child);\n      return {\n        modified: false\n      };\n    } else {\n      if (newKey === previousKey) {\n        return {\n          modified: false\n        };\n      }\n      const previousIndex = this._items.indexOf(child);\n      const existingItemIndex = this._indexOfPosition(newKey);\n      if (existingItemIndex !== -1) {\n        this._items[existingItemIndex]._setParentLink(\n          this,\n          makePosition(newKey, _optionalChain([this, 'access', _71 => _71._items, 'access', _72 => _72[existingItemIndex + 1], 'optionalAccess', _73 => _73._parentPos]))\n        );\n      }\n      child._setParentLink(this, newKey);\n      this._sortItems();\n      const newIndex = this._items.indexOf(child);\n      if (previousIndex === newIndex) {\n        return {\n          modified: false\n        };\n      } else {\n        return {\n          modified: makeUpdate(this, [\n            moveDelta(previousIndex, newIndex, child)\n          ]),\n          reverse: []\n        };\n      }\n    }\n  }\n  /** @internal */\n  _applySetChildKeyUndoRedo(newKey, child) {\n    const previousKey = nn(child._parentKey);\n    const previousIndex = this._items.indexOf(child);\n    const existingItemIndex = this._indexOfPosition(newKey);\n    if (existingItemIndex !== -1) {\n      this._items[existingItemIndex]._setParentLink(\n        this,\n        makePosition(newKey, _optionalChain([this, 'access', _74 => _74._items, 'access', _75 => _75[existingItemIndex + 1], 'optionalAccess', _76 => _76._parentPos]))\n      );\n    }\n    child._setParentLink(this, newKey);\n    this._sortItems();\n    const newIndex = this._items.indexOf(child);\n    if (previousIndex === newIndex) {\n      return {\n        modified: false\n      };\n    }\n    return {\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\n      reverse: [\n        {\n          type: 1 /* SET_PARENT_KEY */,\n          id: nn(child._id),\n          parentKey: previousKey\n        }\n      ]\n    };\n  }\n  /** @internal */\n  _setChildKey(newKey, child, source) {\n    if (source === 1 /* REMOTE */) {\n      return this._applySetChildKeyRemote(newKey, child);\n    } else if (source === 2 /* ACK */) {\n      return this._applySetChildKeyAck(newKey, child);\n    } else {\n      return this._applySetChildKeyUndoRedo(newKey, child);\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    return super._apply(op, isLocal);\n  }\n  /** @internal */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveList if parent is missing\");\n    }\n    return {\n      type: 1 /* LIST */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns the number of elements.\n   */\n  get length() {\n    return this._items.length;\n  }\n  /**\n   * Adds one element to the end of the LiveList.\n   * @param element The element to add to the end of the LiveList.\n   */\n  push(element) {\n    _optionalChain([this, 'access', _77 => _77._pool, 'optionalAccess', _78 => _78.assertStorageIsWritable, 'call', _79 => _79()]);\n    return this.insert(element, this.length);\n  }\n  /**\n   * Inserts one element at a specified index.\n   * @param element The element to insert.\n   * @param index The index at which you want to insert the element.\n   */\n  insert(element, index) {\n    _optionalChain([this, 'access', _80 => _80._pool, 'optionalAccess', _81 => _81.assertStorageIsWritable, 'call', _82 => _82()]);\n    if (index < 0 || index > this._items.length) {\n      throw new Error(\n        `Cannot insert list item at index \"\u001D${index}\". index should be between 0 and ${this._items.length}`\n      );\n    }\n    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\n    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\n    const position = makePosition(before2, after2);\n    const value = lsonToLiveNode(element);\n    value._setParentLink(this, position);\n    this._insertAndSort(value);\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      this._pool.dispatch(\n        value._toOps(this._id, position, this._pool),\n        [{ type: 5 /* DELETE_CRDT */, id }],\n        /* @__PURE__ */ new Map([\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\n        ])\n      );\n    }\n  }\n  /**\n   * Move one element from one index to another.\n   * @param index The index of the element to move\n   * @param targetIndex The index where the element should be after moving.\n   */\n  move(index, targetIndex) {\n    _optionalChain([this, 'access', _83 => _83._pool, 'optionalAccess', _84 => _84.assertStorageIsWritable, 'call', _85 => _85()]);\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n    if (targetIndex >= this._items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n    if (index >= this._items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n    let beforePosition = null;\n    let afterPosition = null;\n    if (index < targetIndex) {\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\n      beforePosition = this._items[targetIndex]._parentPos;\n    } else {\n      afterPosition = this._items[targetIndex]._parentPos;\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\n    }\n    const position = makePosition(beforePosition, afterPosition);\n    const item = this._items[index];\n    const previousPosition = item._getParentKeyOrThrow();\n    item._setParentLink(this, position);\n    this._sortItems();\n    if (this._pool && this._id) {\n      const storageUpdates = /* @__PURE__ */ new Map([\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\n      ]);\n      this._pool.dispatch(\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            opId: this._pool.generateOpId(),\n            parentKey: position\n          }\n        ],\n        [\n          {\n            type: 1 /* SET_PARENT_KEY */,\n            id: nn(item._id),\n            parentKey: previousPosition\n          }\n        ],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Deletes an element at the specified index\n   * @param index The index of the element to delete\n   */\n  delete(index) {\n    _optionalChain([this, 'access', _86 => _86._pool, 'optionalAccess', _87 => _87.assertStorageIsWritable, 'call', _88 => _88()]);\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot delete list item at index \"${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const item = this._items[index];\n    item._detach();\n    const [prev] = this._items.splice(index, 1);\n    this.invalidate();\n    if (this._pool) {\n      const childRecordId = item._id;\n      if (childRecordId) {\n        const storageUpdates = /* @__PURE__ */ new Map();\n        storageUpdates.set(\n          nn(this._id),\n          makeUpdate(this, [deleteDelta(index, prev)])\n        );\n        this._pool.dispatch(\n          [\n            {\n              id: childRecordId,\n              opId: this._pool.generateOpId(),\n              type: 5 /* DELETE_CRDT */\n            }\n          ],\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\n          storageUpdates\n        );\n      }\n    }\n  }\n  clear() {\n    _optionalChain([this, 'access', _89 => _89._pool, 'optionalAccess', _90 => _90.assertStorageIsWritable, 'call', _91 => _91()]);\n    if (this._pool) {\n      const ops = [];\n      const reverseOps = [];\n      const updateDelta = [];\n      for (const item of this._items) {\n        item._detach();\n        const childId = item._id;\n        if (childId) {\n          ops.push({\n            type: 5 /* DELETE_CRDT */,\n            id: childId,\n            opId: this._pool.generateOpId()\n          });\n          reverseOps.push(\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\n          );\n          updateDelta.push(deleteDelta(0, item));\n        }\n      }\n      this._items = [];\n      this.invalidate();\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    } else {\n      for (const item of this._items) {\n        item._detach();\n      }\n      this._items = [];\n      this.invalidate();\n    }\n  }\n  set(index, item) {\n    _optionalChain([this, 'access', _92 => _92._pool, 'optionalAccess', _93 => _93.assertStorageIsWritable, 'call', _94 => _94()]);\n    if (index < 0 || index >= this._items.length) {\n      throw new Error(\n        `Cannot set list item at index \"\u001D${index}\". index should be between 0 and ${this._items.length - 1}`\n      );\n    }\n    const existingItem = this._items[index];\n    const position = existingItem._getParentKeyOrThrow();\n    const existingId = existingItem._id;\n    existingItem._detach();\n    const value = lsonToLiveNode(item);\n    value._setParentLink(this, position);\n    this._items[index] = value;\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      value._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\n      const ops = HACK_addIntentAndDeletedIdToOperation(\n        value._toOps(this._id, position, this._pool),\n        existingId\n      );\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\n        existingItem._toOps(this._id, position, void 0),\n        id\n      );\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\n    }\n  }\n  /**\n   * Returns an Array of all the elements in the LiveList.\n   */\n  toArray() {\n    return this._items.map(\n      (entry) => liveNodeToLson(entry)\n      //                               ^^^^^^^^\n      //                               FIXME! This isn't safe.\n    );\n  }\n  /**\n   * Tests whether all elements pass the test implemented by the provided function.\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\n   */\n  every(predicate) {\n    return this.toArray().every(predicate);\n  }\n  /**\n   * Creates an array with all elements that pass the test implemented by the provided function.\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\n   * @returns An array with the elements that pass the test.\n   */\n  filter(predicate) {\n    return this.toArray().filter(predicate);\n  }\n  /**\n   * Returns the first element that satisfies the provided testing function.\n   * @param predicate Function to execute on each value.\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\n   */\n  find(predicate) {\n    return this.toArray().find(predicate);\n  }\n  /**\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\n   */\n  findIndex(predicate) {\n    return this.toArray().findIndex(predicate);\n  }\n  /**\n   * Executes a provided function once for each element.\n   * @param callbackfn Function to execute on each element.\n   */\n  forEach(callbackfn) {\n    return this.toArray().forEach(callbackfn);\n  }\n  /**\n   * Get the element at the specified index.\n   * @param index The index on the element to get.\n   * @returns The element at the specified index or undefined.\n   */\n  get(index) {\n    if (index < 0 || index >= this._items.length) {\n      return void 0;\n    }\n    return liveNodeToLson(this._items[index]);\n  }\n  /**\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index to start the search at.\n   * @returns The first index of the element in the LiveList; -1 if not found.\n   */\n  indexOf(searchElement, fromIndex) {\n    return this.toArray().indexOf(searchElement, fromIndex);\n  }\n  /**\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\n   * @param searchElement Element to locate.\n   * @param fromIndex The index at which to start searching backwards.\n   * @returns\n   */\n  lastIndexOf(searchElement, fromIndex) {\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\n  }\n  /**\n   * Creates an array populated with the results of calling a provided function on every element.\n   * @param callback Function that is called for every element.\n   * @returns An array with each element being the result of the callback function.\n   */\n  map(callback) {\n    return this._items.map(\n      (entry, i) => callback(\n        liveNodeToLson(entry),\n        //                    ^^^^^^^^\n        //                    FIXME! This isn't safe.\n        i\n      )\n    );\n  }\n  /**\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\n   * @param predicate Function to test for each element.\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\n   */\n  some(predicate) {\n    return this.toArray().some(predicate);\n  }\n  [Symbol.iterator]() {\n    return new LiveListIterator(this._items);\n  }\n  /** @internal */\n  _createAttachItemAndSort(op, key) {\n    const newItem = creationOpToLiveNode(op);\n    newItem._attach(op.id, nn(this._pool));\n    newItem._setParentLink(this, key);\n    this._insertAndSort(newItem);\n    const newIndex = this._indexOfPosition(key);\n    return { newItem, newIndex };\n  }\n  /** @internal */\n  _shiftItemPosition(index, key) {\n    const shiftedPosition = makePosition(\n      key,\n      this._items.length > index + 1 ? _optionalChain([this, 'access', _95 => _95._items, 'access', _96 => _96[index + 1], 'optionalAccess', _97 => _97._parentPos]) : void 0\n    );\n    this._items[index]._setParentLink(this, shiftedPosition);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveList\",\n      id: _nullishCoalesce(this._id, () => ( nanoid())),\n      key,\n      payload: this._items.map(\n        (item, index) => item.toTreeNode(index.toString())\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = this._items.map((node) => node.toImmutable());\n    return process.env.NODE_ENV === \"production\" ? result : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveList(this._items.map((item) => item.clone()));\n  }\n};\nvar LiveListIterator = class {\n  constructor(items) {\n    this._innerIterator = items[Symbol.iterator]();\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n  next() {\n    const result = this._innerIterator.next();\n    if (result.done) {\n      return {\n        done: true,\n        value: void 0\n      };\n    }\n    const value = liveNodeToLson(result.value);\n    return { value };\n  }\n};\nfunction makeUpdate(liveList, deltaUpdates) {\n  return {\n    node: liveList,\n    type: \"LiveList\",\n    updates: deltaUpdates\n  };\n}\nfunction setDelta(index, item) {\n  return {\n    index,\n    type: \"set\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction deleteDelta(index, deletedNode) {\n  return {\n    type: \"delete\",\n    index,\n    deletedItem: deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode\n  };\n}\nfunction insertDelta(index, item) {\n  return {\n    index,\n    type: \"insert\",\n    item: item instanceof LiveRegister ? item.data : item\n  };\n}\nfunction moveDelta(previousIndex, index, item) {\n  return {\n    type: \"move\",\n    index,\n    item: item instanceof LiveRegister ? item.data : item,\n    previousIndex\n  };\n}\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\n  return ops.map((op, index) => {\n    if (index === 0) {\n      const firstOp = op;\n      return {\n        ...firstOp,\n        intent: \"set\",\n        deletedId\n      };\n    } else {\n      return op;\n    }\n  });\n}\n\n// src/lib/freeze.ts\nvar freeze = process.env.NODE_ENV === \"production\" ? (\n  /* istanbul ignore next */\n  (x) => x\n) : Object.freeze;\n\n// src/crdts/LiveMap.ts\nvar LiveMap = class _LiveMap extends AbstractCrdt {\n  constructor(entries2) {\n    super();\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\n    if (entries2) {\n      const mappedEntries = [];\n      for (const [key, value] of entries2) {\n        const node = lsonToLiveNode(value);\n        node._setParentLink(this, key);\n        mappedEntries.push([key, node]);\n      }\n      this._map = new Map(mappedEntries);\n    } else {\n      this._map = /* @__PURE__ */ new Map();\n    }\n  }\n  /**\n   * @internal\n   */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const ops = [];\n    const op = {\n      id: this._id,\n      opId: _optionalChain([pool, 'optionalAccess', _98 => _98.generateOpId, 'call', _99 => _99()]),\n      type: 7 /* CREATE_MAP */,\n      parentId,\n      parentKey\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      ops.push(...value._toOps(this._id, key, pool));\n    }\n    return ops;\n  }\n  /**\n   * @internal\n   */\n  static _deserialize([id, _item], parentToChildren, pool) {\n    const map = new _LiveMap();\n    map._attach(id, pool);\n    const children = parentToChildren.get(id);\n    if (children === void 0) {\n      return map;\n    }\n    for (const [id2, crdt] of children) {\n      const child = deserialize([id2, crdt], parentToChildren, pool);\n      child._setParentLink(map, crdt.parentKey);\n      map._map.set(crdt.parentKey, child);\n      map.invalidate();\n    }\n    return map;\n  }\n  /**\n   * @internal\n   */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, parentKey, opId } = op;\n    const key = parentKey;\n    const child = creationOpToLiveNode(op);\n    if (this._pool.getNode(id) !== void 0) {\n      return { modified: false };\n    }\n    if (source === 2 /* ACK */) {\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\n      if (lastUpdateOpId === opId) {\n        this.unacknowledgedSet.delete(key);\n        return { modified: false };\n      } else if (lastUpdateOpId !== void 0) {\n        return { modified: false };\n      }\n    } else if (source === 1 /* REMOTE */) {\n      this.unacknowledgedSet.delete(key);\n    }\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (previousValue) {\n      const thisId = nn(this._id);\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else {\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\n    }\n    child._setParentLink(this, key);\n    child._attach(id, this._pool);\n    this._map.set(key, child);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const item of this._map.values()) {\n      item._detach();\n    }\n  }\n  /**\n   * @internal\n   */\n  _detachChild(child) {\n    const id = nn(this._id);\n    const parentKey = nn(child._parentKey);\n    const reverse = child._toOps(id, parentKey, this._pool);\n    for (const [key, value] of this._map) {\n      if (value === child) {\n        this._map.delete(key);\n        this.invalidate();\n      }\n    }\n    child._detach();\n    const storageUpdate = {\n      node: this,\n      type: \"LiveMap\",\n      updates: { [parentKey]: { type: \"delete\" } }\n    };\n    return { modified: storageUpdate, reverse };\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    if (this.parent.type !== \"HasParent\") {\n      throw new Error(\"Cannot serialize LiveMap if parent is missing\");\n    }\n    return {\n      type: 2 /* MAP */,\n      parentId: nn(this.parent.node._id, \"Parent node expected to have ID\"),\n      parentKey: this.parent.key\n    };\n  }\n  /**\n   * Returns a specified element from the LiveMap.\n   * @param key The key of the element to return.\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\n   */\n  get(key) {\n    const value = this._map.get(key);\n    if (value === void 0) {\n      return void 0;\n    }\n    return liveNodeToLson(value);\n  }\n  /**\n   * Adds or updates an element with a specified key and a value.\n   * @param key The key of the element to add. Should be a string.\n   * @param value The value of the element to add. Should be serializable to JSON.\n   */\n  set(key, value) {\n    _optionalChain([this, 'access', _100 => _100._pool, 'optionalAccess', _101 => _101.assertStorageIsWritable, 'call', _102 => _102()]);\n    const oldValue = this._map.get(key);\n    if (oldValue) {\n      oldValue._detach();\n    }\n    const item = lsonToLiveNode(value);\n    item._setParentLink(this, key);\n    this._map.set(key, item);\n    this.invalidate();\n    if (this._pool && this._id) {\n      const id = this._pool.generateId();\n      item._attach(id, this._pool);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(this._id, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"update\" } }\n      });\n      const ops = item._toOps(this._id, key, this._pool);\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\n      this._pool.dispatch(\n        item._toOps(this._id, key, this._pool),\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\n        storageUpdates\n      );\n    }\n  }\n  /**\n   * Returns the number of elements in the LiveMap.\n   */\n  get size() {\n    return this._map.size;\n  }\n  /**\n   * Returns a boolean indicating whether an element with the specified key exists or not.\n   * @param key The key of the element to test for presence.\n   */\n  has(key) {\n    return this._map.has(key);\n  }\n  /**\n   * Removes the specified element by key.\n   * @param key The key of the element to remove.\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    _optionalChain([this, 'access', _103 => _103._pool, 'optionalAccess', _104 => _104.assertStorageIsWritable, 'call', _105 => _105()]);\n    const item = this._map.get(key);\n    if (item === void 0) {\n      return false;\n    }\n    item._detach();\n    this._map.delete(key);\n    this.invalidate();\n    if (this._pool && item._id) {\n      const thisId = nn(this._id);\n      const storageUpdates = /* @__PURE__ */ new Map();\n      storageUpdates.set(thisId, {\n        node: this,\n        type: \"LiveMap\",\n        updates: { [key]: { type: \"delete\" } }\n      });\n      this._pool.dispatch(\n        [\n          {\n            type: 5 /* DELETE_CRDT */,\n            id: item._id,\n            opId: this._pool.generateOpId()\n          }\n        ],\n        item._toOps(thisId, key),\n        storageUpdates\n      );\n    }\n    return true;\n  }\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\n   */\n  entries() {\n    const innerIterator = this._map.entries();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const entry = iteratorValue.value;\n        const key = entry[0];\n        const value = liveNodeToLson(iteratorValue.value[1]);\n        return {\n          value: [key, value]\n        };\n      }\n    };\n  }\n  /**\n   * Same function object as the initial value of the entries method.\n   */\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  /**\n   * Returns a new Iterator object that contains the keys for each element.\n   */\n  keys() {\n    return this._map.keys();\n  }\n  /**\n   * Returns a new Iterator object that contains the values for each element.\n   */\n  values() {\n    const innerIterator = this._map.values();\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const iteratorValue = innerIterator.next();\n        if (iteratorValue.done) {\n          return {\n            done: true,\n            value: void 0\n          };\n        }\n        const value = liveNodeToLson(iteratorValue.value);\n        return { value };\n      }\n    };\n  }\n  /**\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\n   * @param callback Function to execute for each entry in the map.\n   */\n  forEach(callback) {\n    for (const entry of this) {\n      callback(entry[1], entry[0], this);\n    }\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    return {\n      type: \"LiveMap\",\n      id: _nullishCoalesce(this._id, () => ( nanoid())),\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, val]) => val.toTreeNode(key2)\n      )\n    };\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = /* @__PURE__ */ new Map();\n    for (const [key, value] of this._map) {\n      result.set(key, value.toImmutable());\n    }\n    return freeze(result);\n  }\n  clone() {\n    return new _LiveMap(\n      Array.from(this._map).map(([key, node]) => [key, node.clone()])\n    );\n  }\n};\n\n// src/crdts/LiveObject.ts\nvar LiveObject = class _LiveObject extends AbstractCrdt {\n  /** @internal */\n  static _buildRootAndParentToChildren(items) {\n    const parentToChildren = /* @__PURE__ */ new Map();\n    let root = null;\n    for (const [id, crdt] of items) {\n      if (isRootCrdt(crdt)) {\n        root = [id, crdt];\n      } else {\n        const tuple = [id, crdt];\n        const children = parentToChildren.get(crdt.parentId);\n        if (children !== void 0) {\n          children.push(tuple);\n        } else {\n          parentToChildren.set(crdt.parentId, [tuple]);\n        }\n      }\n    }\n    if (root === null) {\n      throw new Error(\"Root can't be null\");\n    }\n    return [root, parentToChildren];\n  }\n  /** @internal */\n  static _fromItems(items, pool) {\n    const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\n    return _LiveObject._deserialize(\n      root,\n      parentToChildren,\n      pool\n    );\n  }\n  constructor(obj = {}) {\n    super();\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\n    const o = compactObject(obj);\n    for (const key of Object.keys(o)) {\n      const value = o[key];\n      if (isLiveNode(value)) {\n        value._setParentLink(this, key);\n      }\n    }\n    this._map = new Map(Object.entries(o));\n  }\n  /** @internal */\n  _toOps(parentId, parentKey, pool) {\n    if (this._id === void 0) {\n      throw new Error(\"Cannot serialize item is not attached\");\n    }\n    const opId = _optionalChain([pool, 'optionalAccess', _106 => _106.generateOpId, 'call', _107 => _107()]);\n    const ops = [];\n    const op = {\n      type: 4 /* CREATE_OBJECT */,\n      id: this._id,\n      opId,\n      parentId,\n      parentKey,\n      data: {}\n    };\n    ops.push(op);\n    for (const [key, value] of this._map) {\n      if (isLiveNode(value)) {\n        ops.push(...value._toOps(this._id, key, pool));\n      } else {\n        op.data[key] = value;\n      }\n    }\n    return ops;\n  }\n  /** @internal */\n  static _deserialize([id, item], parentToChildren, pool) {\n    const liveObj = new _LiveObject(item.data);\n    liveObj._attach(id, pool);\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\n  }\n  /** @internal */\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\n    const children = parentToChildren.get(nn(liveObj._id));\n    if (children === void 0) {\n      return liveObj;\n    }\n    for (const [id, crdt] of children) {\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\n      if (isLiveStructure(child)) {\n        child._setParentLink(liveObj, crdt.parentKey);\n      }\n      liveObj._map.set(crdt.parentKey, child);\n      liveObj.invalidate();\n    }\n    return liveObj;\n  }\n  /** @internal */\n  _attach(id, pool) {\n    super._attach(id, pool);\n    for (const [_key, value] of this._map) {\n      if (isLiveNode(value)) {\n        value._attach(pool.generateId(), pool);\n      }\n    }\n  }\n  /** @internal */\n  _attachChild(op, source) {\n    if (this._pool === void 0) {\n      throw new Error(\"Can't attach child if managed pool is not present\");\n    }\n    const { id, opId, parentKey: key } = op;\n    const child = creationOpToLson(op);\n    if (this._pool.getNode(id) !== void 0) {\n      if (this._propToLastUpdate.get(key) === opId) {\n        this._propToLastUpdate.delete(key);\n      }\n      return { modified: false };\n    }\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\n      this._propToLastUpdate.set(key, nn(opId));\n    } else if (this._propToLastUpdate.get(key) === void 0) {\n    } else if (this._propToLastUpdate.get(key) === opId) {\n      this._propToLastUpdate.delete(key);\n      return { modified: false };\n    } else {\n      return { modified: false };\n    }\n    const thisId = nn(this._id);\n    const previousValue = this._map.get(key);\n    let reverse;\n    if (isLiveNode(previousValue)) {\n      reverse = previousValue._toOps(thisId, key);\n      previousValue._detach();\n    } else if (previousValue === void 0) {\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id: thisId,\n          data: { [key]: previousValue }\n        }\n      ];\n    }\n    this._map.set(key, child);\n    this.invalidate();\n    if (isLiveStructure(child)) {\n      child._setParentLink(this, key);\n      child._attach(id, this._pool);\n    }\n    return {\n      reverse,\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [key]: { type: \"update\" } }\n      }\n    };\n  }\n  /** @internal */\n  _detachChild(child) {\n    if (child) {\n      const id = nn(this._id);\n      const parentKey = nn(child._parentKey);\n      const reverse = child._toOps(id, parentKey, this._pool);\n      for (const [key, value] of this._map) {\n        if (value === child) {\n          this._map.delete(key);\n          this.invalidate();\n        }\n      }\n      child._detach();\n      const storageUpdate = {\n        node: this,\n        type: \"LiveObject\",\n        updates: {\n          [parentKey]: { type: \"delete\" }\n        }\n      };\n      return { modified: storageUpdate, reverse };\n    }\n    return { modified: false };\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    super._detach();\n    for (const value of this._map.values()) {\n      if (isLiveNode(value)) {\n        value._detach();\n      }\n    }\n  }\n  /** @internal */\n  _apply(op, isLocal) {\n    if (op.type === 3 /* UPDATE_OBJECT */) {\n      return this._applyUpdate(op, isLocal);\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\n      return this._applyDeleteObjectKey(op, isLocal);\n    }\n    return super._apply(op, isLocal);\n  }\n  /**\n   * @internal\n   */\n  _serialize() {\n    const data = {};\n    for (const [key, value] of this._map) {\n      if (!isLiveNode(value)) {\n        data[key] = value;\n      }\n    }\n    if (this.parent.type === \"HasParent\" && this.parent.node._id) {\n      return {\n        type: 0 /* OBJECT */,\n        parentId: this.parent.node._id,\n        parentKey: this.parent.key,\n        data\n      };\n    } else {\n      return {\n        type: 0 /* OBJECT */,\n        data\n      };\n    }\n  }\n  /** @internal */\n  _applyUpdate(op, isLocal) {\n    let isModified = false;\n    const id = nn(this._id);\n    const reverse = [];\n    const reverseUpdate = {\n      type: 3 /* UPDATE_OBJECT */,\n      id,\n      data: {}\n    };\n    for (const key in op.data) {\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverse.push(...oldValue._toOps(id, key));\n        oldValue._detach();\n      } else if (oldValue !== void 0) {\n        reverseUpdate.data[key] = oldValue;\n      } else if (oldValue === void 0) {\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\n      }\n    }\n    const updateDelta = {};\n    for (const key in op.data) {\n      const value = op.data[key];\n      if (value === void 0) {\n        continue;\n      }\n      if (isLocal) {\n        this._propToLastUpdate.set(key, nn(op.opId));\n      } else if (this._propToLastUpdate.get(key) === void 0) {\n        isModified = true;\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\n        this._propToLastUpdate.delete(key);\n        continue;\n      } else {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      isModified = true;\n      updateDelta[key] = { type: \"update\" };\n      this._map.set(key, value);\n      this.invalidate();\n    }\n    if (Object.keys(reverseUpdate.data).length !== 0) {\n      reverse.unshift(reverseUpdate);\n    }\n    return isModified ? {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: updateDelta\n      },\n      reverse\n    } : { modified: false };\n  }\n  /** @internal */\n  _applyDeleteObjectKey(op, isLocal) {\n    const key = op.key;\n    if (this._map.has(key) === false) {\n      return { modified: false };\n    }\n    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\n      return { modified: false };\n    }\n    const oldValue = this._map.get(key);\n    const id = nn(this._id);\n    let reverse = [];\n    if (isLiveNode(oldValue)) {\n      reverse = oldValue._toOps(id, op.key);\n      oldValue._detach();\n    } else if (oldValue !== void 0) {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          id,\n          data: { [key]: oldValue }\n        }\n      ];\n    }\n    this._map.delete(key);\n    this.invalidate();\n    return {\n      modified: {\n        node: this,\n        type: \"LiveObject\",\n        updates: { [op.key]: { type: \"delete\" } }\n      },\n      reverse\n    };\n  }\n  /**\n   * Transform the LiveObject into a javascript object\n   */\n  toObject() {\n    return Object.fromEntries(this._map);\n  }\n  /**\n   * Adds or updates a property with a specified key and a value.\n   * @param key The key of the property to add\n   * @param value The value of the property to add\n   */\n  set(key, value) {\n    _optionalChain([this, 'access', _108 => _108._pool, 'optionalAccess', _109 => _109.assertStorageIsWritable, 'call', _110 => _110()]);\n    this.update({ [key]: value });\n  }\n  /**\n   * Returns a specified property from the LiveObject.\n   * @param key The key of the property to get\n   */\n  get(key) {\n    return this._map.get(key);\n  }\n  /**\n   * Deletes a key from the LiveObject\n   * @param key The key of the property to delete\n   */\n  delete(key) {\n    _optionalChain([this, 'access', _111 => _111._pool, 'optionalAccess', _112 => _112.assertStorageIsWritable, 'call', _113 => _113()]);\n    const keyAsString = key;\n    const oldValue = this._map.get(keyAsString);\n    if (oldValue === void 0) {\n      return;\n    }\n    if (this._pool === void 0 || this._id === void 0) {\n      if (isLiveNode(oldValue)) {\n        oldValue._detach();\n      }\n      this._map.delete(keyAsString);\n      this.invalidate();\n      return;\n    }\n    let reverse;\n    if (isLiveNode(oldValue)) {\n      oldValue._detach();\n      reverse = oldValue._toOps(this._id, keyAsString);\n    } else {\n      reverse = [\n        {\n          type: 3 /* UPDATE_OBJECT */,\n          data: { [keyAsString]: oldValue },\n          id: this._id\n        }\n      ];\n    }\n    this._map.delete(keyAsString);\n    this.invalidate();\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: { [key]: { type: \"delete\" } }\n    });\n    this._pool.dispatch(\n      [\n        {\n          type: 6 /* DELETE_OBJECT_KEY */,\n          key: keyAsString,\n          id: this._id,\n          opId: this._pool.generateOpId()\n        }\n      ],\n      reverse,\n      storageUpdates\n    );\n  }\n  /**\n   * Adds or updates multiple properties at once with an object.\n   * @param patch The object used to overrides properties\n   */\n  update(patch) {\n    _optionalChain([this, 'access', _114 => _114._pool, 'optionalAccess', _115 => _115.assertStorageIsWritable, 'call', _116 => _116()]);\n    if (this._pool === void 0 || this._id === void 0) {\n      for (const key in patch) {\n        const newValue = patch[key];\n        if (newValue === void 0) {\n          continue;\n        }\n        const oldValue = this._map.get(key);\n        if (isLiveNode(oldValue)) {\n          oldValue._detach();\n        }\n        if (isLiveNode(newValue)) {\n          newValue._setParentLink(this, key);\n        }\n        this._map.set(key, newValue);\n        this.invalidate();\n      }\n      return;\n    }\n    const ops = [];\n    const reverseOps = [];\n    const opId = this._pool.generateOpId();\n    const updatedProps = {};\n    const reverseUpdateOp = {\n      id: this._id,\n      type: 3 /* UPDATE_OBJECT */,\n      data: {}\n    };\n    const updateDelta = {};\n    for (const key in patch) {\n      const newValue = patch[key];\n      if (newValue === void 0) {\n        continue;\n      }\n      const oldValue = this._map.get(key);\n      if (isLiveNode(oldValue)) {\n        reverseOps.push(...oldValue._toOps(this._id, key));\n        oldValue._detach();\n      } else if (oldValue === void 0) {\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\n      } else {\n        reverseUpdateOp.data[key] = oldValue;\n      }\n      if (isLiveNode(newValue)) {\n        newValue._setParentLink(this, key);\n        newValue._attach(this._pool.generateId(), this._pool);\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\n        const createCrdtOp = newAttachChildOps.find(\n          (op) => op.parentId === this._id\n        );\n        if (createCrdtOp) {\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\n        }\n        ops.push(...newAttachChildOps);\n      } else {\n        updatedProps[key] = newValue;\n        this._propToLastUpdate.set(key, opId);\n      }\n      this._map.set(key, newValue);\n      this.invalidate();\n      updateDelta[key] = { type: \"update\" };\n    }\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\n      reverseOps.unshift(reverseUpdateOp);\n    }\n    if (Object.keys(updatedProps).length !== 0) {\n      ops.unshift({\n        opId,\n        id: this._id,\n        type: 3 /* UPDATE_OBJECT */,\n        data: updatedProps\n      });\n    }\n    const storageUpdates = /* @__PURE__ */ new Map();\n    storageUpdates.set(this._id, {\n      node: this,\n      type: \"LiveObject\",\n      updates: updateDelta\n    });\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\n  }\n  toImmutable() {\n    return super.toImmutable();\n  }\n  /** @internal */\n  toTreeNode(key) {\n    return super.toTreeNode(key);\n  }\n  /** @internal */\n  _toTreeNode(key) {\n    const nodeId = _nullishCoalesce(this._id, () => ( nanoid()));\n    return {\n      type: \"LiveObject\",\n      id: nodeId,\n      key,\n      payload: Array.from(this._map.entries()).map(\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \"Json\", id: `${nodeId}:${key2}`, key: key2, payload: value }\n      )\n    };\n  }\n  /** @internal */\n  _toImmutable() {\n    const result = {};\n    for (const [key, val] of this._map) {\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\n    }\n    return process.env.NODE_ENV === \"production\" ? result : Object.freeze(result);\n  }\n  clone() {\n    return new _LiveObject(\n      Object.fromEntries(\n        Array.from(this._map).map(([key, value]) => [\n          key,\n          isLiveStructure(value) ? value.clone() : deepClone(value)\n        ])\n      )\n    );\n  }\n};\n\n// src/crdts/liveblocks-helpers.ts\nfunction creationOpToLiveNode(op) {\n  return lsonToLiveNode(creationOpToLson(op));\n}\nfunction creationOpToLson(op) {\n  switch (op.type) {\n    case 8 /* CREATE_REGISTER */:\n      return op.data;\n    case 4 /* CREATE_OBJECT */:\n      return new LiveObject(op.data);\n    case 7 /* CREATE_MAP */:\n      return new LiveMap();\n    case 2 /* CREATE_LIST */:\n      return new LiveList([]);\n    default:\n      return assertNever(op, \"Unknown creation Op\");\n  }\n}\nfunction isSameNodeOrChildOf(node, parent) {\n  if (node === parent) {\n    return true;\n  }\n  if (node.parent.type === \"HasParent\") {\n    return isSameNodeOrChildOf(node.parent.node, parent);\n  }\n  return false;\n}\nfunction deserialize([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\n  switch (crdt.type) {\n    case 0 /* OBJECT */: {\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 1 /* LIST */: {\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 2 /* MAP */: {\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\n    }\n    case 3 /* REGISTER */: {\n      return crdt.data;\n    }\n    default: {\n      throw new Error(\"Unexpected CRDT type\");\n    }\n  }\n}\nfunction isLiveStructure(value) {\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\n}\nfunction isLiveNode(value) {\n  return isLiveStructure(value) || isLiveRegister(value);\n}\nfunction isLiveList(value) {\n  return value instanceof LiveList;\n}\nfunction isLiveMap(value) {\n  return value instanceof LiveMap;\n}\nfunction isLiveObject(value) {\n  return value instanceof LiveObject;\n}\nfunction isLiveRegister(value) {\n  return value instanceof LiveRegister;\n}\nfunction cloneLson(value) {\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\n}\nfunction liveNodeToLson(obj) {\n  if (obj instanceof LiveRegister) {\n    return obj.data;\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\n    return obj;\n  } else {\n    return assertNever(obj, \"Unknown AbstractCrdt\");\n  }\n}\nfunction lsonToLiveNode(value) {\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\n    return value;\n  } else {\n    return new LiveRegister(value);\n  }\n}\nfunction getTreesDiffOperations(currentItems, newItems) {\n  const ops = [];\n  currentItems.forEach((_, id) => {\n    if (!newItems.get(id)) {\n      ops.push({\n        type: 5 /* DELETE_CRDT */,\n        id\n      });\n    }\n  });\n  newItems.forEach((crdt, id) => {\n    const currentCrdt = currentItems.get(id);\n    if (currentCrdt) {\n      if (crdt.type === 0 /* OBJECT */) {\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\n          ops.push({\n            type: 3 /* UPDATE_OBJECT */,\n            id,\n            data: crdt.data\n          });\n        }\n      }\n      if (crdt.parentKey !== currentCrdt.parentKey) {\n        ops.push({\n          type: 1 /* SET_PARENT_KEY */,\n          id,\n          parentKey: nn(crdt.parentKey, \"Parent key must not be missing\")\n        });\n      }\n    } else {\n      switch (crdt.type) {\n        case 3 /* REGISTER */:\n          ops.push({\n            type: 8 /* CREATE_REGISTER */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 1 /* LIST */:\n          ops.push({\n            type: 2 /* CREATE_LIST */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n        case 0 /* OBJECT */:\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\n            throw new Error(\n              \"Internal error. Cannot serialize storage root into an operation\"\n            );\n          }\n          ops.push({\n            type: 4 /* CREATE_OBJECT */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey,\n            data: crdt.data\n          });\n          break;\n        case 2 /* MAP */:\n          ops.push({\n            type: 7 /* CREATE_MAP */,\n            id,\n            parentId: crdt.parentId,\n            parentKey: crdt.parentKey\n          });\n          break;\n      }\n    }\n  });\n  return ops;\n}\nfunction mergeObjectStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeMapStorageUpdates(first, second) {\n  const updates = first.updates;\n  for (const [key, value] of entries(second.updates)) {\n    updates[key] = value;\n  }\n  return {\n    ...second,\n    updates\n  };\n}\nfunction mergeListStorageUpdates(first, second) {\n  const updates = first.updates;\n  return {\n    ...second,\n    updates: updates.concat(second.updates)\n  };\n}\nfunction mergeStorageUpdates(first, second) {\n  if (first === void 0) {\n    return second;\n  }\n  if (first.type === \"LiveObject\" && second.type === \"LiveObject\") {\n    return mergeObjectStorageUpdates(first, second);\n  } else if (first.type === \"LiveMap\" && second.type === \"LiveMap\") {\n    return mergeMapStorageUpdates(first, second);\n  } else if (first.type === \"LiveList\" && second.type === \"LiveList\") {\n    return mergeListStorageUpdates(first, second);\n  } else {\n  }\n  return second;\n}\nfunction isPlain(value) {\n  const type = typeof value;\n  return value === void 0 || value === null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(value) || isPlainObject(value);\n}\nfunction findNonSerializableValue(value, path = \"\") {\n  if (!isPlain) {\n    return {\n      path: path || \"root\",\n      value\n    };\n  }\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  for (const [key, nestedValue] of Object.entries(value)) {\n    const nestedPath = path ? path + \".\" + key : key;\n    if (!isPlain(nestedValue)) {\n      return {\n        path: nestedPath,\n        value: nestedValue\n      };\n    }\n    if (typeof nestedValue === \"object\") {\n      const nonSerializableNestedValue = findNonSerializableValue(\n        nestedValue,\n        nestedPath\n      );\n      if (nonSerializableNestedValue) {\n        return nonSerializableNestedValue;\n      }\n    }\n  }\n  return false;\n}\n\n// src/lib/chunk.ts\nfunction chunk(array, size) {\n  const chunks = [];\n  for (let i = 0, j = array.length; i < j; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\n\n// src/lib/createIds.ts\nvar THREAD_ID_PREFIX = \"th\";\nvar COMMENT_ID_PREFIX = \"cm\";\nvar COMMENT_ATTACHMENT_ID_PREFIX = \"at\";\nvar INBOX_NOTIFICATION_ID_PREFIX = \"in\";\nfunction createOptimisticId(prefix) {\n  return `${prefix}_${nanoid()}`;\n}\nfunction createThreadId() {\n  return createOptimisticId(THREAD_ID_PREFIX);\n}\nfunction createCommentId() {\n  return createOptimisticId(COMMENT_ID_PREFIX);\n}\nfunction createCommentAttachmentId() {\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\n}\nfunction createInboxNotificationId() {\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\n}\n\n// src/lib/debug.ts\nfunction captureStackTrace(msg, traceRoot) {\n  const errorLike = { name: msg };\n  if (typeof Error.captureStackTrace !== \"function\") {\n    return void 0;\n  }\n  Error.captureStackTrace(errorLike, traceRoot);\n  return errorLike.stack;\n}\n\n// src/lib/Json.ts\nfunction isJsonScalar(data) {\n  return data === null || typeof data === \"string\" || typeof data === \"number\" || typeof data === \"boolean\";\n}\nfunction isJsonArray(data) {\n  return Array.isArray(data);\n}\nfunction isJsonObject(data) {\n  return !isJsonScalar(data) && !isJsonArray(data);\n}\n\n// src/lib/objectToQuery.ts\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nfunction objectToQuery(obj) {\n  let filterList = [];\n  const entries2 = Object.entries(obj);\n  const keyValuePairs = [];\n  const keyValuePairsWithOperator = [];\n  const indexedKeys = [];\n  entries2.forEach(([key, value]) => {\n    if (!identifierRegex.test(key)) {\n      throw new Error(\"Key must only contain letters, numbers, _\");\n    }\n    if (isSimpleValue(value)) {\n      keyValuePairs.push([key, value]);\n    } else if (isValueWithOperator(value)) {\n      keyValuePairsWithOperator.push([key, value]);\n    } else if (typeof value === \"object\" && !(\"startsWith\" in value)) {\n      indexedKeys.push([key, value]);\n    }\n  });\n  filterList = [\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\n  ];\n  indexedKeys.forEach(([key, value]) => {\n    const nestedEntries = Object.entries(value);\n    const nKeyValuePairs = [];\n    const nKeyValuePairsWithOperator = [];\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\n      if (isStringEmpty(nestedKey)) {\n        throw new Error(\"Key cannot be empty\");\n      }\n      if (isSimpleValue(nestedValue)) {\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\n      } else if (isValueWithOperator(nestedValue)) {\n        nKeyValuePairsWithOperator.push([\n          formatFilterKey(key, nestedKey),\n          nestedValue\n        ]);\n      }\n    });\n    filterList = [\n      ...filterList,\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\n    ];\n  });\n  return filterList.map(\n    ({ key, operator, value }) => formatFilter(key, operator, formatFilterValue(value))\n  ).join(\" AND \");\n}\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\n  const filters = [];\n  keyValuePairs.forEach(([key, value]) => {\n    filters.push({\n      key,\n      operator: \":\",\n      value\n    });\n  });\n  return filters;\n};\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\n  const filters = [];\n  keyValuePairsWithOperator.forEach(([key, value]) => {\n    if (\"startsWith\" in value && typeof value.startsWith === \"string\") {\n      filters.push({\n        key,\n        operator: \"^\",\n        value: value.startsWith\n      });\n    }\n  });\n  return filters;\n};\nvar isSimpleValue = (value) => {\n  if (typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  return false;\n};\nvar isValueWithOperator = (value) => {\n  if (typeof value === \"object\" && value !== null && \"startsWith\" in value) {\n    return true;\n  }\n  return false;\n};\nvar formatFilter = (key, operator, value) => {\n  return `${key}${operator}${value}`;\n};\nvar formatFilterKey = (key, nestedKey) => {\n  if (nestedKey) {\n    return `${key}[${JSON.stringify(nestedKey)}]`;\n  }\n  return key;\n};\nvar formatFilterValue = (value) => {\n  if (typeof value === \"string\") {\n    if (isStringEmpty(value)) {\n      throw new Error(\"Value cannot be empty\");\n    }\n    return JSON.stringify(value);\n  }\n  return value.toString();\n};\nvar isStringEmpty = (value) => {\n  return !value || value.toString().trim() === \"\";\n};\n\n// src/protocol/ClientMsg.ts\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_PRESENCE\"] = 100] = \"UPDATE_PRESENCE\";\n  ClientMsgCode2[ClientMsgCode2[\"BROADCAST_EVENT\"] = 103] = \"BROADCAST_EVENT\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_STORAGE\"] = 200] = \"FETCH_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_STORAGE\"] = 201] = \"UPDATE_STORAGE\";\n  ClientMsgCode2[ClientMsgCode2[\"FETCH_YDOC\"] = 300] = \"FETCH_YDOC\";\n  ClientMsgCode2[ClientMsgCode2[\"UPDATE_YDOC\"] = 301] = \"UPDATE_YDOC\";\n  return ClientMsgCode2;\n})(ClientMsgCode || {});\n\n// src/refs/ImmutableRef.ts\nfunction merge(target, patch) {\n  let updated = false;\n  const newValue = { ...target };\n  Object.keys(patch).forEach((k) => {\n    const key = k;\n    const val = patch[key];\n    if (newValue[key] !== val) {\n      if (val === void 0) {\n        delete newValue[key];\n      } else {\n        newValue[key] = val;\n      }\n      updated = true;\n    }\n  });\n  return updated ? newValue : target;\n}\nvar ImmutableRef = class {\n  constructor() {\n    this._ev = makeEventSource();\n  }\n  get didInvalidate() {\n    return this._ev.observable;\n  }\n  invalidate() {\n    if (this._cache !== void 0) {\n      this._cache = void 0;\n      this._ev.notify();\n    }\n  }\n  get current() {\n    return _nullishCoalesce(this._cache, () => ( (this._cache = this._toImmutable())));\n  }\n};\n\n// src/refs/OthersRef.ts\nfunction makeUser(conn, presence) {\n  const { connectionId, id, info } = conn;\n  const canWrite = canWriteStorage(conn.scopes);\n  return freeze(\n    compactObject({\n      connectionId,\n      id,\n      info,\n      canWrite,\n      canComment: canComment(conn.scopes),\n      isReadOnly: !canWrite,\n      // Deprecated, kept for backward-compatibility\n      presence\n    })\n  );\n}\nvar OthersRef = class extends ImmutableRef {\n  //\n  // --------------------------------------------------------------\n  //\n  constructor() {\n    super();\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n  }\n  connectionIds() {\n    return this._connections.keys();\n  }\n  /** @internal */\n  _toImmutable() {\n    const users = compact(\n      Array.from(this._presences.keys()).map(\n        (connectionId) => this.getUser(Number(connectionId))\n      )\n    );\n    return users;\n  }\n  clearOthers() {\n    this._connections = /* @__PURE__ */ new Map();\n    this._presences = /* @__PURE__ */ new Map();\n    this._users = /* @__PURE__ */ new Map();\n    this.invalidate();\n  }\n  /** @internal */\n  _getUser(connectionId) {\n    const conn = this._connections.get(connectionId);\n    const presence = this._presences.get(connectionId);\n    if (conn !== void 0 && presence !== void 0) {\n      return makeUser(conn, presence);\n    }\n    return void 0;\n  }\n  getUser(connectionId) {\n    const cachedUser = this._users.get(connectionId);\n    if (cachedUser) {\n      return cachedUser;\n    }\n    const computedUser = this._getUser(connectionId);\n    if (computedUser) {\n      this._users.set(connectionId, computedUser);\n      return computedUser;\n    }\n    return void 0;\n  }\n  /** @internal */\n  _invalidateUser(connectionId) {\n    if (this._users.has(connectionId)) {\n      this._users.delete(connectionId);\n    }\n    this.invalidate();\n  }\n  /**\n   * Records a known connection. This records the connection ID and the\n   * associated metadata.\n   */\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\n    this._connections.set(\n      connectionId,\n      freeze({\n        connectionId,\n        id: metaUserId,\n        info: metaUserInfo,\n        scopes\n      })\n    );\n    if (this._presences.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Removes a known connectionId. Removes both the connection's metadata and\n   * the presence information.\n   */\n  removeConnection(connectionId) {\n    this._connections.delete(connectionId);\n    this._presences.delete(connectionId);\n    this._invalidateUser(connectionId);\n  }\n  /**\n   * Stores a new user from a full presence update. If the user already exists,\n   * its known presence data is overwritten.\n   */\n  setOther(connectionId, presence) {\n    this._presences.set(connectionId, freeze(compactObject(presence)));\n    if (this._connections.has(connectionId)) {\n      this._invalidateUser(connectionId);\n    }\n  }\n  /**\n   * Patches the presence data for an existing \"other\". If we don't know the\n   * initial presence data for this user yet, discard this patch and await the\n   * full .setOther() call first.\n   */\n  patchOther(connectionId, patch) {\n    const oldPresence = this._presences.get(connectionId);\n    if (oldPresence === void 0) {\n      return;\n    }\n    const newPresence = merge(oldPresence, patch);\n    if (oldPresence !== newPresence) {\n      this._presences.set(connectionId, freeze(newPresence));\n      this._invalidateUser(connectionId);\n    }\n  }\n};\n\n// src/refs/PatchableRef.ts\nvar PatchableRef = class extends ImmutableRef {\n  constructor(data) {\n    super();\n    this._data = freeze(compactObject(data));\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._data;\n  }\n  /**\n   * Patches the current object.\n   */\n  patch(patch) {\n    const oldData = this._data;\n    const newData = merge(oldData, patch);\n    if (oldData !== newData) {\n      this._data = freeze(newData);\n      this.invalidate();\n    }\n  }\n};\n\n// src/refs/ValueRef.ts\nvar ValueRef = class extends ImmutableRef {\n  constructor(initialValue) {\n    super();\n    this._value = freeze(initialValue);\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._value;\n  }\n  set(newValue) {\n    this._value = freeze(newValue);\n    this.invalidate();\n  }\n};\nvar DerivedRef = class extends ImmutableRef {\n  constructor(...args) {\n    super();\n    const transformFn = args.pop();\n    const otherRefs = args;\n    this._refs = otherRefs;\n    this._refs.forEach((ref) => {\n      ref.didInvalidate.subscribe(() => this.invalidate());\n    });\n    this._transform = transformFn;\n  }\n  /** @internal */\n  _toImmutable() {\n    return this._transform(\n      ...this._refs.map((ref) => ref.current)\n    );\n  }\n};\n\n// src/room.ts\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\nfunction makeIdFactory(connectionId) {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\nfunction userToTreeNode(key, user) {\n  return {\n    type: \"User\",\n    id: `${user.connectionId}`,\n    key,\n    payload: {\n      connectionId: user.connectionId,\n      id: user.id,\n      info: user.info,\n      presence: user.presence,\n      isReadOnly: !user.canWrite\n    }\n  };\n}\nfunction installBackgroundTabSpy() {\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const inBackgroundSince = { current: null };\n  function onVisibilityChange() {\n    if (_optionalChain([doc, 'optionalAccess', _117 => _117.visibilityState]) === \"hidden\") {\n      inBackgroundSince.current = _nullishCoalesce(inBackgroundSince.current, () => ( Date.now()));\n    } else {\n      inBackgroundSince.current = null;\n    }\n  }\n  _optionalChain([doc, 'optionalAccess', _118 => _118.addEventListener, 'call', _119 => _119(\"visibilitychange\", onVisibilityChange)]);\n  const unsub = () => {\n    _optionalChain([doc, 'optionalAccess', _120 => _120.removeEventListener, 'call', _121 => _121(\"visibilitychange\", onVisibilityChange)]);\n  };\n  return [inBackgroundSince, unsub];\n}\nvar GET_ATTACHMENT_URLS_BATCH_DELAY = 50;\nvar ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;\nvar ATTACHMENT_PART_BATCH_SIZE = 5;\nvar RETRY_ATTEMPTS = 10;\nvar RETRY_DELAYS = [\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3,\n  2e3\n];\nfunction splitFileIntoParts(file) {\n  const parts = [];\n  let start = 0;\n  while (start < file.size) {\n    const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\n    parts.push({\n      partNumber: parts.length + 1,\n      part: file.slice(start, end)\n    });\n    start = end;\n  }\n  return parts;\n}\nfunction createRoom(options, config) {\n  const initialPresence = options.initialPresence;\n  const initialStorage = options.initialStorage;\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\n  const delegates = {\n    ...config.delegates,\n    // A connection is allowed to go into \"zombie state\" only if all of the\n    // following conditions apply:\n    //\n    // - The `backgroundKeepAliveTimeout` client option is configured\n    // - The browser window has been in the background for at least\n    //   `backgroundKeepAliveTimeout` milliseconds\n    // - There are no pending changes\n    //\n    canZombie() {\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \"synchronizing\";\n    }\n  };\n  const managedSocket = new ManagedSocket(\n    delegates,\n    config.enableDebugLogging\n  );\n  const context = {\n    buffer: {\n      flushTimerID: void 0,\n      lastFlushedAt: 0,\n      presenceUpdates: (\n        // Queue up the initial presence message as a Full Presence™ update\n        {\n          type: \"full\",\n          data: initialPresence\n        }\n      ),\n      messages: [],\n      storageOperations: []\n    },\n    staticSessionInfo: new ValueRef(null),\n    dynamicSessionInfo: new ValueRef(null),\n    myPresence: new PatchableRef(initialPresence),\n    others: new OthersRef(),\n    initialStorage,\n    idFactory: null,\n    // Y.js\n    provider: void 0,\n    onProviderUpdate: makeEventSource(),\n    // Storage\n    clock: 0,\n    opClock: 0,\n    nodes: /* @__PURE__ */ new Map(),\n    root: void 0,\n    undoStack: [],\n    redoStack: [],\n    pausedHistory: null,\n    activeBatch: null,\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\n    // Debug\n    opStackTraces: process.env.NODE_ENV !== \"production\" ? /* @__PURE__ */ new Map() : void 0\n  };\n  const doNotBatchUpdates = (cb) => cb();\n  const batchUpdates = _nullishCoalesce(config.unstable_batchedUpdates, () => ( doNotBatchUpdates));\n  let lastTokenKey;\n  function onStatusDidChange(newStatus) {\n    const authValue = managedSocket.authValue;\n    if (authValue !== null) {\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\n      if (tokenKey !== lastTokenKey) {\n        lastTokenKey = tokenKey;\n        if (authValue.type === \"secret\") {\n          const token = authValue.token.parsed;\n          context.staticSessionInfo.set({\n            userId: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.id : token.uid,\n            userInfo: token.k === \"sec-legacy\" /* SECRET_LEGACY */ ? token.info : token.ui\n          });\n        } else {\n          context.staticSessionInfo.set({\n            userId: void 0,\n            userInfo: void 0\n          });\n        }\n      }\n    }\n    batchUpdates(() => {\n      eventHub.status.notify(newStatus);\n      notifySelfChanged(doNotBatchUpdates);\n    });\n  }\n  let _connectionLossTimerId;\n  let _hasLostConnection = false;\n  function handleConnectionLossEvent(newStatus) {\n    if (newStatus === \"reconnecting\") {\n      _connectionLossTimerId = setTimeout(() => {\n        batchUpdates(() => {\n          eventHub.lostConnection.notify(\"lost\");\n          _hasLostConnection = true;\n          context.others.clearOthers();\n          notify({ others: [{ type: \"reset\" }] }, doNotBatchUpdates);\n        });\n      }, config.lostConnectionTimeout);\n    } else {\n      clearTimeout(_connectionLossTimerId);\n      if (_hasLostConnection) {\n        if (newStatus === \"disconnected\") {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"failed\");\n          });\n        } else {\n          batchUpdates(() => {\n            eventHub.lostConnection.notify(\"restored\");\n          });\n        }\n        _hasLostConnection = false;\n      }\n    }\n  }\n  function onDidConnect() {\n    context.buffer.presenceUpdates = {\n      type: \"full\",\n      data: (\n        // Because context.me.current is a readonly object, we'll have to\n        // make a copy here. Otherwise, type errors happen later when\n        // \"patching\" my presence.\n        { ...context.myPresence.current }\n      )\n    };\n    if (_getStorage$ !== null) {\n      refreshStorage({ flush: false });\n    }\n    flushNowOrSoon();\n  }\n  function onDidDisconnect() {\n    clearTimeout(context.buffer.flushTimerID);\n  }\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\n  managedSocket.events.didConnect.subscribe(onDidConnect);\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\n    batchUpdates(() => {\n      if (process.env.NODE_ENV !== \"production\") {\n        error2(\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\n        );\n      }\n      eventHub.error.notify(err);\n    });\n  });\n  const pool = {\n    roomId: config.roomId,\n    getNode: (id) => context.nodes.get(id),\n    addNode: (id, node) => void context.nodes.set(id, node),\n    deleteNode: (id) => void context.nodes.delete(id),\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\n    dispatch(ops, reverse, storageUpdates) {\n      const activeBatch = context.activeBatch;\n      if (process.env.NODE_ENV !== \"production\") {\n        const stackTrace = captureStackTrace(\"Storage mutation\", this.dispatch);\n        if (stackTrace) {\n          for (const op of ops) {\n            if (op.opId) {\n              nn(context.opStackTraces).set(op.opId, stackTrace);\n            }\n          }\n        }\n      }\n      if (activeBatch) {\n        for (const op of ops) {\n          activeBatch.ops.push(op);\n        }\n        for (const [key, value] of storageUpdates) {\n          activeBatch.updates.storageUpdates.set(\n            key,\n            mergeStorageUpdates(\n              activeBatch.updates.storageUpdates.get(key),\n              value\n            )\n          );\n        }\n        activeBatch.reverseOps.unshift(...reverse);\n      } else {\n        batchUpdates(() => {\n          addToUndoStack(reverse, doNotBatchUpdates);\n          context.redoStack.length = 0;\n          dispatchOps(ops);\n          notify({ storageUpdates }, doNotBatchUpdates);\n        });\n      }\n    },\n    assertStorageIsWritable: () => {\n      const scopes = _optionalChain([context, 'access', _122 => _122.dynamicSessionInfo, 'access', _123 => _123.current, 'optionalAccess', _124 => _124.scopes]);\n      if (scopes === void 0) {\n        return;\n      }\n      const canWrite = canWriteStorage(scopes);\n      if (!canWrite) {\n        throw new Error(\n          \"Cannot write to storage with a read only user, please ensure the user has write permissions\"\n        );\n      }\n    }\n  };\n  const eventHub = {\n    status: makeEventSource(),\n    // New/recommended API\n    lostConnection: makeEventSource(),\n    customEvent: makeEventSource(),\n    self: makeEventSource(),\n    myPresence: makeEventSource(),\n    others: makeEventSource(),\n    error: makeEventSource(),\n    storageBatch: makeEventSource(),\n    history: makeEventSource(),\n    storageDidLoad: makeEventSource(),\n    storageStatus: makeEventSource(),\n    ydoc: makeEventSource(),\n    comments: makeEventSource()\n  };\n  const fetchPolyfill = _optionalChain([config, 'access', _125 => _125.polyfills, 'optionalAccess', _126 => _126.fetch]) || /* istanbul ignore next */\n  _optionalChain([globalThis, 'access', _127 => _127.fetch, 'optionalAccess', _128 => _128.bind, 'call', _129 => _129(globalThis)]);\n  const httpClient1 = new HttpClient(\n    config.baseUrl,\n    fetchPolyfill,\n    () => Promise.resolve(_nullishCoalesce(managedSocket.authValue, () => ( raise(\"Not authorized\"))))\n  );\n  const httpClient2 = new HttpClient(\n    config.baseUrl,\n    fetchPolyfill,\n    () => (\n      // TODO: Use the right scope\n      delegates.authenticate()\n    )\n  );\n  async function createTextMention(userId, mentionId) {\n    await httpClient1.rawPost(url`/v2/c/rooms/${config.roomId}/text-mentions`, {\n      userId,\n      mentionId\n    });\n  }\n  async function deleteTextMention(mentionId) {\n    await httpClient1.rawDelete(\n      url`/v2/c/rooms/${config.roomId}/text-mentions/${mentionId}`\n    );\n  }\n  async function reportTextEditor(type, rootKey) {\n    await httpClient2.rawPost(url`/v2/c/rooms/${config.roomId}/text-metadata`, {\n      type,\n      rootKey\n    });\n  }\n  async function listTextVersions() {\n    const result = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/versions`);\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function listTextVersionsSince(options2) {\n    const result = await httpClient2.get(\n      url`/v2/c/rooms/${config.roomId}/versions/delta`,\n      { since: options2.since.toISOString() },\n      { signal: options2.signal }\n    );\n    return {\n      versions: result.versions.map(({ createdAt, ...version }) => {\n        return {\n          createdAt: new Date(createdAt),\n          ...version\n        };\n      }),\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function getTextVersion(versionId) {\n    return httpClient2.rawGet(\n      url`/v2/c/rooms/${config.roomId}/y-version/${versionId}`\n    );\n  }\n  async function createTextVersion() {\n    await httpClient2.rawPost(url`/v2/c/rooms/${config.roomId}/version`);\n  }\n  function sendMessages(messages) {\n    const serializedPayload = JSON.stringify(messages);\n    const nonce = _optionalChain([context, 'access', _130 => _130.dynamicSessionInfo, 'access', _131 => _131.current, 'optionalAccess', _132 => _132.nonce]);\n    if (config.unstable_fallbackToHTTP && nonce) {\n      const size = new TextEncoder().encode(serializedPayload).length;\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\n        void httpClient1.rawPost(url`/v2/c/rooms/${config.roomId}/send-message`, {\n          nonce,\n          messages\n        }).then((resp) => {\n          if (!resp.ok && resp.status === 403) {\n            managedSocket.reconnect();\n          }\n        });\n        warn(\n          \"Message was too large for websockets and sent over HTTP instead\"\n        );\n        return;\n      }\n    }\n    managedSocket.send(serializedPayload);\n  }\n  const self = new DerivedRef(\n    context.staticSessionInfo,\n    context.dynamicSessionInfo,\n    context.myPresence,\n    (staticSession, dynamicSession, myPresence) => {\n      if (staticSession === null || dynamicSession === null) {\n        return null;\n      } else {\n        const canWrite = canWriteStorage(dynamicSession.scopes);\n        return {\n          connectionId: dynamicSession.actor,\n          id: staticSession.userId,\n          info: staticSession.userInfo,\n          presence: myPresence,\n          canWrite,\n          canComment: canComment(dynamicSession.scopes)\n        };\n      }\n    }\n  );\n  let _lastSelf;\n  function notifySelfChanged(batchedUpdatesWrapper) {\n    const currSelf = self.current;\n    if (currSelf !== null && currSelf !== _lastSelf) {\n      batchedUpdatesWrapper(() => {\n        eventHub.self.notify(currSelf);\n      });\n      _lastSelf = currSelf;\n    }\n  }\n  const selfAsTreeNode = new DerivedRef(\n    self,\n    (me) => me !== null ? userToTreeNode(\"Me\", me) : null\n  );\n  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\n    if (message.items.length === 0) {\n      throw new Error(\"Internal error: cannot load storage without items\");\n    }\n    if (context.root !== void 0) {\n      updateRoot(message.items, batchedUpdatesWrapper);\n    } else {\n      context.root = LiveObject._fromItems(message.items, pool);\n    }\n    const canWrite = _nullishCoalesce(_optionalChain([self, 'access', _133 => _133.current, 'optionalAccess', _134 => _134.canWrite]), () => ( true));\n    const stackSizeBefore = context.undoStack.length;\n    for (const key in context.initialStorage) {\n      if (context.root.get(key) === void 0) {\n        if (canWrite) {\n          context.root.set(key, cloneLson(context.initialStorage[key]));\n        } else {\n          warn(\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\n          );\n        }\n      }\n    }\n    context.undoStack.length = stackSizeBefore;\n  }\n  function updateRoot(items, batchedUpdatesWrapper) {\n    if (context.root === void 0) {\n      return;\n    }\n    const currentItems = /* @__PURE__ */ new Map();\n    for (const [id, node] of context.nodes) {\n      currentItems.set(id, node._serialize());\n    }\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\n    const result = applyOps(ops, false);\n    notify(result.updates, batchedUpdatesWrapper);\n  }\n  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.undoStack.length >= 50) {\n      context.undoStack.shift();\n    }\n    context.undoStack.push(historyOps);\n    onHistoryChange(batchedUpdatesWrapper);\n  }\n  function addToUndoStack(historyOps, batchedUpdatesWrapper) {\n    if (context.pausedHistory !== null) {\n      context.pausedHistory.unshift(...historyOps);\n    } else {\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\n    }\n  }\n  function notify(updates, batchedUpdatesWrapper) {\n    const storageUpdates = updates.storageUpdates;\n    const othersUpdates = updates.others;\n    batchedUpdatesWrapper(() => {\n      if (othersUpdates !== void 0 && othersUpdates.length > 0) {\n        const others = context.others.current;\n        for (const event of othersUpdates) {\n          eventHub.others.notify({ ...event, others });\n        }\n      }\n      if (_nullishCoalesce(updates.presence, () => ( false))) {\n        notifySelfChanged(doNotBatchUpdates);\n        eventHub.myPresence.notify(context.myPresence.current);\n      }\n      if (storageUpdates !== void 0 && storageUpdates.size > 0) {\n        const updates2 = Array.from(storageUpdates.values());\n        eventHub.storageBatch.notify(updates2);\n      }\n      notifyStorageStatus();\n    });\n  }\n  function getConnectionId() {\n    const info = context.dynamicSessionInfo.current;\n    if (info) {\n      return info.actor;\n    }\n    throw new Error(\n      \"Internal. Tried to get connection id but connection was never open\"\n    );\n  }\n  function applyOps(rawOps, isLocal) {\n    const output = {\n      reverse: [],\n      storageUpdates: /* @__PURE__ */ new Map(),\n      presence: false\n    };\n    const createdNodeIds = /* @__PURE__ */ new Set();\n    const ops = rawOps.map((op) => {\n      if (op.type !== \"presence\" && !op.opId) {\n        return { ...op, opId: pool.generateOpId() };\n      } else {\n        return op;\n      }\n    });\n    for (const op of ops) {\n      if (op.type === \"presence\") {\n        const reverse = {\n          type: \"presence\",\n          data: {}\n        };\n        for (const key in op.data) {\n          reverse.data[key] = context.myPresence.current[key];\n        }\n        context.myPresence.patch(op.data);\n        if (context.buffer.presenceUpdates === null) {\n          context.buffer.presenceUpdates = { type: \"partial\", data: op.data };\n        } else {\n          for (const key in op.data) {\n            context.buffer.presenceUpdates.data[key] = op.data[key];\n          }\n        }\n        output.reverse.unshift(reverse);\n        output.presence = true;\n      } else {\n        let source;\n        if (isLocal) {\n          source = 0 /* UNDOREDO_RECONNECT */;\n        } else {\n          const opId = nn(op.opId);\n          if (process.env.NODE_ENV !== \"production\") {\n            nn(context.opStackTraces).delete(opId);\n          }\n          const deleted = context.unacknowledgedOps.delete(opId);\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\n        }\n        const applyOpResult = applyOp(op, source);\n        if (applyOpResult.modified) {\n          const nodeId = applyOpResult.modified.node._id;\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\n            output.storageUpdates.set(\n              nn(applyOpResult.modified.node._id),\n              mergeStorageUpdates(\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\n                applyOpResult.modified\n              )\n            );\n            output.reverse.unshift(...applyOpResult.reverse);\n          }\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\n            createdNodeIds.add(nn(op.id));\n          }\n        }\n      }\n    }\n    return {\n      ops,\n      reverse: output.reverse,\n      updates: {\n        storageUpdates: output.storageUpdates,\n        presence: output.presence\n      }\n    };\n  }\n  function applyOp(op, source) {\n    if (isAckOp(op)) {\n      return { modified: false };\n    }\n    switch (op.type) {\n      case 6 /* DELETE_OBJECT_KEY */:\n      case 3 /* UPDATE_OBJECT */:\n      case 5 /* DELETE_CRDT */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\n      }\n      case 1 /* SET_PARENT_KEY */: {\n        const node = context.nodes.get(op.id);\n        if (node === void 0) {\n          return { modified: false };\n        }\n        if (node.parent.type === \"HasParent\" && isLiveList(node.parent.node)) {\n          return node.parent.node._setChildKey(\n            asPos(op.parentKey),\n            node,\n            source\n          );\n        }\n        return { modified: false };\n      }\n      case 4 /* CREATE_OBJECT */:\n      case 2 /* CREATE_LIST */:\n      case 7 /* CREATE_MAP */:\n      case 8 /* CREATE_REGISTER */: {\n        if (op.parentId === void 0) {\n          return { modified: false };\n        }\n        const parentNode = context.nodes.get(op.parentId);\n        if (parentNode === void 0) {\n          return { modified: false };\n        }\n        return parentNode._attachChild(op, source);\n      }\n    }\n  }\n  function updatePresence(patch, options2) {\n    const oldValues = {};\n    if (context.buffer.presenceUpdates === null) {\n      context.buffer.presenceUpdates = {\n        type: \"partial\",\n        data: {}\n      };\n    }\n    for (const key in patch) {\n      const overrideValue = patch[key];\n      if (overrideValue === void 0) {\n        continue;\n      }\n      context.buffer.presenceUpdates.data[key] = overrideValue;\n      oldValues[key] = context.myPresence.current[key];\n    }\n    context.myPresence.patch(patch);\n    if (context.activeBatch) {\n      if (_optionalChain([options2, 'optionalAccess', _135 => _135.addToHistory])) {\n        context.activeBatch.reverseOps.unshift({\n          type: \"presence\",\n          data: oldValues\n        });\n      }\n      context.activeBatch.updates.presence = true;\n    } else {\n      flushNowOrSoon();\n      batchUpdates(() => {\n        if (_optionalChain([options2, 'optionalAccess', _136 => _136.addToHistory])) {\n          addToUndoStack(\n            [{ type: \"presence\", data: oldValues }],\n            doNotBatchUpdates\n          );\n        }\n        notify({ presence: true }, doNotBatchUpdates);\n      });\n    }\n  }\n  function onUpdatePresenceMessage(message) {\n    if (message.targetActor !== void 0) {\n      const oldUser = context.others.getUser(message.actor);\n      context.others.setOther(message.actor, message.data);\n      const newUser = context.others.getUser(message.actor);\n      if (oldUser === void 0 && newUser !== void 0) {\n        return { type: \"enter\", user: newUser };\n      }\n    } else {\n      context.others.patchOther(message.actor, message.data), message;\n    }\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      return {\n        type: \"update\",\n        updates: message.data,\n        user\n      };\n    } else {\n      return void 0;\n    }\n  }\n  function onUserLeftMessage(message) {\n    const user = context.others.getUser(message.actor);\n    if (user) {\n      context.others.removeConnection(message.actor);\n      return { type: \"leave\", user };\n    }\n    return null;\n  }\n  function onRoomStateMessage(message, batchedUpdatesWrapper) {\n    context.dynamicSessionInfo.set({\n      actor: message.actor,\n      nonce: message.nonce,\n      scopes: message.scopes\n    });\n    context.idFactory = makeIdFactory(message.actor);\n    notifySelfChanged(batchedUpdatesWrapper);\n    for (const connectionId of context.others.connectionIds()) {\n      const user = message.users[connectionId];\n      if (user === void 0) {\n        context.others.removeConnection(connectionId);\n      }\n    }\n    for (const key in message.users) {\n      const user = message.users[key];\n      const connectionId = Number(key);\n      context.others.setConnection(\n        connectionId,\n        user.id,\n        user.info,\n        user.scopes\n      );\n    }\n    return { type: \"reset\" };\n  }\n  function canUndo() {\n    return context.undoStack.length > 0;\n  }\n  function canRedo() {\n    return context.redoStack.length > 0;\n  }\n  function onHistoryChange(batchedUpdatesWrapper) {\n    batchedUpdatesWrapper(() => {\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\n    });\n  }\n  function onUserJoinedMessage(message) {\n    context.others.setConnection(\n      message.actor,\n      message.id,\n      message.info,\n      message.scopes\n    );\n    context.buffer.messages.push({\n      type: 100 /* UPDATE_PRESENCE */,\n      data: context.myPresence.current,\n      targetActor: message.actor\n    });\n    flushNowOrSoon();\n    const user = context.others.getUser(message.actor);\n    return user ? { type: \"enter\", user } : void 0;\n  }\n  function parseServerMessage(data) {\n    if (!isJsonObject(data)) {\n      return null;\n    }\n    return data;\n  }\n  function parseServerMessages(text) {\n    const data = tryParseJson(text);\n    if (data === void 0) {\n      return null;\n    } else if (isJsonArray(data)) {\n      return compact(data.map((item) => parseServerMessage(item)));\n    } else {\n      return compact([parseServerMessage(data)]);\n    }\n  }\n  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\n    if (offlineOps.size === 0) {\n      return;\n    }\n    const messages = [];\n    const ops = Array.from(offlineOps.values());\n    const result = applyOps(ops, true);\n    messages.push({\n      type: 201 /* UPDATE_STORAGE */,\n      ops: result.ops\n    });\n    notify(result.updates, batchedUpdatesWrapper);\n    sendMessages(messages);\n  }\n  function handleServerMessage(event) {\n    if (typeof event.data !== \"string\") {\n      return;\n    }\n    const messages = parseServerMessages(event.data);\n    if (messages === null || messages.length === 0) {\n      return;\n    }\n    const updates = {\n      storageUpdates: /* @__PURE__ */ new Map(),\n      others: []\n    };\n    batchUpdates(() => {\n      for (const message of messages) {\n        switch (message.type) {\n          case 101 /* USER_JOINED */: {\n            const userJoinedUpdate = onUserJoinedMessage(message);\n            if (userJoinedUpdate) {\n              updates.others.push(userJoinedUpdate);\n            }\n            break;\n          }\n          case 100 /* UPDATE_PRESENCE */: {\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\n            if (othersPresenceUpdate) {\n              updates.others.push(othersPresenceUpdate);\n            }\n            break;\n          }\n          case 103 /* BROADCASTED_EVENT */: {\n            const others = context.others.current;\n            eventHub.customEvent.notify({\n              connectionId: message.actor,\n              user: message.actor < 0 ? null : _nullishCoalesce(others.find((u) => u.connectionId === message.actor), () => ( null)),\n              event: message.event\n            });\n            break;\n          }\n          case 102 /* USER_LEFT */: {\n            const event2 = onUserLeftMessage(message);\n            if (event2) {\n              updates.others.push(event2);\n            }\n            break;\n          }\n          case 300 /* UPDATE_YDOC */: {\n            eventHub.ydoc.notify(message);\n            break;\n          }\n          case 104 /* ROOM_STATE */: {\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\n            break;\n          }\n          case 200 /* INITIAL_STORAGE_STATE */: {\n            processInitialStorage(message);\n            break;\n          }\n          case 201 /* UPDATE_STORAGE */: {\n            const applyResult = applyOps(message.ops, false);\n            for (const [key, value] of applyResult.updates.storageUpdates) {\n              updates.storageUpdates.set(\n                key,\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\n              );\n            }\n            break;\n          }\n          case 299 /* REJECT_STORAGE_OP */: {\n            errorWithTitle(\n              \"Storage mutation rejection error\",\n              message.reason\n            );\n            if (process.env.NODE_ENV !== \"production\") {\n              const traces = /* @__PURE__ */ new Set();\n              for (const opId of message.opIds) {\n                const trace = _optionalChain([context, 'access', _137 => _137.opStackTraces, 'optionalAccess', _138 => _138.get, 'call', _139 => _139(opId)]);\n                if (trace) {\n                  traces.add(trace);\n                }\n              }\n              if (traces.size > 0) {\n                warnWithTitle(\n                  \"The following function calls caused the rejected storage mutations:\",\n                  `\n\n${Array.from(traces).join(\"\\n\\n\")}`\n                );\n              }\n              throw new Error(\n                `Storage mutations rejected by server: ${message.reason}`\n              );\n            }\n            break;\n          }\n          case 400 /* THREAD_CREATED */:\n          case 407 /* THREAD_DELETED */:\n          case 401 /* THREAD_METADATA_UPDATED */:\n          case 408 /* THREAD_UPDATED */:\n          case 405 /* COMMENT_REACTION_ADDED */:\n          case 406 /* COMMENT_REACTION_REMOVED */:\n          case 402 /* COMMENT_CREATED */:\n          case 403 /* COMMENT_EDITED */:\n          case 404 /* COMMENT_DELETED */: {\n            eventHub.comments.notify(message);\n            break;\n          }\n        }\n      }\n      notify(updates, doNotBatchUpdates);\n    });\n  }\n  function flushNowOrSoon() {\n    const storageOps = context.buffer.storageOperations;\n    if (storageOps.length > 0) {\n      for (const op of storageOps) {\n        context.unacknowledgedOps.set(nn(op.opId), op);\n      }\n      notifyStorageStatus();\n    }\n    if (managedSocket.getStatus() !== \"connected\") {\n      context.buffer.storageOperations = [];\n      return;\n    }\n    const now = Date.now();\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\n    if (elapsedMillis >= config.throttleDelay) {\n      const messagesToFlush = serializeBuffer();\n      if (messagesToFlush.length === 0) {\n        return;\n      }\n      sendMessages(messagesToFlush);\n      context.buffer = {\n        flushTimerID: void 0,\n        lastFlushedAt: now,\n        messages: [],\n        storageOperations: [],\n        presenceUpdates: null\n      };\n    } else {\n      clearTimeout(context.buffer.flushTimerID);\n      context.buffer.flushTimerID = setTimeout(\n        flushNowOrSoon,\n        config.throttleDelay - elapsedMillis\n      );\n    }\n  }\n  function serializeBuffer() {\n    const messages = [];\n    if (context.buffer.presenceUpdates) {\n      messages.push(\n        context.buffer.presenceUpdates.type === \"full\" ? {\n          type: 100 /* UPDATE_PRESENCE */,\n          // Populating the `targetActor` field turns this message into\n          // a Full Presence™ update message (not a patch), which will get\n          // interpreted by other clients as such.\n          targetActor: -1,\n          data: context.buffer.presenceUpdates.data\n        } : {\n          type: 100 /* UPDATE_PRESENCE */,\n          data: context.buffer.presenceUpdates.data\n        }\n      );\n    }\n    for (const event of context.buffer.messages) {\n      messages.push(event);\n    }\n    if (context.buffer.storageOperations.length > 0) {\n      messages.push({\n        type: 201 /* UPDATE_STORAGE */,\n        ops: context.buffer.storageOperations\n      });\n    }\n    return messages;\n  }\n  function updateYDoc(update, guid) {\n    const clientMsg = {\n      type: 301 /* UPDATE_YDOC */,\n      update,\n      guid\n    };\n    context.buffer.messages.push(clientMsg);\n    eventHub.ydoc.notify(clientMsg);\n    flushNowOrSoon();\n  }\n  function broadcastEvent(event, options2 = {\n    shouldQueueEventIfNotReady: false\n  }) {\n    if (managedSocket.getStatus() !== \"connected\" && !options2.shouldQueueEventIfNotReady) {\n      return;\n    }\n    context.buffer.messages.push({\n      type: 103 /* BROADCAST_EVENT */,\n      event\n    });\n    flushNowOrSoon();\n  }\n  function dispatchOps(ops) {\n    const { storageOperations } = context.buffer;\n    for (const op of ops) {\n      storageOperations.push(op);\n    }\n    flushNowOrSoon();\n  }\n  let _getStorage$ = null;\n  let _resolveStoragePromise = null;\n  function processInitialStorage(message) {\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\n    _optionalChain([_resolveStoragePromise, 'optionalCall', _140 => _140()]);\n    notifyStorageStatus();\n    eventHub.storageDidLoad.notify();\n  }\n  async function streamStorage() {\n    if (!managedSocket.authValue) return;\n    const result = await httpClient1.rawGet(\n      url`/v2/c/rooms/${config.roomId}/storage`\n    );\n    const items = await result.json();\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\n  }\n  function refreshStorage(options2) {\n    const messages = context.buffer.messages;\n    if (config.unstable_streamData) {\n      void streamStorage();\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\n    }\n    if (options2.flush) {\n      flushNowOrSoon();\n    }\n  }\n  function startLoadingStorage() {\n    if (_getStorage$ === null) {\n      refreshStorage({ flush: true });\n      _getStorage$ = new Promise((resolve) => {\n        _resolveStoragePromise = resolve;\n      });\n      notifyStorageStatus();\n    }\n    return _getStorage$;\n  }\n  function getStorageSnapshot() {\n    const root = context.root;\n    if (root !== void 0) {\n      return root;\n    } else {\n      void startLoadingStorage();\n      return null;\n    }\n  }\n  async function getStorage() {\n    if (context.root !== void 0) {\n      return Promise.resolve({\n        root: context.root\n      });\n    }\n    await startLoadingStorage();\n    return {\n      root: nn(context.root)\n    };\n  }\n  function fetchYDoc(vector, guid) {\n    if (!context.buffer.messages.find((m) => {\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid;\n    })) {\n      context.buffer.messages.push({\n        type: 300 /* FETCH_YDOC */,\n        vector,\n        guid\n      });\n    }\n    flushNowOrSoon();\n  }\n  function undo() {\n    if (context.activeBatch) {\n      throw new Error(\"undo is not allowed during a batch\");\n    }\n    const historyOps = context.undoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.redoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function redo() {\n    if (context.activeBatch) {\n      throw new Error(\"redo is not allowed during a batch\");\n    }\n    const historyOps = context.redoStack.pop();\n    if (historyOps === void 0) {\n      return;\n    }\n    context.pausedHistory = null;\n    const result = applyOps(historyOps, true);\n    batchUpdates(() => {\n      notify(result.updates, doNotBatchUpdates);\n      context.undoStack.push(result.reverse);\n      onHistoryChange(doNotBatchUpdates);\n    });\n    for (const op of result.ops) {\n      if (op.type !== \"presence\") {\n        context.buffer.storageOperations.push(op);\n      }\n    }\n    flushNowOrSoon();\n  }\n  function clear() {\n    context.undoStack.length = 0;\n    context.redoStack.length = 0;\n  }\n  function batch(callback) {\n    if (context.activeBatch) {\n      return callback();\n    }\n    let returnValue = void 0;\n    batchUpdates(() => {\n      context.activeBatch = {\n        ops: [],\n        updates: {\n          storageUpdates: /* @__PURE__ */ new Map(),\n          presence: false,\n          others: []\n        },\n        reverseOps: []\n      };\n      try {\n        returnValue = callback();\n      } finally {\n        const currentBatch = context.activeBatch;\n        context.activeBatch = null;\n        if (currentBatch.reverseOps.length > 0) {\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\n        }\n        if (currentBatch.ops.length > 0) {\n          context.redoStack.length = 0;\n        }\n        if (currentBatch.ops.length > 0) {\n          dispatchOps(currentBatch.ops);\n        }\n        notify(currentBatch.updates, doNotBatchUpdates);\n        flushNowOrSoon();\n      }\n    });\n    return returnValue;\n  }\n  function pauseHistory() {\n    if (context.pausedHistory === null) {\n      context.pausedHistory = [];\n    }\n  }\n  function resumeHistory() {\n    const historyOps = context.pausedHistory;\n    context.pausedHistory = null;\n    if (historyOps !== null && historyOps.length > 0) {\n      _addToRealUndoStack(historyOps, batchUpdates);\n    }\n  }\n  function getStorageStatus() {\n    if (context.root === void 0) {\n      return _getStorage$ === null ? \"not-loaded\" : \"loading\";\n    } else {\n      return context.unacknowledgedOps.size === 0 ? \"synchronized\" : \"synchronizing\";\n    }\n  }\n  let _lastStorageStatus = getStorageStatus();\n  function notifyStorageStatus() {\n    const storageStatus = getStorageStatus();\n    if (_lastStorageStatus !== storageStatus) {\n      _lastStorageStatus = storageStatus;\n      eventHub.storageStatus.notify(storageStatus);\n    }\n  }\n  function isPresenceReady() {\n    return self.current !== null;\n  }\n  async function waitUntilPresenceReady() {\n    while (!isPresenceReady()) {\n      const { promise, resolve } = Promise_withResolvers();\n      const unsub1 = events.self.subscribeOnce(resolve);\n      const unsub2 = events.status.subscribeOnce(resolve);\n      await promise;\n      unsub1();\n      unsub2();\n    }\n  }\n  function isStorageReady() {\n    return getStorageSnapshot() !== null;\n  }\n  async function waitUntilStorageReady() {\n    while (!isStorageReady()) {\n      await getStorage();\n    }\n  }\n  const others_forDevTools = new DerivedRef(\n    context.others,\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\n  );\n  const events = {\n    status: eventHub.status.observable,\n    lostConnection: eventHub.lostConnection.observable,\n    customEvent: eventHub.customEvent.observable,\n    others: eventHub.others.observable,\n    self: eventHub.self.observable,\n    myPresence: eventHub.myPresence.observable,\n    error: eventHub.error.observable,\n    /** @deprecated */\n    storage: eventHub.storageBatch.observable,\n    storageBatch: eventHub.storageBatch.observable,\n    history: eventHub.history.observable,\n    storageDidLoad: eventHub.storageDidLoad.observable,\n    storageStatus: eventHub.storageStatus.observable,\n    ydoc: eventHub.ydoc.observable,\n    comments: eventHub.comments.observable\n  };\n  async function getThreadsSince(options2) {\n    const result = await httpClient2.get(\n      url`/v2/c/rooms/${config.roomId}/threads/delta`,\n      { since: _optionalChain([options2, 'optionalAccess', _141 => _141.since, 'optionalAccess', _142 => _142.toISOString, 'call', _143 => _143()]) },\n      { signal: options2.signal }\n    );\n    return {\n      threads: {\n        updated: result.data.map(convertToThreadData),\n        deleted: result.deletedThreads.map(convertToThreadDeleteInfo)\n      },\n      inboxNotifications: {\n        updated: result.inboxNotifications.map(convertToInboxNotificationData),\n        deleted: result.deletedInboxNotifications.map(\n          convertToInboxNotificationDeleteInfo\n        )\n      },\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function getThreads(options2) {\n    let query;\n    if (_optionalChain([options2, 'optionalAccess', _144 => _144.query])) {\n      query = objectToQuery(options2.query);\n    }\n    const PAGE_SIZE = 50;\n    const result = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/threads`, {\n      cursor: _optionalChain([options2, 'optionalAccess', _145 => _145.cursor]),\n      query,\n      limit: PAGE_SIZE\n    });\n    return {\n      threads: result.data.map(convertToThreadData),\n      inboxNotifications: result.inboxNotifications.map(\n        convertToInboxNotificationData\n      ),\n      nextCursor: result.meta.nextCursor,\n      requestedAt: new Date(result.meta.requestedAt)\n    };\n  }\n  async function getThread(threadId) {\n    const response = await httpClient2.rawGet(\n      url`/v2/c/rooms/${config.roomId}/thread-with-notification/${threadId}`\n    );\n    if (response.ok) {\n      const json = await response.json();\n      return {\n        thread: convertToThreadData(json.thread),\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\n      };\n    } else if (response.status === 404) {\n      return {\n        thread: void 0,\n        inboxNotification: void 0\n      };\n    } else {\n      throw new Error(`There was an error while getting thread ${threadId}.`);\n    }\n  }\n  async function createThread({\n    metadata,\n    body,\n    commentId = createCommentId(),\n    threadId = createThreadId(),\n    attachmentIds\n  }) {\n    const thread = await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads`,\n      {\n        id: threadId,\n        comment: {\n          id: commentId,\n          body,\n          attachmentIds\n        },\n        metadata\n      }\n    );\n    return convertToThreadData(thread);\n  }\n  async function deleteThread(threadId) {\n    await httpClient2.delete(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}`\n    );\n  }\n  async function editThreadMetadata({\n    metadata,\n    threadId\n  }) {\n    return await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/metadata`,\n      metadata\n    );\n  }\n  async function markThreadAsResolved(threadId) {\n    await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-resolved`\n    );\n  }\n  async function markThreadAsUnresolved(threadId) {\n    await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-unresolved`\n    );\n  }\n  async function createComment({\n    threadId,\n    commentId = createCommentId(),\n    body,\n    attachmentIds\n  }) {\n    const comment = await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments`,\n      {\n        id: commentId,\n        body,\n        attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function editComment({\n    threadId,\n    commentId,\n    body,\n    attachmentIds\n  }) {\n    const comment = await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`,\n      {\n        body,\n        attachmentIds\n      }\n    );\n    return convertToCommentData(comment);\n  }\n  async function deleteComment({\n    threadId,\n    commentId\n  }) {\n    await httpClient2.delete(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`\n    );\n  }\n  async function addReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    const reaction = await httpClient2.post(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions`,\n      { emoji }\n    );\n    return convertToCommentUserReaction(reaction);\n  }\n  async function removeReaction({\n    threadId,\n    commentId,\n    emoji\n  }) {\n    await httpClient2.delete(\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions/${emoji}`\n    );\n  }\n  function prepareAttachment(file) {\n    return {\n      type: \"localAttachment\",\n      status: \"idle\",\n      id: createCommentAttachmentId(),\n      name: file.name,\n      size: file.size,\n      mimeType: file.type,\n      file\n    };\n  }\n  async function uploadAttachment(attachment, options2 = {}) {\n    const abortSignal = options2.signal;\n    const abortError = abortSignal ? new DOMException(\n      `Upload of attachment ${attachment.id} was aborted.`,\n      \"AbortError\"\n    ) : void 0;\n    if (_optionalChain([abortSignal, 'optionalAccess', _146 => _146.aborted])) {\n      throw abortError;\n    }\n    const handleRetryError = (err) => {\n      if (_optionalChain([abortSignal, 'optionalAccess', _147 => _147.aborted])) {\n        throw abortError;\n      }\n      if (err instanceof HttpError && err.status === 413) {\n        throw err;\n      }\n      return false;\n    };\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\n      return autoRetry(\n        () => httpClient2.putBlob(\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\n          attachment.file,\n          { fileSize: attachment.size },\n          { signal: abortSignal }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n    } else {\n      let uploadId;\n      const uploadedParts = [];\n      const createMultiPartUpload = await autoRetry(\n        () => httpClient2.post(\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\n          void 0,\n          { signal: abortSignal },\n          { fileSize: attachment.size }\n        ),\n        RETRY_ATTEMPTS,\n        RETRY_DELAYS,\n        handleRetryError\n      );\n      try {\n        uploadId = createMultiPartUpload.uploadId;\n        const parts = splitFileIntoParts(attachment.file);\n        if (_optionalChain([abortSignal, 'optionalAccess', _148 => _148.aborted])) {\n          throw abortError;\n        }\n        const batches = chunk(parts, ATTACHMENT_PART_BATCH_SIZE);\n        for (const parts2 of batches) {\n          const uploadedPartsPromises = [];\n          for (const { part, partNumber } of parts2) {\n            uploadedPartsPromises.push(\n              autoRetry(\n                () => httpClient2.putBlob(\n                  url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\n                  part,\n                  void 0,\n                  { signal: abortSignal }\n                ),\n                RETRY_ATTEMPTS,\n                RETRY_DELAYS,\n                handleRetryError\n              )\n            );\n          }\n          uploadedParts.push(...await Promise.all(uploadedPartsPromises));\n        }\n        if (_optionalChain([abortSignal, 'optionalAccess', _149 => _149.aborted])) {\n          throw abortError;\n        }\n        const sortedUploadedParts = uploadedParts.sort(\n          (a, b) => a.partNumber - b.partNumber\n        );\n        return httpClient2.post(\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\n          { parts: sortedUploadedParts },\n          { signal: abortSignal }\n        );\n      } catch (error3) {\n        if (uploadId && _optionalChain([error3, 'optionalAccess', _150 => _150.name]) && (error3.name === \"AbortError\" || error3.name === \"TimeoutError\")) {\n          try {\n            await httpClient2.rawDelete(\n              url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}`\n            );\n          } catch (error4) {\n          }\n        }\n        throw error3;\n      }\n    }\n  }\n  async function getAttachmentUrls(attachmentIds) {\n    const { urls } = await httpClient2.post(url`/v2/c/rooms/${config.roomId}/attachments/presigned-urls`, {\n      attachmentIds\n    });\n    return urls;\n  }\n  const batchedGetAttachmentUrls = new Batch(\n    async (batchedAttachmentIds) => {\n      const attachmentIds = batchedAttachmentIds.flat();\n      const attachmentUrls = await getAttachmentUrls(attachmentIds);\n      return attachmentUrls.map(\n        (url2) => _nullishCoalesce(url2, () => ( new Error(\"There was an error while getting this attachment's URL\")))\n      );\n    },\n    { delay: GET_ATTACHMENT_URLS_BATCH_DELAY }\n  );\n  const attachmentUrlsStore = createBatchStore(batchedGetAttachmentUrls);\n  function getAttachmentUrl(attachmentId) {\n    return batchedGetAttachmentUrls.get(attachmentId);\n  }\n  async function fetchNotificationsJson(endpoint, options2) {\n    return await httpClient2.get(endpoint, void 0, options2);\n  }\n  function getNotificationSettings(options2) {\n    return fetchNotificationsJson(\n      url`/v2/c/rooms/${config.roomId}/notification-settings`,\n      { signal: _optionalChain([options2, 'optionalAccess', _151 => _151.signal]) }\n    );\n  }\n  function updateNotificationSettings(settings) {\n    return fetchNotificationsJson(\n      url`/v2/c/rooms/${config.roomId}/notification-settings`,\n      {\n        method: \"POST\",\n        body: JSON.stringify(settings)\n      }\n    );\n  }\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\n    await fetchNotificationsJson(\n      url`/v2/c/rooms/${config.roomId}/inbox-notifications/read`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({ inboxNotificationIds })\n      }\n    );\n  }\n  const batchedMarkInboxNotificationsAsRead = new Batch(\n    async (batchedInboxNotificationIds) => {\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\n      await markInboxNotificationsAsRead(inboxNotificationIds);\n      return inboxNotificationIds;\n    },\n    { delay: 50 }\n  );\n  async function markInboxNotificationAsRead(inboxNotificationId) {\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\n  }\n  return Object.defineProperty(\n    {\n      [kInternal]: {\n        get presenceBuffer() {\n          return deepClone(_nullishCoalesce(_optionalChain([context, 'access', _152 => _152.buffer, 'access', _153 => _153.presenceUpdates, 'optionalAccess', _154 => _154.data]), () => ( null)));\n        },\n        // prettier-ignore\n        get undoStack() {\n          return deepClone(context.undoStack);\n        },\n        // prettier-ignore\n        get nodeCount() {\n          return context.nodes.size;\n        },\n        // prettier-ignore\n        getProvider() {\n          return context.provider;\n        },\n        setProvider(provider) {\n          context.provider = provider;\n          context.onProviderUpdate.notify();\n        },\n        onProviderUpdate: context.onProviderUpdate.observable,\n        // send metadata when using a text editor\n        reportTextEditor,\n        // create a text mention when using a text editor\n        createTextMention,\n        // delete a text mention when using a text editor\n        deleteTextMention,\n        // list versions of the document\n        listTextVersions,\n        // List versions of the document since the specified date\n        listTextVersionsSince,\n        // get a specific version\n        getTextVersion,\n        // create a version\n        createTextVersion,\n        // Support for the Liveblocks browser extension\n        getSelf_forDevTools: () => selfAsTreeNode.current,\n        getOthers_forDevTools: () => others_forDevTools.current,\n        // prettier-ignore\n        simulate: {\n          // These exist only for our E2E testing app\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \"EXPLICIT_SOCKET_CLOSE\", event }),\n          rawSend: (data) => managedSocket.send(data)\n        },\n        attachmentUrlsStore\n      },\n      id: config.roomId,\n      subscribe: makeClassicSubscribeFn(events),\n      connect: () => managedSocket.connect(),\n      reconnect: () => managedSocket.reconnect(),\n      disconnect: () => managedSocket.disconnect(),\n      destroy: () => {\n        uninstallBgTabSpy();\n        managedSocket.destroy();\n      },\n      // Presence\n      updatePresence,\n      updateYDoc,\n      broadcastEvent,\n      // Storage\n      batch,\n      history: {\n        undo,\n        redo,\n        canUndo,\n        canRedo,\n        clear,\n        pause: pauseHistory,\n        resume: resumeHistory\n      },\n      fetchYDoc,\n      getStorage,\n      getStorageSnapshot,\n      getStorageStatus,\n      isPresenceReady,\n      isStorageReady,\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\n      events,\n      // Core\n      getStatus: () => managedSocket.getStatus(),\n      getSelf: () => self.current,\n      // Presence\n      getPresence: () => context.myPresence.current,\n      getOthers: () => context.others.current,\n      // Comments\n      getThreads,\n      getThreadsSince,\n      getThread,\n      createThread,\n      deleteThread,\n      editThreadMetadata,\n      markThreadAsResolved,\n      markThreadAsUnresolved,\n      createComment,\n      editComment,\n      deleteComment,\n      addReaction,\n      removeReaction,\n      prepareAttachment,\n      uploadAttachment,\n      getAttachmentUrl,\n      // Notifications\n      getNotificationSettings,\n      updateNotificationSettings,\n      markInboxNotificationAsRead\n    },\n    // Explictly make the internal field non-enumerable, to avoid aggressive\n    // freezing when used with Immer\n    kInternal,\n    { enumerable: false }\n  );\n}\nfunction makeClassicSubscribeFn(events) {\n  function subscribeToLiveStructureDeeply(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      const relatedUpdates = updates.filter(\n        (update) => isSameNodeOrChildOf(update.node, node)\n      );\n      if (relatedUpdates.length > 0) {\n        callback(relatedUpdates);\n      }\n    });\n  }\n  function subscribeToLiveStructureShallowly(node, callback) {\n    return events.storageBatch.subscribe((updates) => {\n      for (const update of updates) {\n        if (update.node._id === node._id) {\n          callback(update.node);\n        }\n      }\n    });\n  }\n  function subscribe(first, second, options) {\n    if (typeof first === \"string\" && isRoomEventName(first)) {\n      if (typeof second !== \"function\") {\n        throw new Error(\"Second argument must be a callback function\");\n      }\n      const callback = second;\n      switch (first) {\n        case \"event\":\n          return events.customEvent.subscribe(\n            callback\n          );\n        case \"my-presence\":\n          return events.myPresence.subscribe(callback);\n        case \"others\": {\n          const cb = callback;\n          return events.others.subscribe((event) => {\n            const { others, ...internalEvent } = event;\n            return cb(others, internalEvent);\n          });\n        }\n        case \"error\":\n          return events.error.subscribe(callback);\n        case \"status\":\n          return events.status.subscribe(callback);\n        case \"lost-connection\":\n          return events.lostConnection.subscribe(\n            callback\n          );\n        case \"history\":\n          return events.history.subscribe(callback);\n        case \"storage-status\":\n          return events.storageStatus.subscribe(\n            callback\n          );\n        case \"comments\":\n          return events.comments.subscribe(\n            callback\n          );\n        default:\n          return assertNever(\n            first,\n            `\"${String(first)}\" is not a valid event name`\n          );\n      }\n    }\n    if (second === void 0 || typeof first === \"function\") {\n      if (typeof first === \"function\") {\n        const storageCallback = first;\n        return events.storageBatch.subscribe(storageCallback);\n      } else {\n        throw new Error(\"Please specify a listener callback\");\n      }\n    }\n    if (isLiveNode(first)) {\n      const node = first;\n      if (_optionalChain([options, 'optionalAccess', _155 => _155.isDeep])) {\n        const storageCallback = second;\n        return subscribeToLiveStructureDeeply(node, storageCallback);\n      } else {\n        const nodeCallback = second;\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\n      }\n    }\n    throw new Error(\n      `${String(first)} is not a value that can be subscribed to.`\n    );\n  }\n  return subscribe;\n}\nfunction isRoomEventName(value) {\n  return value === \"my-presence\" || value === \"others\" || value === \"event\" || value === \"error\" || value === \"history\" || value === \"status\" || value === \"storage-status\" || value === \"lost-connection\" || value === \"connection\" || value === \"comments\";\n}\nfunction makeAuthDelegateForRoom(roomId, authManager) {\n  return async () => {\n    return authManager.getAuthValue({ requestedScope: \"room:read\", roomId });\n  };\n}\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\n  return (authValue) => {\n    const ws = _nullishCoalesce(WebSocketPolyfill, () => ( (typeof WebSocket === \"undefined\" ? void 0 : WebSocket)));\n    if (ws === void 0) {\n      throw new StopRetrying(\n        \"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\"\n      );\n    }\n    const url2 = new URL(baseUrl);\n    url2.protocol = url2.protocol === \"http:\" ? \"ws\" : \"wss\";\n    url2.pathname = \"/v7\";\n    url2.searchParams.set(\"roomId\", roomId);\n    if (authValue.type === \"secret\") {\n      url2.searchParams.set(\"tok\", authValue.token.raw);\n    } else if (authValue.type === \"public\") {\n      url2.searchParams.set(\"pubkey\", authValue.publicApiKey);\n    } else {\n      return assertNever(authValue, \"Unhandled case\");\n    }\n    url2.searchParams.set(\"version\", PKG_VERSION || \"dev\");\n    return new ws(url2.toString());\n  };\n}\n\n// src/client.ts\nvar MIN_THROTTLE = 16;\nvar MAX_THROTTLE = 1e3;\nvar DEFAULT_THROTTLE = 100;\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\nvar RESOLVE_USERS_BATCH_DELAY = 50;\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\nfunction getBaseUrl(baseUrl) {\n  if (typeof baseUrl === \"string\" && baseUrl.startsWith(\"http\")) {\n    return baseUrl;\n  } else {\n    return DEFAULT_BASE_URL;\n  }\n}\nfunction createClient(options) {\n  const clientOptions = options;\n  const throttleDelay = getThrottle(_nullishCoalesce(clientOptions.throttle, () => ( DEFAULT_THROTTLE)));\n  const lostConnectionTimeout = getLostConnectionTimeout(\n    _nullishCoalesce(clientOptions.lostConnectionTimeout, () => ( DEFAULT_LOST_CONNECTION_TIMEOUT))\n  );\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\n    clientOptions.backgroundKeepAliveTimeout\n  );\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\n  const authManager = createAuthManager(options);\n  const roomsById = /* @__PURE__ */ new Map();\n  function teardownRoom(room) {\n    unlinkDevTools(room.id);\n    roomsById.delete(room.id);\n    room.destroy();\n  }\n  function leaseRoom(details) {\n    const leave = () => {\n      const self = leave;\n      if (!details.unsubs.delete(self)) {\n        warn(\n          \"This leave function was already called. Calling it more than once has no effect.\"\n        );\n      } else {\n        if (details.unsubs.size === 0) {\n          teardownRoom(details.room);\n        }\n      }\n    };\n    details.unsubs.add(leave);\n    return {\n      room: details.room,\n      leave\n    };\n  }\n  function enterRoom(roomId, ...args) {\n    const existing = roomsById.get(roomId);\n    if (existing !== void 0) {\n      return leaseRoom(existing);\n    }\n    const options2 = _nullishCoalesce(args[0], () => ( {}));\n    const initialPresence = _nullishCoalesce((typeof options2.initialPresence === \"function\" ? options2.initialPresence(roomId) : options2.initialPresence), () => ( {}));\n    const initialStorage = _nullishCoalesce((typeof options2.initialStorage === \"function\" ? options2.initialStorage(roomId) : options2.initialStorage), () => ( {}));\n    const newRoom = createRoom(\n      { initialPresence, initialStorage },\n      {\n        roomId,\n        throttleDelay,\n        lostConnectionTimeout,\n        backgroundKeepAliveTimeout,\n        polyfills: clientOptions.polyfills,\n        delegates: _nullishCoalesce(clientOptions.mockedDelegates, () => ( {\n          createSocket: makeCreateSocketDelegateForRoom(\n            roomId,\n            baseUrl,\n            _optionalChain([clientOptions, 'access', _156 => _156.polyfills, 'optionalAccess', _157 => _157.WebSocket])\n          ),\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\n        })),\n        enableDebugLogging: clientOptions.enableDebugLogging,\n        unstable_batchedUpdates: _optionalChain([options2, 'optionalAccess', _158 => _158.unstable_batchedUpdates]),\n        baseUrl,\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\n        unstable_streamData: !!clientOptions.unstable_streamData\n      }\n    );\n    const newRoomDetails = {\n      room: newRoom,\n      unsubs: /* @__PURE__ */ new Set()\n    };\n    roomsById.set(roomId, newRoomDetails);\n    setupDevTools(() => Array.from(roomsById.keys()));\n    linkDevTools(roomId, newRoom);\n    const shouldConnect = _nullishCoalesce(options2.autoConnect, () => ( true));\n    if (shouldConnect) {\n      if (typeof atob === \"undefined\") {\n        if (_optionalChain([clientOptions, 'access', _159 => _159.polyfills, 'optionalAccess', _160 => _160.atob]) === void 0) {\n          throw new Error(\n            \"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\"\n          );\n        }\n        global.atob = clientOptions.polyfills.atob;\n      }\n      newRoom.connect();\n    }\n    return leaseRoom(newRoomDetails);\n  }\n  function getRoom(roomId) {\n    const room = _optionalChain([roomsById, 'access', _161 => _161.get, 'call', _162 => _162(roomId), 'optionalAccess', _163 => _163.room]);\n    return room ? room : null;\n  }\n  function logout() {\n    authManager.reset();\n    for (const { room } of roomsById.values()) {\n      if (!isIdle(room.getStatus())) {\n        room.reconnect();\n      }\n    }\n  }\n  const currentUserIdStore = createStore(null);\n  const fetchPolyfill = _optionalChain([clientOptions, 'access', _164 => _164.polyfills, 'optionalAccess', _165 => _165.fetch]) || /* istanbul ignore next */\n  _optionalChain([globalThis, 'access', _166 => _166.fetch, 'optionalAccess', _167 => _167.bind, 'call', _168 => _168(globalThis)]);\n  const notificationsAPI = createNotificationsApi({\n    baseUrl,\n    fetchPolyfill,\n    authManager,\n    currentUserIdStore\n  });\n  const resolveUsers = clientOptions.resolveUsers;\n  const warnIfNoResolveUsers = createDevelopmentWarning(\n    () => !resolveUsers,\n    \"Set the resolveUsers option in createClient to specify user info.\"\n  );\n  const batchedResolveUsers = new Batch(\n    async (batchedUserIds) => {\n      const userIds = batchedUserIds.flat();\n      const users = await _optionalChain([resolveUsers, 'optionalCall', _169 => _169({ userIds })]);\n      warnIfNoResolveUsers();\n      return _nullishCoalesce(users, () => ( userIds.map(() => void 0)));\n    },\n    { delay: RESOLVE_USERS_BATCH_DELAY }\n  );\n  const usersStore = createBatchStore(batchedResolveUsers);\n  function invalidateResolvedUsers(userIds) {\n    usersStore.invalidate(userIds);\n  }\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\n    () => !resolveRoomsInfo,\n    \"Set the resolveRoomsInfo option in createClient to specify room info.\"\n  );\n  const batchedResolveRoomsInfo = new Batch(\n    async (batchedRoomIds) => {\n      const roomIds = batchedRoomIds.flat();\n      const roomsInfo = await _optionalChain([resolveRoomsInfo, 'optionalCall', _170 => _170({ roomIds })]);\n      warnIfNoResolveRoomsInfo();\n      return _nullishCoalesce(roomsInfo, () => ( roomIds.map(() => void 0)));\n    },\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\n  );\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\n  function invalidateResolvedRoomsInfo(roomIds) {\n    roomsInfoStore.invalidate(roomIds);\n  }\n  const mentionSuggestionsCache = /* @__PURE__ */ new Map();\n  function invalidateResolvedMentionSuggestions() {\n    mentionSuggestionsCache.clear();\n  }\n  const client = Object.defineProperty(\n    {\n      enterRoom,\n      getRoom,\n      logout,\n      ...notificationsAPI,\n      // Advanced resolvers APIs\n      resolvers: {\n        invalidateUsers: invalidateResolvedUsers,\n        invalidateRoomsInfo: invalidateResolvedRoomsInfo,\n        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions\n      },\n      // Internal\n      [kInternal]: {\n        currentUserIdStore,\n        mentionSuggestionsCache,\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\n        usersStore,\n        roomsInfoStore,\n        getRoomIds() {\n          return Array.from(roomsById.keys());\n        },\n        // \"All\" threads (= \"user\" threads)\n        getUserThreads_experimental: notificationsAPI.getUserThreads_experimental,\n        getUserThreadsSince_experimental: notificationsAPI.getUserThreadsSince_experimental,\n        // Type-level helper only, it's effectively only an identity-function at runtime\n        as: () => client\n      }\n    },\n    kInternal,\n    {\n      enumerable: false\n    }\n  );\n  return client;\n}\nfunction checkBounds(option, value, min, max, recommendedMin) {\n  if (typeof value !== \"number\" || value < min || max !== void 0 && value > max) {\n    throw new Error(\n      max !== void 0 ? `${option} should be between ${_nullishCoalesce(recommendedMin, () => ( min))} and ${max}.` : `${option} should be at least ${_nullishCoalesce(recommendedMin, () => ( min))}.`\n    );\n  }\n  return value;\n}\nfunction getBackgroundKeepAliveTimeout(value) {\n  if (value === void 0) return void 0;\n  return checkBounds(\n    \"backgroundKeepAliveTimeout\",\n    value,\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\n  );\n}\nfunction getThrottle(value) {\n  return checkBounds(\"throttle\", value, MIN_THROTTLE, MAX_THROTTLE);\n}\nfunction getLostConnectionTimeout(value) {\n  return checkBounds(\n    \"lostConnectionTimeout\",\n    value,\n    MIN_LOST_CONNECTION_TIMEOUT,\n    MAX_LOST_CONNECTION_TIMEOUT,\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\n  );\n}\nfunction createDevelopmentWarning(condition, ...args) {\n  let hasWarned = false;\n  if (process.env.NODE_ENV !== \"production\") {\n    return () => {\n      if (!hasWarned && (typeof condition === \"function\" ? condition() : condition)) {\n        warn(...args);\n        hasWarned = true;\n      }\n    };\n  } else {\n    return () => {\n    };\n  }\n}\n\n// src/comments/comment-body.ts\nfunction isCommentBodyParagraph(element) {\n  return \"type\" in element && element.type === \"paragraph\";\n}\nfunction isCommentBodyText(element) {\n  return !(\"type\" in element) && \"text\" in element && typeof element.text === \"string\";\n}\nfunction isCommentBodyMention(element) {\n  return \"type\" in element && element.type === \"mention\";\n}\nfunction isCommentBodyLink(element) {\n  return \"type\" in element && element.type === \"link\";\n}\nvar commentBodyElementsGuards = {\n  paragraph: isCommentBodyParagraph,\n  text: isCommentBodyText,\n  link: isCommentBodyLink,\n  mention: isCommentBodyMention\n};\nvar commentBodyElementsTypes = {\n  paragraph: \"block\",\n  text: \"inline\",\n  link: \"inline\",\n  mention: \"inline\"\n};\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\n  if (!body || !_optionalChain([body, 'optionalAccess', _171 => _171.content])) {\n    return;\n  }\n  const element = typeof elementOrVisitor === \"string\" ? elementOrVisitor : void 0;\n  const type = element ? commentBodyElementsTypes[element] : \"all\";\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\n  const visitor = typeof elementOrVisitor === \"function\" ? elementOrVisitor : possiblyVisitor;\n  for (const block of body.content) {\n    if (type === \"all\" || type === \"block\") {\n      if (guard(block)) {\n        _optionalChain([visitor, 'optionalCall', _172 => _172(block)]);\n      }\n    }\n    if (type === \"all\" || type === \"inline\") {\n      for (const inline of block.children) {\n        if (guard(inline)) {\n          _optionalChain([visitor, 'optionalCall', _173 => _173(inline)]);\n        }\n      }\n    }\n  }\n}\nfunction getMentionedIdsFromCommentBody(body) {\n  const mentionedIds = /* @__PURE__ */ new Set();\n  traverseCommentBody(\n    body,\n    \"mention\",\n    (mention) => mentionedIds.add(mention.id)\n  );\n  return Array.from(mentionedIds);\n}\nasync function resolveUsersInCommentBody(body, resolveUsers) {\n  const resolvedUsers = /* @__PURE__ */ new Map();\n  if (!resolveUsers) {\n    return resolvedUsers;\n  }\n  const userIds = getMentionedIdsFromCommentBody(body);\n  const users = await resolveUsers({\n    userIds\n  });\n  for (const [index, userId] of userIds.entries()) {\n    const user = _optionalChain([users, 'optionalAccess', _174 => _174[index]]);\n    if (user) {\n      resolvedUsers.set(userId, user);\n    }\n  }\n  return resolvedUsers;\n}\nvar htmlEscapables = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\"\n};\nvar htmlEscapablesRegex = new RegExp(\n  Object.keys(htmlEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction htmlSafe(value) {\n  return new HtmlSafeString([String(value)], []);\n}\nfunction joinHtml(strings) {\n  if (strings.length <= 0) {\n    return new HtmlSafeString([\"\"], []);\n  }\n  return new HtmlSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeHtml(value) {\n  if (value instanceof HtmlSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinHtml(value).toString();\n  }\n  return String(value).replace(\n    htmlEscapablesRegex,\n    (character) => htmlEscapables[character]\n  );\n}\nvar HtmlSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction html(strings, ...values) {\n  return new HtmlSafeString(strings, values);\n}\nvar markdownEscapables = {\n  _: \"\\\\_\",\n  \"*\": \"\\\\*\",\n  \"#\": \"\\\\#\",\n  \"`\": \"\\\\`\",\n  \"~\": \"\\\\~\",\n  \"!\": \"\\\\!\",\n  \"|\": \"\\\\|\",\n  \"(\": \"\\\\(\",\n  \")\": \"\\\\)\",\n  \"{\": \"\\\\{\",\n  \"}\": \"\\\\}\",\n  \"[\": \"\\\\[\",\n  \"]\": \"\\\\]\"\n};\nvar markdownEscapablesRegex = new RegExp(\n  Object.keys(markdownEscapables).map((entity) => `\\\\${entity}`).join(\"|\"),\n  \"g\"\n);\nfunction joinMarkdown(strings) {\n  if (strings.length <= 0) {\n    return new MarkdownSafeString([\"\"], []);\n  }\n  return new MarkdownSafeString(\n    [\"\", ...Array(strings.length - 1).fill(\"\"), \"\"],\n    strings\n  );\n}\nfunction escapeMarkdown(value) {\n  if (value instanceof MarkdownSafeString) {\n    return value.toString();\n  }\n  if (Array.isArray(value)) {\n    return joinMarkdown(value).toString();\n  }\n  return String(value).replace(\n    markdownEscapablesRegex,\n    (character) => markdownEscapables[character]\n  );\n}\nvar MarkdownSafeString = class {\n  constructor(strings, values) {\n    this._strings = strings;\n    this._values = values;\n  }\n  toString() {\n    return this._strings.reduce((result, str, i) => {\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\n    });\n  }\n};\nfunction markdown(strings, ...values) {\n  return new MarkdownSafeString(strings, values);\n}\nfunction toAbsoluteUrl(url2) {\n  if (url2.startsWith(\"http://\") || url2.startsWith(\"https://\")) {\n    return url2;\n  } else if (url2.startsWith(\"www.\")) {\n    return \"https://\" + url2;\n  }\n  return;\n}\nvar stringifyCommentBodyPlainElements = {\n  paragraph: ({ children }) => children,\n  text: ({ element }) => element.text,\n  link: ({ element }) => _nullishCoalesce(element.text, () => ( element.url)),\n  mention: ({ element, user }) => {\n    return `@${_nullishCoalesce(_optionalChain([user, 'optionalAccess', _175 => _175.name]), () => ( element.id))}`;\n  }\n};\nvar stringifyCommentBodyHtmlElements = {\n  paragraph: ({ children }) => {\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = html`<strong>${children}</strong>`;\n    }\n    if (element.italic) {\n      children = html`<em>${children}</em>`;\n    }\n    if (element.strikethrough) {\n      children = html`<s>${children}</s>`;\n    }\n    if (element.code) {\n      children = html`<code>${children}</code>`;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return html`<a href=\"${href}\" target=\"_blank\" rel=\"noopener noreferrer\">${_nullishCoalesce(element.text, () => ( element.url))}</a>`;\n  },\n  mention: ({ element, user }) => {\n    return html`<span data-mention>@${_nullishCoalesce(_optionalChain([user, 'optionalAccess', _176 => _176.name]), () => ( element.id))}</span>`;\n  }\n};\nvar stringifyCommentBodyMarkdownElements = {\n  paragraph: ({ children }) => {\n    return children;\n  },\n  text: ({ element }) => {\n    let children = element.text;\n    if (!children) {\n      return children;\n    }\n    if (element.bold) {\n      children = markdown`**${children}**`;\n    }\n    if (element.italic) {\n      children = markdown`_${children}_`;\n    }\n    if (element.strikethrough) {\n      children = markdown`~~${children}~~`;\n    }\n    if (element.code) {\n      children = markdown`\\`${children}\\``;\n    }\n    return children;\n  },\n  link: ({ element, href }) => {\n    return markdown`[${_nullishCoalesce(element.text, () => ( element.url))}](${href})`;\n  },\n  mention: ({ element, user }) => {\n    return markdown`@${_nullishCoalesce(_optionalChain([user, 'optionalAccess', _177 => _177.name]), () => ( element.id))}`;\n  }\n};\nasync function stringifyCommentBody(body, options) {\n  const format = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _178 => _178.format]), () => ( \"plain\"));\n  const separator = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _179 => _179.separator]), () => ( (format === \"markdown\" ? \"\\n\\n\" : \"\\n\")));\n  const elements = {\n    ...format === \"html\" ? stringifyCommentBodyHtmlElements : format === \"markdown\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\n    ..._optionalChain([options, 'optionalAccess', _180 => _180.elements])\n  };\n  const resolvedUsers = await resolveUsersInCommentBody(\n    body,\n    _optionalChain([options, 'optionalAccess', _181 => _181.resolveUsers])\n  );\n  const blocks = body.content.flatMap((block, blockIndex) => {\n    switch (block.type) {\n      case \"paragraph\": {\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\n          if (isCommentBodyMention(inline)) {\n            return inline.id ? [\n              elements.mention(\n                {\n                  element: inline,\n                  user: resolvedUsers.get(inline.id)\n                },\n                inlineIndex\n              )\n            ] : [];\n          }\n          if (isCommentBodyLink(inline)) {\n            return [\n              elements.link(\n                {\n                  element: inline,\n                  href: _nullishCoalesce(toAbsoluteUrl(inline.url), () => ( inline.url))\n                },\n                inlineIndex\n              )\n            ];\n          }\n          if (isCommentBodyText(inline)) {\n            return [elements.text({ element: inline }, inlineIndex)];\n          }\n          return [];\n        });\n        return [\n          elements.paragraph(\n            { element: block, children: inlines.join(\"\") },\n            blockIndex\n          )\n        ];\n      }\n      default:\n        return [];\n    }\n  });\n  return blocks.join(separator);\n}\n\n// src/crdts/utils.ts\nfunction toPlainLson(lson) {\n  if (lson instanceof LiveObject) {\n    return {\n      liveblocksType: \"LiveObject\",\n      data: Object.fromEntries(\n        Object.entries(lson.toObject()).flatMap(\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\n        )\n      )\n    };\n  } else if (lson instanceof LiveMap) {\n    return {\n      liveblocksType: \"LiveMap\",\n      data: Object.fromEntries(\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\n      )\n    };\n  } else if (lson instanceof LiveList) {\n    return {\n      liveblocksType: \"LiveList\",\n      data: [...lson].map((item) => toPlainLson(item))\n    };\n  } else {\n    return lson;\n  }\n}\n\n// src/immutable.ts\nfunction lsonObjectToJson(obj) {\n  const result = {};\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result[key] = lsonToJson(val);\n    }\n  }\n  return result;\n}\nfunction liveObjectToJson(liveObject) {\n  return lsonObjectToJson(liveObject.toObject());\n}\nfunction liveMapToJson(map) {\n  const result = {};\n  for (const [key, value] of map.entries()) {\n    result[key] = lsonToJson(value);\n  }\n  return result;\n}\nfunction lsonListToJson(value) {\n  return value.map(lsonToJson);\n}\nfunction liveListToJson(value) {\n  return lsonListToJson(value.toArray());\n}\nfunction lsonToJson(value) {\n  if (value instanceof LiveObject) {\n    return liveObjectToJson(value);\n  } else if (value instanceof LiveList) {\n    return liveListToJson(value);\n  } else if (value instanceof LiveMap) {\n    return liveMapToJson(value);\n  } else if (value instanceof LiveRegister) {\n    return value.data;\n  }\n  if (Array.isArray(value)) {\n    return lsonListToJson(value);\n  } else if (isPlainObject(value)) {\n    return lsonObjectToJson(value);\n  }\n  return value;\n}\nfunction deepLiveify(value) {\n  if (Array.isArray(value)) {\n    return new LiveList(value.map(deepLiveify));\n  } else if (isPlainObject(value)) {\n    const init = {};\n    for (const key in value) {\n      const val = value[key];\n      if (val === void 0) {\n        continue;\n      }\n      init[key] = deepLiveify(val);\n    }\n    return new LiveObject(init);\n  } else {\n    return value;\n  }\n}\nfunction patchLiveList(liveList, prev, next) {\n  let i = 0;\n  let prevEnd = prev.length - 1;\n  let nextEnd = next.length - 1;\n  let prevNode = prev[0];\n  let nextNode = next[0];\n  outer: {\n    while (prevNode === nextNode) {\n      ++i;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[i];\n      nextNode = next[i];\n    }\n    prevNode = prev[prevEnd];\n    nextNode = next[nextEnd];\n    while (prevNode === nextNode) {\n      prevEnd--;\n      nextEnd--;\n      if (i > prevEnd || i > nextEnd) {\n        break outer;\n      }\n      prevNode = prev[prevEnd];\n      nextNode = next[nextEnd];\n    }\n  }\n  if (i > prevEnd) {\n    if (i <= nextEnd) {\n      while (i <= nextEnd) {\n        liveList.insert(deepLiveify(next[i]), i);\n        i++;\n      }\n    }\n  } else if (i > nextEnd) {\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  } else {\n    while (i <= prevEnd && i <= nextEnd) {\n      prevNode = prev[i];\n      nextNode = next[i];\n      const liveListNode = liveList.get(i);\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\n        patchLiveObject(liveListNode, prevNode, nextNode);\n      } else {\n        liveList.set(i, deepLiveify(nextNode));\n      }\n      i++;\n    }\n    while (i <= nextEnd) {\n      liveList.insert(deepLiveify(next[i]), i);\n      i++;\n    }\n    let localI = i;\n    while (localI <= prevEnd) {\n      liveList.delete(i);\n      localI++;\n    }\n  }\n}\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const nonSerializableValue = findNonSerializableValue(next);\n    if (nonSerializableValue) {\n      error2(\n        `New state path: '${nonSerializableValue.path}' value: '${String(\n          nonSerializableValue.value\n        )}' is not serializable.\nOnly serializable value can be synced with Liveblocks.`\n      );\n      return;\n    }\n  }\n  const value = liveObject.get(key);\n  if (next === void 0) {\n    liveObject.delete(key);\n  } else if (value === void 0) {\n    liveObject.set(key, deepLiveify(next));\n  } else if (prev === next) {\n    return;\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\n    patchLiveList(value, prev, next);\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\n    patchLiveObject(value, prev, next);\n  } else {\n    liveObject.set(key, deepLiveify(next));\n  }\n}\nfunction patchLiveObject(root, prev, next) {\n  const updates = {};\n  for (const key in next) {\n    patchLiveObjectKey(root, key, prev[key], next[key]);\n  }\n  for (const key in prev) {\n    if (next[key] === void 0) {\n      root.delete(key);\n    }\n  }\n  if (Object.keys(updates).length > 0) {\n    root.update(updates);\n  }\n}\nfunction getParentsPath(node) {\n  const path = [];\n  while (node.parent.type === \"HasParent\") {\n    if (isLiveList(node.parent.node)) {\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\n    } else {\n      path.push(node.parent.key);\n    }\n    node = node.parent.node;\n  }\n  return path;\n}\nfunction legacy_patchImmutableObject(state, updates) {\n  return updates.reduce(\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\n    state\n  );\n}\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\n  const path = getParentsPath(update.node);\n  return legacy_patchImmutableNode(state, path, update);\n}\nfunction legacy_patchImmutableNode(state, path, update) {\n  const pathItem = path.pop();\n  if (pathItem === void 0) {\n    switch (update.type) {\n      case \"LiveObject\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveObject but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (_optionalChain([update, 'access', _182 => _182.updates, 'access', _183 => _183[key], 'optionalAccess', _184 => _184.type]) === \"update\") {\n            const val = update.node.get(key);\n            if (val !== void 0) {\n              newState[key] = lsonToJson(val);\n            }\n          } else if (_optionalChain([update, 'access', _185 => _185.updates, 'access', _186 => _186[key], 'optionalAccess', _187 => _187.type]) === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n      case \"LiveList\": {\n        if (!Array.isArray(state)) {\n          throw new Error(\n            \"Internal: received update on LiveList but state was not an array\"\n          );\n        }\n        let newState = state.map((x) => x);\n        for (const listUpdate of update.updates) {\n          if (listUpdate.type === \"set\") {\n            newState = newState.map(\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\n            );\n          } else if (listUpdate.type === \"insert\") {\n            if (listUpdate.index === newState.length) {\n              newState.push(lsonToJson(listUpdate.item));\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index)\n              ];\n            }\n          } else if (listUpdate.type === \"delete\") {\n            newState.splice(listUpdate.index, 1);\n          } else if (listUpdate.type === \"move\") {\n            if (listUpdate.previousIndex > listUpdate.index) {\n              newState = [\n                ...newState.slice(0, listUpdate.index),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\n                ...newState.slice(listUpdate.previousIndex + 1)\n              ];\n            } else {\n              newState = [\n                ...newState.slice(0, listUpdate.previousIndex),\n                ...newState.slice(\n                  listUpdate.previousIndex + 1,\n                  listUpdate.index + 1\n                ),\n                lsonToJson(listUpdate.item),\n                ...newState.slice(listUpdate.index + 1)\n              ];\n            }\n          }\n        }\n        return newState;\n      }\n      case \"LiveMap\": {\n        if (!isJsonObject(state)) {\n          throw new Error(\n            \"Internal: received update on LiveMap but state was not an object\"\n          );\n        }\n        const newState = Object.assign({}, state);\n        for (const key in update.updates) {\n          if (_optionalChain([update, 'access', _188 => _188.updates, 'access', _189 => _189[key], 'optionalAccess', _190 => _190.type]) === \"update\") {\n            const value = update.node.get(key);\n            if (value !== void 0) {\n              newState[key] = lsonToJson(value);\n            }\n          } else if (_optionalChain([update, 'access', _191 => _191.updates, 'access', _192 => _192[key], 'optionalAccess', _193 => _193.type]) === \"delete\") {\n            delete newState[key];\n          }\n        }\n        return newState;\n      }\n    }\n  }\n  if (Array.isArray(state)) {\n    const newArray = [...state];\n    newArray[pathItem] = legacy_patchImmutableNode(\n      state[pathItem],\n      path,\n      update\n    );\n    return newArray;\n  } else if (isJsonObject(state)) {\n    const node = state[pathItem];\n    if (node === void 0) {\n      return state;\n    } else {\n      const stateAsObj = state;\n      return {\n        ...stateAsObj,\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\n      };\n    }\n  } else {\n    return state;\n  }\n}\n\n// src/lib/deprecation.ts\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\nfunction deprecate(message, key = message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!_emittedDeprecationWarnings.has(key)) {\n      _emittedDeprecationWarnings.add(key);\n      errorWithTitle(\"Deprecation warning\", message);\n    }\n  }\n}\nfunction deprecateIf(condition, message, key = message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      deprecate(message, key);\n    }\n  }\n}\nfunction throwUsageError(message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    const usageError = new Error(message);\n    usageError.name = \"Usage error\";\n    errorWithTitle(\"Usage error\", message);\n    throw usageError;\n  }\n}\nfunction errorIf(condition, message) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (condition) {\n      throwUsageError(message);\n    }\n  }\n}\n\n// src/lib/Poller.ts\nvar BACKOFF_DELAYS2 = [1e3, 2e3, 4e3, 8e3, 1e4];\nfunction makePoller(callback, intervalMs, options) {\n  const startTime = performance.now();\n  const doc = typeof document !== \"undefined\" ? document : void 0;\n  const win = typeof window !== \"undefined\" ? window : void 0;\n  const maxStaleTimeMs = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _194 => _194.maxStaleTimeMs]), () => ( Number.POSITIVE_INFINITY));\n  const context = {\n    inForeground: _optionalChain([doc, 'optionalAccess', _195 => _195.visibilityState]) !== \"hidden\",\n    lastSuccessfulPollAt: startTime,\n    count: 0,\n    backoff: 0\n  };\n  function mayPoll() {\n    return context.count > 0 && context.inForeground;\n  }\n  const fsm = new FSM({}).addState(\"@idle\").addState(\"@enabled\").addState(\"@polling\");\n  fsm.addTransitions(\"@idle\", { START: \"@enabled\" });\n  fsm.addTransitions(\"@enabled\", { STOP: \"@idle\", POLL: \"@polling\" });\n  fsm.addTimedTransition(\n    \"@enabled\",\n    () => {\n      const lastPoll = context.lastSuccessfulPollAt;\n      const nextPoll = lastPoll + intervalMs;\n      return Math.max(0, nextPoll - performance.now()) + context.backoff;\n    },\n    \"@polling\"\n  );\n  fsm.onEnterAsync(\n    \"@polling\",\n    async (_ctx, signal) => {\n      await callback(signal);\n      if (!signal.aborted) {\n        context.lastSuccessfulPollAt = performance.now();\n      }\n    },\n    // When OK\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = 0;\n        }\n      };\n    },\n    // When error\n    () => {\n      return {\n        target: mayPoll() ? \"@enabled\" : \"@idle\",\n        effect: () => {\n          context.backoff = _nullishCoalesce(BACKOFF_DELAYS2.find((delay) => delay > context.backoff), () => ( BACKOFF_DELAYS2[BACKOFF_DELAYS2.length - 1]));\n        }\n      };\n    },\n    3e4\n    // Abort the poll if the callback takes more than 30 seconds to complete\n  );\n  function startOrStop() {\n    if (mayPoll()) {\n      fsm.send({ type: \"START\" });\n    } else {\n      fsm.send({ type: \"STOP\" });\n    }\n  }\n  function inc() {\n    context.count++;\n    startOrStop();\n  }\n  function dec() {\n    context.count--;\n    if (context.count < 0) {\n      context.count = 0;\n    }\n    startOrStop();\n  }\n  function pollNowIfStale() {\n    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {\n      fsm.send({ type: \"POLL\" });\n    }\n  }\n  function setInForeground(inForeground) {\n    context.inForeground = inForeground;\n    startOrStop();\n    pollNowIfStale();\n  }\n  function onVisibilityChange() {\n    setInForeground(_optionalChain([doc, 'optionalAccess', _196 => _196.visibilityState]) !== \"hidden\");\n  }\n  _optionalChain([doc, 'optionalAccess', _197 => _197.addEventListener, 'call', _198 => _198(\"visibilitychange\", onVisibilityChange)]);\n  _optionalChain([win, 'optionalAccess', _199 => _199.addEventListener, 'call', _200 => _200(\"online\", onVisibilityChange)]);\n  fsm.start();\n  return {\n    inc,\n    dec,\n    pollNowIfStale,\n    // Internal API, used by unit tests only to simulate visibility events\n    setInForeground\n  };\n}\n\n// src/lib/shallow.ts\nfunction shallowArray(xs, ys) {\n  if (xs.length !== ys.length) {\n    return false;\n  }\n  for (let i = 0; i < xs.length; i++) {\n    if (!Object.is(xs[i], ys[i])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shallowObj(objA, objB) {\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  return keysA.every(\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\n  );\n}\nfunction shallow(a, b) {\n  if (Object.is(a, b)) {\n    return true;\n  }\n  const isArrayA = Array.isArray(a);\n  const isArrayB = Array.isArray(b);\n  if (isArrayA || isArrayB) {\n    if (!isArrayA || !isArrayB) {\n      return false;\n    }\n    return shallowArray(a, b);\n  }\n  return shallowObj(a, b);\n}\n\n// src/lib/SortedList.ts\nfunction bisectRight(arr, x, lt) {\n  let lo = 0;\n  let hi = arr.length;\n  while (lo < hi) {\n    const mid = lo + (hi - lo >> 1);\n    if (lt(x, arr[mid])) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\nvar SortedList = class _SortedList {\n  constructor(alreadySortedList, lt) {\n    this._lt = lt;\n    this._data = alreadySortedList;\n  }\n  static from(arr, lt) {\n    const sorted = new _SortedList([], lt);\n    for (const item of arr) {\n      sorted.add(item);\n    }\n    return sorted;\n  }\n  static fromAlreadySorted(alreadySorted, lt) {\n    return new _SortedList(alreadySorted, lt);\n  }\n  /**\n   * Clones the sorted list to a new instance.\n   */\n  clone() {\n    return new _SortedList(this._data.slice(), this._lt);\n  }\n  /**\n   * Adds a new item to the sorted list, such that it remains sorted.\n   */\n  add(value) {\n    const idx = bisectRight(this._data, value, this._lt);\n    this._data.splice(idx, 0, value);\n  }\n  /**\n   * Removes the given value from the sorted list, if it exists. The given\n   * value must be `===` to one of the list items. Only the first entry will be\n   * removed if the element exists in the sorted list multiple times.\n   */\n  remove(value) {\n    const idx = this._data.indexOf(value);\n    if (idx >= 0) {\n      this._data.splice(idx, 1);\n      return true;\n    }\n    return false;\n  }\n  get length() {\n    return this._data.length;\n  }\n  *filter(predicate) {\n    for (const item of this._data) {\n      if (predicate(item)) {\n        yield item;\n      }\n    }\n  }\n  [Symbol.iterator]() {\n    return this._data[Symbol.iterator]();\n  }\n};\n\n// src/index.ts\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\nvar CommentsApiError = HttpError;\nvar NotificationsApiError = HttpError;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexports.ClientMsgCode = ClientMsgCode; exports.CommentsApiError = CommentsApiError; exports.CrdtType = CrdtType; exports.HttpError = HttpError; exports.LiveList = LiveList; exports.LiveMap = LiveMap; exports.LiveObject = LiveObject; exports.NotificationsApiError = NotificationsApiError; exports.OpCode = OpCode; exports.ServerMsgCode = ServerMsgCode; exports.SortedList = SortedList; exports.WebsocketCloseCodes = WebsocketCloseCodes; exports.ackOp = ackOp; exports.asPos = asPos; exports.assert = assert; exports.assertNever = assertNever; exports.autoRetry = autoRetry; exports.b64decode = b64decode; exports.chunk = chunk; exports.cloneLson = cloneLson; exports.compactObject = compactObject; exports.console = fancy_console_exports; exports.convertToCommentData = convertToCommentData; exports.convertToCommentUserReaction = convertToCommentUserReaction; exports.convertToInboxNotificationData = convertToInboxNotificationData; exports.convertToThreadData = convertToThreadData; exports.createClient = createClient; exports.createCommentId = createCommentId; exports.createInboxNotificationId = createInboxNotificationId; exports.createStore = createStore; exports.createThreadId = createThreadId; exports.deprecate = deprecate; exports.deprecateIf = deprecateIf; exports.detectDupes = detectDupes; exports.errorIf = errorIf; exports.freeze = freeze; exports.getMentionedIdsFromCommentBody = getMentionedIdsFromCommentBody; exports.isChildCrdt = isChildCrdt; exports.isJsonArray = isJsonArray; exports.isJsonObject = isJsonObject; exports.isJsonScalar = isJsonScalar; exports.isLiveNode = isLiveNode; exports.isPlainObject = isPlainObject; exports.isRootCrdt = isRootCrdt; exports.kInternal = kInternal; exports.legacy_patchImmutableObject = legacy_patchImmutableObject; exports.lsonToJson = lsonToJson; exports.makeEventSource = makeEventSource; exports.makePoller = makePoller; exports.makePosition = makePosition; exports.mapValues = mapValues; exports.memoizeOnSuccess = memoizeOnSuccess; exports.nanoid = nanoid; exports.nn = nn; exports.objectToQuery = objectToQuery; exports.patchLiveObjectKey = patchLiveObjectKey; exports.raise = raise; exports.shallow = shallow; exports.stringify = stringify; exports.stringifyCommentBody = stringifyCommentBody; exports.throwUsageError = throwUsageError; exports.toPlainLson = toPlainLson; exports.tryParseJson = tryParseJson; exports.url = url; exports.urljoin = urljoin; exports.wait = wait; exports.withTimeout = withTimeout;\n//# sourceMappingURL=index.js.map\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["_cachedImmutable","editedAt","parentId","deprecateIf","callback","isStorageReady","enterRoom","_users","rootKey","message","roomsInfoStore","since","parts","nodeCount","waitUntilPresenceReady","cleanups","requestedScope","updatedAt","_propToLastUpdate","EXPLICIT_SOCKET_ERROR","nextCursor","newItem","promise","allowedTransitions","getAttachmentUrl","shouldQueueEventIfNotReady","throttleDelay","__pool","convertToCommentUserReaction","CommentsApiError","presenceUpdates","inForeground","reconnect","targetActor","protocol","pos","detectDupes","broadcastEvent","authenticate","url","tryParseJson","throwUsageError","__id","deprecate","freeze","mentionId","unstable_batchedUpdates","NAVIGATOR_ONLINE","token","uploadAttachment","unstable_fallbackToHTTP","isChildCrdt","patchLiveObjectKey","versions","resolve","redo","body","asPos","NotificationsApiError","LiveObject","b64decode","connectionId","Authorization","index","isJsonScalar","withTimeout","backgroundKeepAliveTimeout","storageStatus","activeBatch","isLiveNode","threads","isRootCrdt","WINDOW_GOT_FOCUS","getUserThreadsSince_experimental","simulate","_value","parentKey","enableDebugLogging","createComment","part","eventHub","createdAt","onMessage","_parent","getStatus","authManager","createClient","deleteThread","unpause","resolvers","userIds","partNumber","cleanupStack","disconnect","msg","runningState","customEvent","operator","createSocket","generateOpId","updates","lostConnection","redoStack","convertToThreadData","usersStore","reverse","unsubs","queue","assertNever","warnWithTitle","ops","deleteComment","_forceClear","pathname","method","reverseOps","_cachedTreeNode","invalidateUsers","ackOp","updatePresence","emoji","addNode","key","reactions","query","children","newIndex","explicitClose","user","updateNotificationSettings","__esModule","storage","force","_data","getOthers","DISCONNECT","info","warn","path","invalidateMentionSuggestions","_refs","stringifyCommentBody","editComment","initialStorage","isJsonObject","error","deleteNode","backoff","unacknowledgedOps","deleteTextMention","id","others","flush","storageUpdates","states","compactObject","reset","batch","root","createInboxNotificationId","event","kInternal","myPresence","getNotificationSettings","mentionSuggestionsCache","count","update","getNode","currentUserIdStore","createTextVersion","_cache","_fetchPolyfill","errorWithTitle","undo","_transform","getSelf","toPlainLson","nanoid","provider","clientVersion","buffer","signal","element","chunk","console","href","name","getState","previousIndex","willExitState","getAuthValue","urljoin","getRoom","limit","fetchYDoc","userInfo","waitUntilStorageReady","attachmentUrlsStore","waitForActorId","deletedAt","getStorage","attachmentIds","nn","pausedHistory","ServerMsgCode","value","markThreadAsUnresolved","userId","items","createStore","deleteInboxNotification","_cacheKeys","willTransition","LiveList","destroy","connect","inc","scopes","enumerable","observable","inboxNotificationIds","updateYDoc","baseUrl","editThreadMetadata","liveblocksType","didIgnoreEvent","deletedItem","requestedAt","_implicitlyDeletedItems","unacknowledgedSet","_values","vector","inboxNotifications","removeReaction","readAt","wait","createThread","status","undoStack","isLoading","rawSend","objectToQuery","successCount","pause","text","opStackTraces","OpCode","CrdtType","cursor","createCommentId","dynamicSessionInfo","item","parsed","currentStateOrNull","leave","getInboxNotificationsSince","didDisconnect","_unacknowledgedSets","current","paragraph","listTextVersionsSince","mention","_","self","machine","invalidate","currentContext","getStorageSnapshot","fetchPolyfill","getStorageStatus","createThreadId","oldKey","metadata","getInboxNotifications","length","convertToCommentData","reportTextEditor","makePosition","raise","_items","clock","events","intent","input","publicApiKey","oldPos","memoizeOnSuccess","storageDidLoad","nodes","markThreadAsResolved","cloneLson","RECONNECT","canRedo","delay","history","knownEventTypes","link","source","storageOperations","createTextMention","type","staticSessionInfo","lastSuccessfulPollAt","activities","initialPresence","presence","comments","legacy_patchImmutableObject","effect","getTextVersion","isPresenceReady","makePoller","_presences","statusDidChange","stringify","deleted","enterFns","authValue","errorIf","flushTimerID","modified","generateId","setInForeground","didEnterState","_strings","from","ClientMsgCode","inboxNotification","mapValues","assertStorageIsWritable","SortedList","target","details","polyfills","reason","presenceBuffer","getMentionedIdsFromCommentBody","addReaction","updated","getUnreadInboxNotificationsCount","didConnect","file","_innerIterator","set","messages","nonce","CONNECT","getSelf_forDevTools","delayTimeoutId","canWrite","unstable_streamData","getThreads","fileSize","onProviderUpdate","_map","room","subscribeOnce","curr","size","_connections","makeEventSource","roomId","invalidateRoomsInfo","notify","mimeType","resolveMentionSuggestions","START","convertToInboxNotificationData","markInboxNotificationAsRead","thread","socket","clear","HttpError","ydoc","isJsonArray","deletedId","comment","logout","getUserThreads_experimental","raw","reject","payload","isReadOnly","EXPLICIT_SOCKET_CLOSE","waitUntil","storageBatch","_authCallback","markAllInboxNotificationsAsRead","POLL","to","_lt","didReceiveEvent","isPlainObject","opId","STOP","dec","PONG","subscribe","prepareAttachment","search","data","get","getThreadsSince","notifiedAt","lostConnectionTimeout","delegates","NAVIGATOR_OFFLINE","guid","as","_cachedTreeNodeKey","code","deleteAllInboxNotifications","done","actor","autoRetry","me","LiveMap","_baseUrl","opClock","assert","listTextVersions","roomIds","onLiveblocksError","_ev","atob","idFactory","node","getThread","lastFlushedAt","backoffDelay","pollNowIfStale","resume","unsubscribe","canComment","getOthers_forDevTools","canUndo","shallow","getPresence","lsonToJson","WebsocketCloseCodes","headers"]],"~:compiled-at",1730300623551,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$liveblocks$core$dist$index.js\",\n\"lineCount\":4162,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@liveblocks/core/dist/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$liveblocks$core$dist$index\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";Object.defineProperty(exports, \\\"__esModule\\\", {value: true}); function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }var __defProp = Object.defineProperty;\\nvar __export = (target, all) => {\\n  for (var name in all)\\n    __defProp(target, name, { get: all[name], enumerable: true });\\n};\\n\\n// src/version.ts\\nvar PKG_NAME = \\\"@liveblocks/core\\\";\\nvar PKG_VERSION = \\\"2.10.2\\\";\\nvar PKG_FORMAT = \\\"cjs\\\";\\n\\n// src/dupe-detection.ts\\nvar g = typeof globalThis !== \\\"undefined\\\" ? globalThis : typeof window !== \\\"undefined\\\" ? window : typeof global !== \\\"undefined\\\" ? global : {};\\nvar crossLinkedDocs = \\\"https://liveblocks.io/docs/errors/cross-linked\\\";\\nvar dupesDocs = \\\"https://liveblocks.io/docs/errors/dupes\\\";\\nvar SPACE = \\\" \\\";\\nfunction error(msg) {\\n  if (process.env.NODE_ENV === \\\"production\\\") {\\n    console.error(msg);\\n  } else {\\n    throw new Error(msg);\\n  }\\n}\\nfunction detectDupes(pkgName, pkgVersion, pkgFormat) {\\n  const pkgId = Symbol.for(pkgName);\\n  const pkgBuildInfo = pkgFormat ? `${pkgVersion || \\\"dev\\\"} (${pkgFormat})` : pkgVersion || \\\"dev\\\";\\n  if (!g[pkgId]) {\\n    g[pkgId] = pkgBuildInfo;\\n  } else if (g[pkgId] === pkgBuildInfo) {\\n  } else {\\n    const msg = [\\n      `Multiple copies of Liveblocks are being loaded in your project. This will cause issues! See ${dupesDocs + SPACE}`,\\n      \\\"\\\",\\n      \\\"Conflicts:\\\",\\n      `- ${pkgName} ${g[pkgId]} (already loaded)`,\\n      `- ${pkgName} ${pkgBuildInfo} (trying to load this now)`\\n    ].join(\\\"\\\\n\\\");\\n    error(msg);\\n  }\\n  if (pkgVersion && PKG_VERSION && pkgVersion !== PKG_VERSION) {\\n    error(\\n      [\\n        `Cross-linked versions of Liveblocks found, which will cause issues! See ${crossLinkedDocs + SPACE}`,\\n        \\\"\\\",\\n        \\\"Conflicts:\\\",\\n        `- ${PKG_NAME} is at ${PKG_VERSION}`,\\n        `- ${pkgName} is at ${pkgVersion}`,\\n        \\\"\\\",\\n        \\\"Always upgrade all Liveblocks packages to the same version number.\\\"\\n      ].join(\\\"\\\\n\\\")\\n    );\\n  }\\n}\\n\\n// src/lib/assert.ts\\nfunction assertNever(_value, errmsg) {\\n  throw new Error(errmsg);\\n}\\nfunction assert(condition, errmsg) {\\n  if (process.env.NODE_ENV !== \\\"production\\\") {\\n    if (!condition) {\\n      const err = new Error(errmsg);\\n      err.name = \\\"Assertion failure\\\";\\n      throw err;\\n    }\\n  }\\n}\\nfunction nn(value, errmsg = \\\"Expected value to be non-nullable\\\") {\\n  assert(value !== null && value !== void 0, errmsg);\\n  return value;\\n}\\n\\n// src/lib/controlledPromise.ts\\nfunction controlledPromise() {\\n  let resolve;\\n  let reject;\\n  const promise = new Promise((res, rej) => {\\n    resolve = res;\\n    reject = rej;\\n  });\\n  return [promise, resolve, reject];\\n}\\nfunction Promise_withResolvers() {\\n  const [promise, resolve, reject] = controlledPromise();\\n  return { promise, resolve, reject };\\n}\\n\\n// src/lib/EventSource.ts\\nfunction makeEventSource() {\\n  const _onetimeObservers = /* @__PURE__ */ new Set();\\n  const _observers = /* @__PURE__ */ new Set();\\n  let _buffer = null;\\n  function pause() {\\n    _buffer = [];\\n  }\\n  function unpause() {\\n    if (_buffer === null) {\\n      return;\\n    }\\n    for (const event of _buffer) {\\n      notify(event);\\n    }\\n    _buffer = null;\\n  }\\n  function subscribe(callback) {\\n    _observers.add(callback);\\n    return () => _observers.delete(callback);\\n  }\\n  function subscribeOnce(callback) {\\n    _onetimeObservers.add(callback);\\n    return () => _onetimeObservers.delete(callback);\\n  }\\n  async function waitUntil(predicate) {\\n    let unsub;\\n    return new Promise((res) => {\\n      unsub = subscribe((event) => {\\n        if (predicate === void 0 || predicate(event)) {\\n          res(event);\\n        }\\n      });\\n    }).finally(() => _optionalChain([unsub, 'optionalCall', _2 => _2()]));\\n  }\\n  function notifyOrBuffer(event) {\\n    if (_buffer !== null) {\\n      _buffer.push(event);\\n    } else {\\n      notify(event);\\n    }\\n  }\\n  function notify(event) {\\n    _onetimeObservers.forEach((callback) => callback(event));\\n    _onetimeObservers.clear();\\n    _observers.forEach((callback) => callback(event));\\n  }\\n  function _forceClear() {\\n    _onetimeObservers.clear();\\n    _observers.clear();\\n  }\\n  function count() {\\n    return _onetimeObservers.size + _observers.size;\\n  }\\n  return {\\n    // Private/internal control over event emission\\n    notify: notifyOrBuffer,\\n    subscribe,\\n    subscribeOnce,\\n    _forceClear,\\n    count,\\n    waitUntil,\\n    pause,\\n    unpause,\\n    // Publicly exposable subscription API\\n    observable: {\\n      subscribe,\\n      subscribeOnce,\\n      waitUntil\\n    }\\n  };\\n}\\n\\n// src/lib/fancy-console.ts\\nvar fancy_console_exports = {};\\n__export(fancy_console_exports, {\\n  error: () => error2,\\n  errorWithTitle: () => errorWithTitle,\\n  warn: () => warn,\\n  warnWithTitle: () => warnWithTitle\\n});\\nvar badge = \\\"background:#0e0d12;border-radius:9999px;color:#fff;padding:3px 7px;font-family:sans-serif;font-weight:600;\\\";\\nvar bold = \\\"font-weight:600\\\";\\nfunction wrap(method) {\\n  return typeof window === \\\"undefined\\\" || process.env.NODE_ENV === \\\"test\\\" ? console[method] : (\\n    /* istanbul ignore next */\\n    (message, ...args) => console[method](\\\"%cLiveblocks\\\", badge, message, ...args)\\n  );\\n}\\nvar warn = wrap(\\\"warn\\\");\\nvar error2 = wrap(\\\"error\\\");\\nfunction wrapWithTitle(method) {\\n  return typeof window === \\\"undefined\\\" || process.env.NODE_ENV === \\\"test\\\" ? console[method] : (\\n    /* istanbul ignore next */\\n    (title, message, ...args) => console[method](\\n      `%cLiveblocks%c ${title}`,\\n      badge,\\n      bold,\\n      message,\\n      ...args\\n    )\\n  );\\n}\\nvar warnWithTitle = wrapWithTitle(\\\"warn\\\");\\nvar errorWithTitle = wrapWithTitle(\\\"error\\\");\\n\\n// src/lib/fsm.ts\\nfunction distance(state1, state2) {\\n  if (state1 === state2) {\\n    return [0, 0];\\n  }\\n  const chunks1 = state1.split(\\\".\\\");\\n  const chunks2 = state2.split(\\\".\\\");\\n  const minLen = Math.min(chunks1.length, chunks2.length);\\n  let shared = 0;\\n  for (; shared < minLen; shared++) {\\n    if (chunks1[shared] !== chunks2[shared]) {\\n      break;\\n    }\\n  }\\n  const up = chunks1.length - shared;\\n  const down = chunks2.length - shared;\\n  return [up, down];\\n}\\nfunction patterns(targetState, levels) {\\n  const parts = targetState.split(\\\".\\\");\\n  if (levels < 1 || levels > parts.length + 1) {\\n    throw new Error(\\\"Invalid number of levels\\\");\\n  }\\n  const result = [];\\n  if (levels > parts.length) {\\n    result.push(\\\"*\\\");\\n  }\\n  for (let i = parts.length - levels + 1; i < parts.length; i++) {\\n    const slice = parts.slice(0, i);\\n    if (slice.length > 0) {\\n      result.push(slice.join(\\\".\\\") + \\\".*\\\");\\n    }\\n  }\\n  result.push(targetState);\\n  return result;\\n}\\nvar SafeContext = class {\\n  constructor(initialContext) {\\n    this.curr = initialContext;\\n  }\\n  get current() {\\n    return this.curr;\\n  }\\n  /**\\n   * Call a callback function that allows patching of the context, by\\n   * calling `context.patch()`. Patching is only allowed for the duration\\n   * of this window.\\n   */\\n  allowPatching(callback) {\\n    const self = this;\\n    let allowed = true;\\n    const patchableContext = {\\n      ...this.curr,\\n      patch(patch) {\\n        if (allowed) {\\n          self.curr = Object.assign({}, self.curr, patch);\\n          for (const pair of Object.entries(patch)) {\\n            const [key, value] = pair;\\n            if (key !== \\\"patch\\\") {\\n              this[key] = value;\\n            }\\n          }\\n        } else {\\n          throw new Error(\\\"Can no longer patch stale context\\\");\\n        }\\n      }\\n    };\\n    callback(patchableContext);\\n    allowed = false;\\n    return;\\n  }\\n};\\nvar nextId = 1;\\nvar FSM = class {\\n  /**\\n   * Returns the initial state, which is defined by the first call made to\\n   * .addState().\\n   */\\n  get initialState() {\\n    const result = this.states.values()[Symbol.iterator]().next();\\n    if (result.done) {\\n      throw new Error(\\\"No states defined yet\\\");\\n    } else {\\n      return result.value;\\n    }\\n  }\\n  get currentState() {\\n    if (this.currentStateOrNull === null) {\\n      if (this.runningState === 0 /* NOT_STARTED_YET */) {\\n        throw new Error(\\\"Not started yet\\\");\\n      } else {\\n        throw new Error(\\\"Already stopped\\\");\\n      }\\n    }\\n    return this.currentStateOrNull;\\n  }\\n  /**\\n   * Starts the machine by entering the initial state.\\n   */\\n  start() {\\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\\n      throw new Error(\\\"State machine has already started\\\");\\n    }\\n    this.runningState = 1 /* STARTED */;\\n    this.currentStateOrNull = this.initialState;\\n    this.enter(null);\\n    return this;\\n  }\\n  /**\\n   * Stops the state machine. Stopping the state machine will call exit\\n   * handlers for the current state, but not enter a new state.\\n   */\\n  stop() {\\n    if (this.runningState !== 1 /* STARTED */) {\\n      throw new Error(\\\"Cannot stop a state machine that hasn't started yet\\\");\\n    }\\n    this.exit(null);\\n    this.runningState = 2 /* STOPPED */;\\n    this.currentStateOrNull = null;\\n  }\\n  constructor(initialContext) {\\n    this.id = nextId++;\\n    this.runningState = 0 /* NOT_STARTED_YET */;\\n    this.currentStateOrNull = null;\\n    this.states = /* @__PURE__ */ new Set();\\n    this.enterFns = /* @__PURE__ */ new Map();\\n    this.cleanupStack = [];\\n    this.knownEventTypes = /* @__PURE__ */ new Set();\\n    this.allowedTransitions = /* @__PURE__ */ new Map();\\n    this.currentContext = new SafeContext(initialContext);\\n    this.eventHub = {\\n      didReceiveEvent: makeEventSource(),\\n      willTransition: makeEventSource(),\\n      didIgnoreEvent: makeEventSource(),\\n      willExitState: makeEventSource(),\\n      didEnterState: makeEventSource()\\n    };\\n    this.events = {\\n      didReceiveEvent: this.eventHub.didReceiveEvent.observable,\\n      willTransition: this.eventHub.willTransition.observable,\\n      didIgnoreEvent: this.eventHub.didIgnoreEvent.observable,\\n      willExitState: this.eventHub.willExitState.observable,\\n      didEnterState: this.eventHub.didEnterState.observable\\n    };\\n  }\\n  get context() {\\n    return this.currentContext.current;\\n  }\\n  /**\\n   * Define an explicit finite state in the state machine.\\n   */\\n  addState(state) {\\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\\n      throw new Error(\\\"Already started\\\");\\n    }\\n    this.states.add(state);\\n    return this;\\n  }\\n  onEnter(nameOrPattern, enterFn) {\\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\\n      throw new Error(\\\"Already started\\\");\\n    } else if (this.enterFns.has(nameOrPattern)) {\\n      throw new Error(\\n        // TODO We _currently_ don't support multiple .onEnters() for the same\\n        // state, but this is not a fundamental limitation. Just not\\n        // implemented yet. If we wanted to, we could make this an array.\\n        `enter/exit function for ${nameOrPattern} already exists`\\n      );\\n    }\\n    this.enterFns.set(nameOrPattern, enterFn);\\n    return this;\\n  }\\n  /**\\n   * Defines a promise-based state. When the state is entered, the promise is\\n   * created. When the promise resolves, the machine will transition to the\\n   * provided `onOK` target state. When the promise rejects, the machine will\\n   * transition to the `onError` target state.\\n   *\\n   * Optionally, a `maxTimeout` can be set. If the timeout happens before the\\n   * promise is settled, then the machine will also transition to the `onError`\\n   * target state.\\n   *\\n   * @param stateOrPattern  The state name, or state group pattern name.\\n   * @param promiseFn       The callback to be invoked when the state is entered.\\n   * @param onOK            The state to transition to when the promise resolves.\\n   * @param onError         The state to transition to when the promise\\n   *                        rejects, or when the timeout happens before the\\n   *                        promise has been settled.\\n   * @param maxTimeout      Optional timeout in milliseconds.\\n   *\\n   * When the promise callback function is invoked, it's provided with an\\n   * AbortSignal (2nd argument).\\n   * If a state transition happens while the promise is pending (for example,\\n   * an event, or a timeout happens), then an abort signal will be used to\\n   * indicate this. Implementers can use this abort signal to terminate the\\n   * in-flight promise, or ignore its results, etc.\\n   */\\n  onEnterAsync(nameOrPattern, promiseFn, onOK, onError, maxTimeout) {\\n    return this.onEnter(nameOrPattern, () => {\\n      const abortController = new AbortController();\\n      const signal = abortController.signal;\\n      const timeoutId = maxTimeout ? setTimeout(() => {\\n        const reason = new Error(\\\"Timed out\\\");\\n        this.transition({ type: \\\"ASYNC_ERROR\\\", reason }, onError);\\n      }, maxTimeout) : void 0;\\n      let done = false;\\n      void promiseFn(this.currentContext.current, signal).then(\\n        // On OK\\n        (data) => {\\n          if (!signal.aborted) {\\n            done = true;\\n            this.transition({ type: \\\"ASYNC_OK\\\", data }, onOK);\\n          }\\n        },\\n        // On Error\\n        (reason) => {\\n          if (!signal.aborted) {\\n            done = true;\\n            this.transition({ type: \\\"ASYNC_ERROR\\\", reason }, onError);\\n          }\\n        }\\n      );\\n      return () => {\\n        clearTimeout(timeoutId);\\n        if (!done) {\\n          abortController.abort();\\n        }\\n      };\\n    });\\n  }\\n  getStatesMatching(nameOrPattern) {\\n    const matches = [];\\n    if (nameOrPattern === \\\"*\\\") {\\n      for (const state of this.states) {\\n        matches.push(state);\\n      }\\n    } else if (nameOrPattern.endsWith(\\\".*\\\")) {\\n      const prefix = nameOrPattern.slice(0, -1);\\n      for (const state of this.states) {\\n        if (state.startsWith(prefix)) {\\n          matches.push(state);\\n        }\\n      }\\n    } else {\\n      const name = nameOrPattern;\\n      if (this.states.has(name)) {\\n        matches.push(name);\\n      }\\n    }\\n    if (matches.length === 0) {\\n      throw new Error(`No states match ${JSON.stringify(nameOrPattern)}`);\\n    }\\n    return matches;\\n  }\\n  /**\\n   * Define all allowed outgoing transitions for a state.\\n   *\\n   * The targets for each event can be defined as a function which returns the\\n   * next state to transition to. These functions can look at the `event` or\\n   * `context` params to conditionally decide which next state to transition\\n   * to.\\n   *\\n   * If you set it to `null`, then the transition will be explicitly forbidden\\n   * and throw an error. If you don't define a target for a transition, then\\n   * such events will get ignored.\\n   */\\n  addTransitions(nameOrPattern, mapping) {\\n    if (this.runningState !== 0 /* NOT_STARTED_YET */) {\\n      throw new Error(\\\"Already started\\\");\\n    }\\n    for (const srcState of this.getStatesMatching(nameOrPattern)) {\\n      let map = this.allowedTransitions.get(srcState);\\n      if (map === void 0) {\\n        map = /* @__PURE__ */ new Map();\\n        this.allowedTransitions.set(srcState, map);\\n      }\\n      for (const [type, target_] of Object.entries(mapping)) {\\n        if (map.has(type)) {\\n          throw new Error(\\n            `Trying to set transition \\\"${type}\\\" on \\\"${srcState}\\\" (via \\\"${nameOrPattern}\\\"), but a transition already exists there.`\\n          );\\n        }\\n        const target = target_;\\n        this.knownEventTypes.add(type);\\n        if (target !== void 0) {\\n          const targetFn = typeof target === \\\"function\\\" ? target : () => target;\\n          map.set(type, targetFn);\\n        }\\n      }\\n    }\\n    return this;\\n  }\\n  /**\\n   * Like `.addTransition()`, but takes an (anonymous) transition whenever the\\n   * timer fires.\\n   *\\n   * @param stateOrPattern  The state name, or state group pattern name.\\n   * @param after           Number of milliseconds after which to take the\\n   *                        transition. If in the mean time, another transition\\n   *                        is taken, the timer will get cancelled.\\n   * @param target          The target state to go to.\\n   */\\n  addTimedTransition(stateOrPattern, after2, target) {\\n    return this.onEnter(stateOrPattern, () => {\\n      const ms = typeof after2 === \\\"function\\\" ? after2(this.currentContext.current) : after2;\\n      const timeoutID = setTimeout(() => {\\n        this.transition({ type: \\\"TIMER\\\" }, target);\\n      }, ms);\\n      return () => {\\n        clearTimeout(timeoutID);\\n      };\\n    });\\n  }\\n  getTargetFn(eventName) {\\n    return _optionalChain([this, 'access', _3 => _3.allowedTransitions, 'access', _4 => _4.get, 'call', _5 => _5(this.currentState), 'optionalAccess', _6 => _6.get, 'call', _7 => _7(eventName)]);\\n  }\\n  /**\\n   * Exits the current state, and executes any necessary cleanup functions.\\n   * Call this before changing the current state to the next state.\\n   *\\n   * @param levels Defines how many \\\"levels\\\" of nesting will be\\n   * exited. For example, if you transition from `foo.bar.qux` to\\n   * `foo.bar.baz`, then the level is 1. But if you transition from\\n   * `foo.bar.qux` to `bla.bla`, then the level is 3.\\n   * If `null`, it will exit all levels.\\n   */\\n  exit(levels) {\\n    this.eventHub.willExitState.notify(this.currentState);\\n    this.currentContext.allowPatching((patchableContext) => {\\n      levels = _nullishCoalesce(levels, () => ( this.cleanupStack.length));\\n      for (let i = 0; i < levels; i++) {\\n        _optionalChain([this, 'access', _8 => _8.cleanupStack, 'access', _9 => _9.pop, 'call', _10 => _10(), 'optionalCall', _11 => _11(patchableContext)]);\\n      }\\n    });\\n  }\\n  /**\\n   * Enters the current state, and executes any necessary onEnter handlers.\\n   * Call this directly _after_ setting the current state to the next state.\\n   */\\n  enter(levels) {\\n    const enterPatterns = patterns(\\n      this.currentState,\\n      _nullishCoalesce(levels, () => ( this.currentState.split(\\\".\\\").length + 1))\\n    );\\n    this.currentContext.allowPatching((patchableContext) => {\\n      for (const pattern of enterPatterns) {\\n        const enterFn = this.enterFns.get(pattern);\\n        const cleanupFn = _optionalChain([enterFn, 'optionalCall', _12 => _12(patchableContext)]);\\n        if (typeof cleanupFn === \\\"function\\\") {\\n          this.cleanupStack.push(cleanupFn);\\n        } else {\\n          this.cleanupStack.push(null);\\n        }\\n      }\\n    });\\n    this.eventHub.didEnterState.notify(this.currentState);\\n  }\\n  /**\\n   * Sends an event to the machine, which may cause an internal state\\n   * transition to happen. When that happens, will trigger side effects.\\n   */\\n  send(event) {\\n    if (!this.knownEventTypes.has(event.type)) {\\n      throw new Error(`Invalid event ${JSON.stringify(event.type)}`);\\n    }\\n    if (this.runningState === 2 /* STOPPED */) {\\n      return;\\n    }\\n    const targetFn = this.getTargetFn(event.type);\\n    if (targetFn !== void 0) {\\n      return this.transition(event, targetFn);\\n    } else {\\n      this.eventHub.didIgnoreEvent.notify(event);\\n    }\\n  }\\n  transition(event, target) {\\n    this.eventHub.didReceiveEvent.notify(event);\\n    const oldState = this.currentState;\\n    const targetFn = typeof target === \\\"function\\\" ? target : () => target;\\n    const nextTarget = targetFn(event, this.currentContext.current);\\n    let nextState;\\n    let effects = void 0;\\n    if (nextTarget === null) {\\n      this.eventHub.didIgnoreEvent.notify(event);\\n      return;\\n    }\\n    if (typeof nextTarget === \\\"string\\\") {\\n      nextState = nextTarget;\\n    } else {\\n      nextState = nextTarget.target;\\n      effects = Array.isArray(nextTarget.effect) ? nextTarget.effect : [nextTarget.effect];\\n    }\\n    if (!this.states.has(nextState)) {\\n      throw new Error(`Invalid next state name: ${JSON.stringify(nextState)}`);\\n    }\\n    this.eventHub.willTransition.notify({ from: oldState, to: nextState });\\n    const [up, down] = distance(this.currentState, nextState);\\n    if (up > 0) {\\n      this.exit(up);\\n    }\\n    this.currentStateOrNull = nextState;\\n    if (effects !== void 0) {\\n      const effectsToRun = effects;\\n      this.currentContext.allowPatching((patchableContext) => {\\n        for (const effect of effectsToRun) {\\n          if (typeof effect === \\\"function\\\") {\\n            effect(patchableContext, event);\\n          } else {\\n            patchableContext.patch(effect);\\n          }\\n        }\\n      });\\n    }\\n    if (down > 0) {\\n      this.enter(down);\\n    }\\n  }\\n};\\n\\n// src/lib/utils.ts\\nfunction raise(msg) {\\n  throw new Error(msg);\\n}\\nfunction isPlainObject(blob) {\\n  return blob !== null && typeof blob === \\\"object\\\" && Object.prototype.toString.call(blob) === \\\"[object Object]\\\";\\n}\\nfunction entries(obj) {\\n  return Object.entries(obj);\\n}\\nfunction mapValues(obj, mapFn) {\\n  const result = {};\\n  for (const pair of Object.entries(obj)) {\\n    const key = pair[0];\\n    if (key === \\\"__proto__\\\") {\\n      continue;\\n    }\\n    const value = pair[1];\\n    result[key] = mapFn(value, key);\\n  }\\n  return result;\\n}\\nfunction tryParseJson(rawMessage) {\\n  try {\\n    return JSON.parse(rawMessage);\\n  } catch (e) {\\n    return void 0;\\n  }\\n}\\nfunction deepClone(value) {\\n  return JSON.parse(JSON.stringify(value));\\n}\\nfunction b64decode(b64value) {\\n  try {\\n    const formattedValue = b64value.replace(/-/g, \\\"+\\\").replace(/_/g, \\\"/\\\");\\n    const decodedValue = decodeURIComponent(\\n      atob(formattedValue).split(\\\"\\\").map(function(c) {\\n        return \\\"%\\\" + (\\\"00\\\" + c.charCodeAt(0).toString(16)).slice(-2);\\n      }).join(\\\"\\\")\\n    );\\n    return decodedValue;\\n  } catch (err) {\\n    return atob(b64value);\\n  }\\n}\\nfunction compact(items) {\\n  return items.filter(\\n    (item) => item !== null && item !== void 0\\n  );\\n}\\nfunction compactObject(obj) {\\n  const newObj = { ...obj };\\n  Object.keys(obj).forEach((k) => {\\n    const key = k;\\n    if (newObj[key] === void 0) {\\n      delete newObj[key];\\n    }\\n  });\\n  return newObj;\\n}\\nfunction wait(millis) {\\n  return new Promise((res) => setTimeout(res, millis));\\n}\\nasync function withTimeout(promise, millis, errmsg) {\\n  let timerID;\\n  const timer$ = new Promise((_, reject) => {\\n    timerID = setTimeout(() => {\\n      reject(new Error(errmsg));\\n    }, millis);\\n  });\\n  return Promise.race([promise, timer$]).finally(() => clearTimeout(timerID));\\n}\\nfunction memoizeOnSuccess(factoryFn) {\\n  let cached = null;\\n  return () => {\\n    if (cached === null) {\\n      cached = factoryFn().catch((err) => {\\n        setTimeout(() => {\\n          cached = null;\\n        }, 5e3);\\n        throw err;\\n      });\\n    }\\n    return cached;\\n  };\\n}\\n\\n// src/protocol/ServerMsg.ts\\nvar ServerMsgCode = /* @__PURE__ */ ((ServerMsgCode2) => {\\n  ServerMsgCode2[ServerMsgCode2[\\\"UPDATE_PRESENCE\\\"] = 100] = \\\"UPDATE_PRESENCE\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"USER_JOINED\\\"] = 101] = \\\"USER_JOINED\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"USER_LEFT\\\"] = 102] = \\\"USER_LEFT\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"BROADCASTED_EVENT\\\"] = 103] = \\\"BROADCASTED_EVENT\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"ROOM_STATE\\\"] = 104] = \\\"ROOM_STATE\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"INITIAL_STORAGE_STATE\\\"] = 200] = \\\"INITIAL_STORAGE_STATE\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"UPDATE_STORAGE\\\"] = 201] = \\\"UPDATE_STORAGE\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"REJECT_STORAGE_OP\\\"] = 299] = \\\"REJECT_STORAGE_OP\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"UPDATE_YDOC\\\"] = 300] = \\\"UPDATE_YDOC\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"THREAD_CREATED\\\"] = 400] = \\\"THREAD_CREATED\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"THREAD_DELETED\\\"] = 407] = \\\"THREAD_DELETED\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"THREAD_METADATA_UPDATED\\\"] = 401] = \\\"THREAD_METADATA_UPDATED\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"THREAD_UPDATED\\\"] = 408] = \\\"THREAD_UPDATED\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"COMMENT_CREATED\\\"] = 402] = \\\"COMMENT_CREATED\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"COMMENT_EDITED\\\"] = 403] = \\\"COMMENT_EDITED\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"COMMENT_DELETED\\\"] = 404] = \\\"COMMENT_DELETED\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"COMMENT_REACTION_ADDED\\\"] = 405] = \\\"COMMENT_REACTION_ADDED\\\";\\n  ServerMsgCode2[ServerMsgCode2[\\\"COMMENT_REACTION_REMOVED\\\"] = 406] = \\\"COMMENT_REACTION_REMOVED\\\";\\n  return ServerMsgCode2;\\n})(ServerMsgCode || {});\\n\\n// src/types/IWebSocket.ts\\nvar WebsocketCloseCodes = /* @__PURE__ */ ((WebsocketCloseCodes2) => {\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"CLOSE_NORMAL\\\"] = 1e3] = \\\"CLOSE_NORMAL\\\";\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"CLOSE_ABNORMAL\\\"] = 1006] = \\\"CLOSE_ABNORMAL\\\";\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"UNEXPECTED_CONDITION\\\"] = 1011] = \\\"UNEXPECTED_CONDITION\\\";\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"TRY_AGAIN_LATER\\\"] = 1013] = \\\"TRY_AGAIN_LATER\\\";\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"INVALID_MESSAGE_FORMAT\\\"] = 4e3] = \\\"INVALID_MESSAGE_FORMAT\\\";\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"NOT_ALLOWED\\\"] = 4001] = \\\"NOT_ALLOWED\\\";\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\\\"] = 4002] = \\\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\\\";\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\\\"] = 4003] = \\\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\\\";\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\\\"] = 4004] = \\\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\\\";\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\\\"] = 4005] = \\\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\\\";\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"ROOM_ID_UPDATED\\\"] = 4006] = \\\"ROOM_ID_UPDATED\\\";\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"KICKED\\\"] = 4100] = \\\"KICKED\\\";\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"TOKEN_EXPIRED\\\"] = 4109] = \\\"TOKEN_EXPIRED\\\";\\n  WebsocketCloseCodes2[WebsocketCloseCodes2[\\\"CLOSE_WITHOUT_RETRY\\\"] = 4999] = \\\"CLOSE_WITHOUT_RETRY\\\";\\n  return WebsocketCloseCodes2;\\n})(WebsocketCloseCodes || {});\\nfunction shouldDisconnect(code) {\\n  return code === 4999 /* CLOSE_WITHOUT_RETRY */ || code >= 4e3 && code < 4100;\\n}\\nfunction shouldReauth(code) {\\n  return code >= 4100 && code < 4200;\\n}\\nfunction shouldRetryWithoutReauth(code) {\\n  return code === 1013 /* TRY_AGAIN_LATER */ || code >= 4200 && code < 4300;\\n}\\n\\n// src/connection.ts\\nfunction isIdle(status) {\\n  return status === \\\"initial\\\" || status === \\\"disconnected\\\";\\n}\\nfunction toNewConnectionStatus(machine) {\\n  const state = machine.currentState;\\n  switch (state) {\\n    case \\\"@ok.connected\\\":\\n    case \\\"@ok.awaiting-pong\\\":\\n      return \\\"connected\\\";\\n    case \\\"@idle.initial\\\":\\n      return \\\"initial\\\";\\n    case \\\"@auth.busy\\\":\\n    case \\\"@auth.backoff\\\":\\n    case \\\"@connecting.busy\\\":\\n    case \\\"@connecting.backoff\\\":\\n    case \\\"@idle.zombie\\\":\\n      return machine.context.successCount > 0 ? \\\"reconnecting\\\" : \\\"connecting\\\";\\n    case \\\"@idle.failed\\\":\\n      return \\\"disconnected\\\";\\n    default:\\n      return assertNever(state, \\\"Unknown state\\\");\\n  }\\n}\\nvar BACKOFF_DELAYS = [250, 500, 1e3, 2e3, 4e3, 8e3, 1e4];\\nvar RESET_DELAY = BACKOFF_DELAYS[0] - 1;\\nvar BACKOFF_DELAYS_SLOW = [2e3, 3e4, 6e4, 3e5];\\nvar HEARTBEAT_INTERVAL = 3e4;\\nvar PONG_TIMEOUT = 2e3;\\nvar AUTH_TIMEOUT = 1e4;\\nvar SOCKET_CONNECT_TIMEOUT = 1e4;\\nvar StopRetrying = class extends Error {\\n  constructor(reason) {\\n    super(reason);\\n  }\\n};\\nvar LiveblocksError = class extends Error {\\n  /** @internal */\\n  constructor(message, code) {\\n    super(message);\\n    this.code = code;\\n  }\\n};\\nfunction nextBackoffDelay(currentDelay, delays) {\\n  return _nullishCoalesce(delays.find((delay) => delay > currentDelay), () => ( delays[delays.length - 1]));\\n}\\nfunction increaseBackoffDelay(context) {\\n  context.patch({\\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS)\\n  });\\n}\\nfunction increaseBackoffDelayAggressively(context) {\\n  context.patch({\\n    backoffDelay: nextBackoffDelay(context.backoffDelay, BACKOFF_DELAYS_SLOW)\\n  });\\n}\\nfunction resetSuccessCount(context) {\\n  context.patch({ successCount: 0 });\\n}\\nfunction log(level, message) {\\n  const logger = level === 2 /* ERROR */ ? error2 : level === 1 /* WARN */ ? warn : (\\n    /* black hole */\\n    () => {\\n    }\\n  );\\n  return () => {\\n    logger(message);\\n  };\\n}\\nfunction logPrematureErrorOrCloseEvent(e) {\\n  const conn = \\\"Connection to Liveblocks websocket server\\\";\\n  return (ctx) => {\\n    if (e instanceof Error) {\\n      warn(`${conn} could not be established. ${String(e)}`);\\n    } else {\\n      warn(\\n        isCloseEvent(e) ? `${conn} closed prematurely (code: ${e.code}). Retrying in ${ctx.backoffDelay}ms.` : `${conn} could not be established.`\\n      );\\n    }\\n  };\\n}\\nfunction logCloseEvent(event) {\\n  const details = [`code: ${event.code}`];\\n  if (event.reason) {\\n    details.push(`reason: ${event.reason}`);\\n  }\\n  return (ctx) => {\\n    warn(\\n      `Connection to Liveblocks websocket server closed (${details.join(\\\", \\\")}). Retrying in ${ctx.backoffDelay}ms.`\\n    );\\n  };\\n}\\nvar logPermanentClose = log(\\n  1 /* WARN */,\\n  \\\"Connection to WebSocket closed permanently. Won't retry.\\\"\\n);\\nfunction isCloseEvent(error3) {\\n  return !(error3 instanceof Error) && error3.type === \\\"close\\\";\\n}\\nfunction enableTracing(machine) {\\n  const start = (/* @__PURE__ */ new Date()).getTime();\\n  function log2(...args) {\\n    warn(\\n      `${(((/* @__PURE__ */ new Date()).getTime() - start) / 1e3).toFixed(2)} [FSM #${machine.id}]`,\\n      ...args\\n    );\\n  }\\n  const unsubs = [\\n    machine.events.didReceiveEvent.subscribe((e) => log2(`Event ${e.type}`)),\\n    machine.events.willTransition.subscribe(\\n      ({ from, to }) => log2(\\\"Transitioning\\\", from, \\\"\\\\u2192\\\", to)\\n    ),\\n    machine.events.didIgnoreEvent.subscribe(\\n      (e) => log2(\\\"Ignored event\\\", e.type, e, \\\"(current state won't handle it)\\\")\\n    )\\n    // machine.events.willExitState.subscribe((s) => log(\\\"Exiting state\\\", s)),\\n    // machine.events.didEnterState.subscribe((s) => log(\\\"Entering state\\\", s)),\\n  ];\\n  return () => {\\n    for (const unsub of unsubs) {\\n      unsub();\\n    }\\n  };\\n}\\nfunction defineConnectivityEvents(machine) {\\n  const statusDidChange = makeEventSource();\\n  const didConnect = makeEventSource();\\n  const didDisconnect = makeEventSource();\\n  let lastStatus = null;\\n  const unsubscribe = machine.events.didEnterState.subscribe(() => {\\n    const currStatus = toNewConnectionStatus(machine);\\n    if (currStatus !== lastStatus) {\\n      statusDidChange.notify(currStatus);\\n    }\\n    if (lastStatus === \\\"connected\\\" && currStatus !== \\\"connected\\\") {\\n      didDisconnect.notify();\\n    } else if (lastStatus !== \\\"connected\\\" && currStatus === \\\"connected\\\") {\\n      didConnect.notify();\\n    }\\n    lastStatus = currStatus;\\n  });\\n  return {\\n    statusDidChange: statusDidChange.observable,\\n    didConnect: didConnect.observable,\\n    didDisconnect: didDisconnect.observable,\\n    unsubscribe\\n  };\\n}\\nvar assign = (patch) => (ctx) => ctx.patch(patch);\\nfunction createConnectionStateMachine(delegates, options) {\\n  const onMessage = makeEventSource();\\n  onMessage.pause();\\n  const onLiveblocksError = makeEventSource();\\n  function fireErrorEvent(errmsg, errcode) {\\n    return () => {\\n      const err = new LiveblocksError(errmsg, errcode);\\n      onLiveblocksError.notify(err);\\n    };\\n  }\\n  const initialContext = {\\n    successCount: 0,\\n    authValue: null,\\n    socket: null,\\n    backoffDelay: RESET_DELAY\\n  };\\n  const machine = new FSM(initialContext).addState(\\\"@idle.initial\\\").addState(\\\"@idle.failed\\\").addState(\\\"@idle.zombie\\\").addState(\\\"@auth.busy\\\").addState(\\\"@auth.backoff\\\").addState(\\\"@connecting.busy\\\").addState(\\\"@connecting.backoff\\\").addState(\\\"@ok.connected\\\").addState(\\\"@ok.awaiting-pong\\\");\\n  machine.addTransitions(\\\"*\\\", {\\n    RECONNECT: {\\n      target: \\\"@auth.backoff\\\",\\n      effect: [increaseBackoffDelay, resetSuccessCount]\\n    },\\n    DISCONNECT: \\\"@idle.initial\\\"\\n  });\\n  machine.onEnter(\\\"@idle.*\\\", resetSuccessCount).addTransitions(\\\"@idle.*\\\", {\\n    CONNECT: (_, ctx) => (\\n      // If we still have a known authValue, try to reconnect to the socket directly,\\n      // otherwise, try to obtain a new authValue\\n      ctx.authValue !== null ? \\\"@connecting.busy\\\" : \\\"@auth.busy\\\"\\n    )\\n  });\\n  machine.addTransitions(\\\"@auth.backoff\\\", {\\n    NAVIGATOR_ONLINE: {\\n      target: \\\"@auth.busy\\\",\\n      effect: assign({ backoffDelay: RESET_DELAY })\\n    }\\n  }).addTimedTransition(\\n    \\\"@auth.backoff\\\",\\n    (ctx) => ctx.backoffDelay,\\n    \\\"@auth.busy\\\"\\n  ).onEnterAsync(\\n    \\\"@auth.busy\\\",\\n    () => withTimeout(\\n      delegates.authenticate(),\\n      AUTH_TIMEOUT,\\n      \\\"Timed out during auth\\\"\\n    ),\\n    // On successful authentication\\n    (okEvent) => ({\\n      target: \\\"@connecting.busy\\\",\\n      effect: assign({\\n        authValue: okEvent.data\\n      })\\n    }),\\n    // Auth failed\\n    (failedEvent) => {\\n      if (failedEvent.reason instanceof StopRetrying) {\\n        return {\\n          target: \\\"@idle.failed\\\",\\n          effect: [\\n            log(2 /* ERROR */, failedEvent.reason.message),\\n            fireErrorEvent(failedEvent.reason.message, -1)\\n          ]\\n        };\\n      }\\n      return {\\n        target: \\\"@auth.backoff\\\",\\n        effect: [\\n          increaseBackoffDelay,\\n          log(\\n            2 /* ERROR */,\\n            `Authentication failed: ${failedEvent.reason instanceof Error ? failedEvent.reason.message : String(failedEvent.reason)}`\\n          )\\n        ]\\n      };\\n    }\\n  );\\n  const onSocketError = (event) => machine.send({ type: \\\"EXPLICIT_SOCKET_ERROR\\\", event });\\n  const onSocketClose = (event) => machine.send({ type: \\\"EXPLICIT_SOCKET_CLOSE\\\", event });\\n  const onSocketMessage = (event) => event.data === \\\"pong\\\" ? machine.send({ type: \\\"PONG\\\" }) : onMessage.notify(event);\\n  function teardownSocket(socket) {\\n    if (socket) {\\n      socket.removeEventListener(\\\"error\\\", onSocketError);\\n      socket.removeEventListener(\\\"close\\\", onSocketClose);\\n      socket.removeEventListener(\\\"message\\\", onSocketMessage);\\n      socket.close();\\n    }\\n  }\\n  machine.addTransitions(\\\"@connecting.backoff\\\", {\\n    NAVIGATOR_ONLINE: {\\n      target: \\\"@connecting.busy\\\",\\n      effect: assign({ backoffDelay: RESET_DELAY })\\n    }\\n  }).addTimedTransition(\\n    \\\"@connecting.backoff\\\",\\n    (ctx) => ctx.backoffDelay,\\n    \\\"@connecting.busy\\\"\\n  ).onEnterAsync(\\n    \\\"@connecting.busy\\\",\\n    //\\n    // Use the \\\"createSocket\\\" delegate function (provided to the\\n    // ManagedSocket) to create the actual WebSocket connection instance.\\n    // Then, set up all the necessary event listeners, and wait for the\\n    // \\\"open\\\" event to occur.\\n    //\\n    // When the \\\"open\\\" event happens, we're ready to transition to the\\n    // OK state. This is done by resolving the Promise.\\n    //\\n    async (ctx, signal) => {\\n      let capturedPrematureEvent = null;\\n      let unconfirmedSocket = null;\\n      const connect$ = new Promise(\\n        (resolve, rej) => {\\n          if (ctx.authValue === null) {\\n            throw new Error(\\\"No auth authValue\\\");\\n          }\\n          const socket = delegates.createSocket(ctx.authValue);\\n          unconfirmedSocket = socket;\\n          function reject(event) {\\n            capturedPrematureEvent = event;\\n            socket.removeEventListener(\\\"message\\\", onSocketMessage);\\n            rej(event);\\n          }\\n          const [actor$, didReceiveActor] = controlledPromise();\\n          if (!options.waitForActorId) {\\n            didReceiveActor();\\n          }\\n          function waitForActorId(event) {\\n            const serverMsg = tryParseJson(event.data);\\n            if (_optionalChain([serverMsg, 'optionalAccess', _13 => _13.type]) === 104 /* ROOM_STATE */) {\\n              didReceiveActor();\\n            }\\n          }\\n          socket.addEventListener(\\\"message\\\", onSocketMessage);\\n          if (options.waitForActorId) {\\n            socket.addEventListener(\\\"message\\\", waitForActorId);\\n          }\\n          socket.addEventListener(\\\"error\\\", reject);\\n          socket.addEventListener(\\\"close\\\", reject);\\n          socket.addEventListener(\\\"open\\\", () => {\\n            socket.addEventListener(\\\"error\\\", onSocketError);\\n            socket.addEventListener(\\\"close\\\", onSocketClose);\\n            const unsub = () => {\\n              socket.removeEventListener(\\\"error\\\", reject);\\n              socket.removeEventListener(\\\"close\\\", reject);\\n              socket.removeEventListener(\\\"message\\\", waitForActorId);\\n            };\\n            void actor$.then(() => {\\n              resolve([socket, unsub]);\\n            });\\n          });\\n        }\\n      );\\n      return withTimeout(\\n        connect$,\\n        SOCKET_CONNECT_TIMEOUT,\\n        \\\"Timed out during websocket connection\\\"\\n      ).then(\\n        //\\n        // Part 3:\\n        // By now, our \\\"open\\\" event has fired, and the promise has been\\n        // resolved. Two possible scenarios:\\n        //\\n        // 1. The happy path. Most likely.\\n        // 2. Uh-oh. A premature close/error event has been observed. Let's\\n        //    reject the promise after all.\\n        //\\n        // Any close/error event that will get scheduled after this point\\n        // onwards, will be caught in the OK state, and dealt with\\n        // accordingly.\\n        //\\n        ([socket, unsub]) => {\\n          unsub();\\n          if (signal.aborted) {\\n            throw new Error(\\\"Aborted\\\");\\n          }\\n          if (capturedPrematureEvent) {\\n            throw capturedPrematureEvent;\\n          }\\n          return socket;\\n        }\\n      ).catch((e) => {\\n        teardownSocket(unconfirmedSocket);\\n        throw e;\\n      });\\n    },\\n    // Only transition to OK state after a successfully opened WebSocket connection\\n    (okEvent) => ({\\n      target: \\\"@ok.connected\\\",\\n      effect: assign({\\n        socket: okEvent.data,\\n        backoffDelay: RESET_DELAY\\n      })\\n    }),\\n    // If the WebSocket connection cannot be established\\n    (failure) => {\\n      const err = failure.reason;\\n      if (err instanceof StopRetrying) {\\n        return {\\n          target: \\\"@idle.failed\\\",\\n          effect: [\\n            log(2 /* ERROR */, err.message),\\n            fireErrorEvent(err.message, -1)\\n          ]\\n        };\\n      }\\n      if (isCloseEvent(err)) {\\n        if (err.code === 4109 /* TOKEN_EXPIRED */) {\\n          return \\\"@auth.busy\\\";\\n        }\\n        if (shouldRetryWithoutReauth(err.code)) {\\n          return {\\n            target: \\\"@connecting.backoff\\\",\\n            effect: [\\n              increaseBackoffDelayAggressively,\\n              logPrematureErrorOrCloseEvent(err)\\n            ]\\n          };\\n        }\\n        if (shouldDisconnect(err.code)) {\\n          return {\\n            target: \\\"@idle.failed\\\",\\n            effect: [\\n              log(2 /* ERROR */, err.reason),\\n              fireErrorEvent(err.reason, err.code)\\n            ]\\n          };\\n        }\\n      }\\n      return {\\n        target: \\\"@auth.backoff\\\",\\n        effect: [increaseBackoffDelay, logPrematureErrorOrCloseEvent(err)]\\n      };\\n    }\\n  );\\n  const sendHeartbeat = {\\n    target: \\\"@ok.awaiting-pong\\\",\\n    effect: (ctx) => {\\n      _optionalChain([ctx, 'access', _14 => _14.socket, 'optionalAccess', _15 => _15.send, 'call', _16 => _16(\\\"ping\\\")]);\\n    }\\n  };\\n  const maybeHeartbeat = () => {\\n    const doc = typeof document !== \\\"undefined\\\" ? document : void 0;\\n    const canZombie = _optionalChain([doc, 'optionalAccess', _17 => _17.visibilityState]) === \\\"hidden\\\" && delegates.canZombie();\\n    return canZombie ? \\\"@idle.zombie\\\" : sendHeartbeat;\\n  };\\n  machine.addTimedTransition(\\\"@ok.connected\\\", HEARTBEAT_INTERVAL, maybeHeartbeat).addTransitions(\\\"@ok.connected\\\", {\\n    NAVIGATOR_OFFLINE: maybeHeartbeat,\\n    // Don't take the browser's word for it when it says it's offline. Do a ping/pong to make sure.\\n    WINDOW_GOT_FOCUS: sendHeartbeat\\n  });\\n  machine.addTransitions(\\\"@idle.zombie\\\", {\\n    WINDOW_GOT_FOCUS: \\\"@connecting.backoff\\\"\\n    // When in zombie state, the client will try to wake up automatically when the window regains focus\\n  });\\n  machine.onEnter(\\\"@ok.*\\\", (ctx) => {\\n    ctx.patch({ successCount: ctx.successCount + 1 });\\n    const timerID = setTimeout(\\n      // On the next tick, start delivering all messages that have already\\n      // been received, and continue synchronous delivery of all future\\n      // incoming messages.\\n      onMessage.unpause,\\n      0\\n    );\\n    return (ctx2) => {\\n      teardownSocket(ctx2.socket);\\n      ctx2.patch({ socket: null });\\n      clearTimeout(timerID);\\n      onMessage.pause();\\n    };\\n  }).addTransitions(\\\"@ok.awaiting-pong\\\", { PONG: \\\"@ok.connected\\\" }).addTimedTransition(\\\"@ok.awaiting-pong\\\", PONG_TIMEOUT, {\\n    target: \\\"@connecting.busy\\\",\\n    // Log implicit connection loss and drop the current open socket\\n    effect: log(\\n      1 /* WARN */,\\n      \\\"Received no pong from server, assume implicit connection loss.\\\"\\n    )\\n  }).addTransitions(\\\"@ok.*\\\", {\\n    // When a socket receives an error, this can cause the closing of the\\n    // socket, or not. So always check to see if the socket is still OPEN or\\n    // not. When still OPEN, don't transition.\\n    EXPLICIT_SOCKET_ERROR: (_, context) => {\\n      if (_optionalChain([context, 'access', _18 => _18.socket, 'optionalAccess', _19 => _19.readyState]) === 1) {\\n        return null;\\n      }\\n      return {\\n        target: \\\"@connecting.backoff\\\",\\n        effect: increaseBackoffDelay\\n      };\\n    },\\n    EXPLICIT_SOCKET_CLOSE: (e) => {\\n      if (shouldDisconnect(e.event.code)) {\\n        return {\\n          target: \\\"@idle.failed\\\",\\n          effect: [\\n            logPermanentClose,\\n            fireErrorEvent(e.event.reason, e.event.code)\\n          ]\\n        };\\n      }\\n      if (shouldReauth(e.event.code)) {\\n        if (e.event.code === 4109 /* TOKEN_EXPIRED */) {\\n          return \\\"@auth.busy\\\";\\n        } else {\\n          return {\\n            target: \\\"@auth.backoff\\\",\\n            effect: [increaseBackoffDelay, logCloseEvent(e.event)]\\n          };\\n        }\\n      }\\n      if (shouldRetryWithoutReauth(e.event.code)) {\\n        return {\\n          target: \\\"@connecting.backoff\\\",\\n          effect: [increaseBackoffDelayAggressively, logCloseEvent(e.event)]\\n        };\\n      }\\n      return {\\n        target: \\\"@connecting.backoff\\\",\\n        effect: [increaseBackoffDelay, logCloseEvent(e.event)]\\n      };\\n    }\\n  });\\n  if (typeof document !== \\\"undefined\\\") {\\n    const doc = typeof document !== \\\"undefined\\\" ? document : void 0;\\n    const win = typeof window !== \\\"undefined\\\" ? window : void 0;\\n    const root = _nullishCoalesce(win, () => ( doc));\\n    machine.onEnter(\\\"*\\\", (ctx) => {\\n      function onNetworkOffline() {\\n        machine.send({ type: \\\"NAVIGATOR_OFFLINE\\\" });\\n      }\\n      function onNetworkBackOnline() {\\n        machine.send({ type: \\\"NAVIGATOR_ONLINE\\\" });\\n      }\\n      function onVisibilityChange() {\\n        if (_optionalChain([doc, 'optionalAccess', _20 => _20.visibilityState]) === \\\"visible\\\") {\\n          machine.send({ type: \\\"WINDOW_GOT_FOCUS\\\" });\\n        }\\n      }\\n      _optionalChain([win, 'optionalAccess', _21 => _21.addEventListener, 'call', _22 => _22(\\\"online\\\", onNetworkBackOnline)]);\\n      _optionalChain([win, 'optionalAccess', _23 => _23.addEventListener, 'call', _24 => _24(\\\"offline\\\", onNetworkOffline)]);\\n      _optionalChain([root, 'optionalAccess', _25 => _25.addEventListener, 'call', _26 => _26(\\\"visibilitychange\\\", onVisibilityChange)]);\\n      return () => {\\n        _optionalChain([root, 'optionalAccess', _27 => _27.removeEventListener, 'call', _28 => _28(\\\"visibilitychange\\\", onVisibilityChange)]);\\n        _optionalChain([win, 'optionalAccess', _29 => _29.removeEventListener, 'call', _30 => _30(\\\"online\\\", onNetworkBackOnline)]);\\n        _optionalChain([win, 'optionalAccess', _31 => _31.removeEventListener, 'call', _32 => _32(\\\"offline\\\", onNetworkOffline)]);\\n        teardownSocket(ctx.socket);\\n      };\\n    });\\n  }\\n  const cleanups = [];\\n  const { statusDidChange, didConnect, didDisconnect, unsubscribe } = defineConnectivityEvents(machine);\\n  cleanups.push(unsubscribe);\\n  if (options.enableDebugLogging) {\\n    cleanups.push(enableTracing(machine));\\n  }\\n  machine.start();\\n  return {\\n    machine,\\n    cleanups,\\n    // Observable events that will be emitted by this machine\\n    events: {\\n      statusDidChange,\\n      didConnect,\\n      didDisconnect,\\n      onMessage: onMessage.observable,\\n      onLiveblocksError: onLiveblocksError.observable\\n    }\\n  };\\n}\\nvar ManagedSocket = class {\\n  constructor(delegates, enableDebugLogging = false, waitForActorId = true) {\\n    const { machine, events, cleanups } = createConnectionStateMachine(\\n      delegates,\\n      { waitForActorId, enableDebugLogging }\\n    );\\n    this.machine = machine;\\n    this.events = events;\\n    this.cleanups = cleanups;\\n  }\\n  getStatus() {\\n    try {\\n      return toNewConnectionStatus(this.machine);\\n    } catch (e2) {\\n      return \\\"initial\\\";\\n    }\\n  }\\n  /**\\n   * Returns the current auth authValue.\\n   */\\n  get authValue() {\\n    return this.machine.context.authValue;\\n  }\\n  /**\\n   * Call this method to try to connect to a WebSocket. This only has an effect\\n   * if the machine is idle at the moment, otherwise this is a no-op.\\n   */\\n  connect() {\\n    this.machine.send({ type: \\\"CONNECT\\\" });\\n  }\\n  /**\\n   * If idle, will try to connect. Otherwise, it will attempt to reconnect to\\n   * the socket, potentially obtaining a new authValue first, if needed.\\n   */\\n  reconnect() {\\n    this.machine.send({ type: \\\"RECONNECT\\\" });\\n  }\\n  /**\\n   * Call this method to disconnect from the current WebSocket. Is going to be\\n   * a no-op if there is no active connection.\\n   */\\n  disconnect() {\\n    this.machine.send({ type: \\\"DISCONNECT\\\" });\\n  }\\n  /**\\n   * Call this to stop the machine and run necessary cleanup functions. After\\n   * calling destroy(), you can no longer use this instance. Call this before\\n   * letting the instance get garbage collected.\\n   */\\n  destroy() {\\n    this.machine.stop();\\n    let cleanup;\\n    while (cleanup = this.cleanups.pop()) {\\n      cleanup();\\n    }\\n  }\\n  /**\\n   * Safely send a message to the current WebSocket connection. Will emit a log\\n   * message if this is somehow impossible.\\n   */\\n  send(data) {\\n    const socket = _optionalChain([this, 'access', _33 => _33.machine, 'access', _34 => _34.context, 'optionalAccess', _35 => _35.socket]);\\n    if (socket === null) {\\n      warn(\\\"Cannot send: not connected yet\\\", data);\\n    } else if (socket.readyState !== 1) {\\n      warn(\\\"Cannot send: WebSocket no longer open\\\", data);\\n    } else {\\n      socket.send(data);\\n    }\\n  }\\n  /**\\n   * NOTE: Used by the E2E app only, to simulate explicit events.\\n   * Not ideal to keep exposed :(\\n   */\\n  _privateSendMachineEvent(event) {\\n    this.machine.send(event);\\n  }\\n};\\n\\n// src/protocol/AuthToken.ts\\nfunction canWriteStorage(scopes) {\\n  return scopes.includes(\\\"room:write\\\" /* Write */);\\n}\\nfunction canComment(scopes) {\\n  return scopes.includes(\\\"comments:write\\\" /* CommentsWrite */) || scopes.includes(\\\"room:write\\\" /* Write */);\\n}\\nfunction isValidAuthTokenPayload(data) {\\n  return isPlainObject(data) && (data.k === \\\"acc\\\" /* ACCESS_TOKEN */ || data.k === \\\"id\\\" /* ID_TOKEN */ || data.k === \\\"sec-legacy\\\" /* SECRET_LEGACY */);\\n}\\nfunction parseAuthToken(rawTokenString) {\\n  const tokenParts = rawTokenString.split(\\\".\\\");\\n  if (tokenParts.length !== 3) {\\n    throw new Error(\\\"Authentication error: invalid JWT token\\\");\\n  }\\n  const payload = tryParseJson(b64decode(tokenParts[1]));\\n  if (!(payload && isValidAuthTokenPayload(payload))) {\\n    throw new Error(\\n      \\\"Authentication error: expected a valid token but did not get one. Hint: if you are using a callback, ensure the room is passed when creating the token. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientCallback\\\"\\n    );\\n  }\\n  return {\\n    raw: rawTokenString,\\n    parsed: payload\\n  };\\n}\\n\\n// src/auth-manager.ts\\nfunction createAuthManager(authOptions) {\\n  const authentication = prepareAuthentication(authOptions);\\n  const seenTokens = /* @__PURE__ */ new Set();\\n  const tokens = [];\\n  const expiryTimes = [];\\n  const requestPromises = /* @__PURE__ */ new Map();\\n  function reset() {\\n    seenTokens.clear();\\n    tokens.length = 0;\\n    expiryTimes.length = 0;\\n    requestPromises.clear();\\n  }\\n  function hasCorrespondingScopes(requestedScope, scopes) {\\n    if (requestedScope === \\\"comments:read\\\") {\\n      return scopes.includes(\\\"comments:read\\\" /* CommentsRead */) || scopes.includes(\\\"comments:write\\\" /* CommentsWrite */) || scopes.includes(\\\"room:read\\\" /* Read */) || scopes.includes(\\\"room:write\\\" /* Write */);\\n    } else if (requestedScope === \\\"room:read\\\") {\\n      return scopes.includes(\\\"room:read\\\" /* Read */) || scopes.includes(\\\"room:write\\\" /* Write */);\\n    }\\n    return false;\\n  }\\n  function getCachedToken(requestOptions) {\\n    const now = Math.ceil(Date.now() / 1e3);\\n    for (let i = tokens.length - 1; i >= 0; i--) {\\n      const token = tokens[i];\\n      const expiresAt = expiryTimes[i];\\n      if (expiresAt <= now) {\\n        tokens.splice(i, 1);\\n        expiryTimes.splice(i, 1);\\n        continue;\\n      }\\n      if (token.parsed.k === \\\"id\\\" /* ID_TOKEN */) {\\n        return token;\\n      } else if (token.parsed.k === \\\"acc\\\" /* ACCESS_TOKEN */) {\\n        if (!requestOptions.roomId && Object.entries(token.parsed.perms).length === 0) {\\n          return token;\\n        }\\n        for (const [resource, scopes] of Object.entries(token.parsed.perms)) {\\n          if (!requestOptions.roomId) {\\n            if (resource.includes(\\\"*\\\") && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\\n              return token;\\n            }\\n          } else if (resource.includes(\\\"*\\\") && requestOptions.roomId.startsWith(resource.replace(\\\"*\\\", \\\"\\\")) || requestOptions.roomId === resource && hasCorrespondingScopes(requestOptions.requestedScope, scopes)) {\\n            return token;\\n          }\\n        }\\n      }\\n    }\\n    return void 0;\\n  }\\n  async function makeAuthRequest(options) {\\n    const fetcher = _nullishCoalesce(_optionalChain([authOptions, 'access', _36 => _36.polyfills, 'optionalAccess', _37 => _37.fetch]), () => ( (typeof window === \\\"undefined\\\" ? void 0 : window.fetch)));\\n    if (authentication.type === \\\"private\\\") {\\n      if (fetcher === void 0) {\\n        throw new StopRetrying(\\n          \\\"To use Liveblocks client in a non-DOM environment with a url as auth endpoint, you need to provide a fetch polyfill.\\\"\\n        );\\n      }\\n      const response = await fetchAuthEndpoint(fetcher, authentication.url, {\\n        room: options.roomId\\n      });\\n      const parsed = parseAuthToken(response.token);\\n      if (seenTokens.has(parsed.raw)) {\\n        throw new StopRetrying(\\n          \\\"The same Liveblocks auth token was issued from the backend before. Caching Liveblocks tokens is not supported.\\\"\\n        );\\n      }\\n      return parsed;\\n    }\\n    if (authentication.type === \\\"custom\\\") {\\n      const response = await authentication.callback(options.roomId);\\n      if (response && typeof response === \\\"object\\\") {\\n        if (typeof response.token === \\\"string\\\") {\\n          const parsed = parseAuthToken(response.token);\\n          return parsed;\\n        } else if (typeof response.error === \\\"string\\\") {\\n          const reason = `Authentication failed: ${\\\"reason\\\" in response && typeof response.reason === \\\"string\\\" ? response.reason : \\\"Forbidden\\\"}`;\\n          if (response.error === \\\"forbidden\\\") {\\n            throw new StopRetrying(reason);\\n          } else {\\n            throw new Error(reason);\\n          }\\n        }\\n      }\\n      throw new Error(\\n        'Your authentication callback function should return a token, but it did not. Hint: the return value should look like: { token: \\\"...\\\" }'\\n      );\\n    }\\n    throw new Error(\\n      \\\"Unexpected authentication type. Must be private or custom.\\\"\\n    );\\n  }\\n  async function getAuthValue(requestOptions) {\\n    if (authentication.type === \\\"public\\\") {\\n      return { type: \\\"public\\\", publicApiKey: authentication.publicApiKey };\\n    }\\n    const cachedToken = getCachedToken(requestOptions);\\n    if (cachedToken !== void 0) {\\n      return { type: \\\"secret\\\", token: cachedToken };\\n    }\\n    let currentPromise;\\n    if (requestOptions.roomId) {\\n      currentPromise = requestPromises.get(requestOptions.roomId);\\n      if (currentPromise === void 0) {\\n        currentPromise = makeAuthRequest(requestOptions);\\n        requestPromises.set(requestOptions.roomId, currentPromise);\\n      }\\n    } else {\\n      currentPromise = requestPromises.get(\\\"liveblocks-user-token\\\");\\n      if (currentPromise === void 0) {\\n        currentPromise = makeAuthRequest(requestOptions);\\n        requestPromises.set(\\\"liveblocks-user-token\\\", currentPromise);\\n      }\\n    }\\n    try {\\n      const token = await currentPromise;\\n      const BUFFER = 30;\\n      const expiresAt = Math.floor(Date.now() / 1e3) + (token.parsed.exp - token.parsed.iat) - BUFFER;\\n      seenTokens.add(token.raw);\\n      if (token.parsed.k !== \\\"sec-legacy\\\" /* SECRET_LEGACY */) {\\n        tokens.push(token);\\n        expiryTimes.push(expiresAt);\\n      }\\n      return { type: \\\"secret\\\", token };\\n    } finally {\\n      if (requestOptions.roomId) {\\n        requestPromises.delete(requestOptions.roomId);\\n      } else {\\n        requestPromises.delete(\\\"liveblocks-user-token\\\");\\n      }\\n    }\\n  }\\n  return {\\n    reset,\\n    getAuthValue\\n  };\\n}\\nfunction prepareAuthentication(authOptions) {\\n  const { publicApiKey, authEndpoint } = authOptions;\\n  if (authEndpoint !== void 0 && publicApiKey !== void 0) {\\n    throw new Error(\\n      \\\"You cannot simultaneously use `publicApiKey` and `authEndpoint` options. Please pick one and leave the other option unspecified. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\\\"\\n    );\\n  }\\n  if (typeof publicApiKey === \\\"string\\\") {\\n    if (publicApiKey.startsWith(\\\"sk_\\\")) {\\n      throw new Error(\\n        \\\"Invalid `publicApiKey` option. The value you passed is a secret key, which should not be used from the client. Please only ever pass a public key here. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\\\"\\n      );\\n    } else if (!publicApiKey.startsWith(\\\"pk_\\\")) {\\n      throw new Error(\\n        \\\"Invalid key. Please use the public key format: pk_<public key>. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientPublicKey\\\"\\n      );\\n    }\\n    return {\\n      type: \\\"public\\\",\\n      publicApiKey\\n    };\\n  }\\n  if (typeof authEndpoint === \\\"string\\\") {\\n    return {\\n      type: \\\"private\\\",\\n      url: authEndpoint\\n    };\\n  } else if (typeof authEndpoint === \\\"function\\\") {\\n    return {\\n      type: \\\"custom\\\",\\n      callback: authEndpoint\\n    };\\n  } else if (authEndpoint !== void 0) {\\n    throw new Error(\\n      \\\"The `authEndpoint` option must be a string or a function. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClientAuthEndpoint\\\"\\n    );\\n  }\\n  throw new Error(\\n    \\\"Invalid Liveblocks client options. Please provide either a `publicApiKey` or `authEndpoint` option. They cannot both be empty. For more information: https://liveblocks.io/docs/api-reference/liveblocks-client#createClient\\\"\\n  );\\n}\\nasync function fetchAuthEndpoint(fetch, endpoint, body) {\\n  const res = await fetch(endpoint, {\\n    method: \\\"POST\\\",\\n    headers: {\\n      \\\"Content-Type\\\": \\\"application/json\\\"\\n    },\\n    body: JSON.stringify(body)\\n  });\\n  if (!res.ok) {\\n    const reason = `${(await res.text()).trim() || \\\"reason not provided in auth response\\\"} (${res.status} returned by POST ${endpoint})`;\\n    if (res.status === 401 || res.status === 403) {\\n      throw new StopRetrying(`Unauthorized: ${reason}`);\\n    } else {\\n      throw new Error(`Failed to authenticate: ${reason}`);\\n    }\\n  }\\n  let data;\\n  try {\\n    data = await res.json();\\n  } catch (er) {\\n    throw new Error(\\n      `Expected a JSON response when doing a POST request on \\\"${endpoint}\\\". ${String(\\n        er\\n      )}`\\n    );\\n  }\\n  if (!isPlainObject(data) || typeof data.token !== \\\"string\\\") {\\n    throw new Error(\\n      `Expected a JSON response of the form \\\\`{ token: \\\"...\\\" }\\\\` when doing a POST request on \\\"${endpoint}\\\", but got ${JSON.stringify(\\n        data\\n      )}`\\n    );\\n  }\\n  const { token } = data;\\n  return { token };\\n}\\n\\n// src/constants.ts\\nvar DEFAULT_BASE_URL = \\\"https://api.liveblocks.io\\\";\\n\\n// src/internal.ts\\nvar kInternal = Symbol();\\n\\n// src/devtools/bridge.ts\\nvar _bridgeActive = false;\\nfunction activateBridge(allowed) {\\n  _bridgeActive = allowed;\\n}\\nfunction sendToPanel(message, options) {\\n  if (process.env.NODE_ENV === \\\"production\\\" || typeof window === \\\"undefined\\\") {\\n    return;\\n  }\\n  const fullMsg = {\\n    ...message,\\n    source: \\\"liveblocks-devtools-client\\\"\\n  };\\n  if (!(_optionalChain([options, 'optionalAccess', _38 => _38.force]) || _bridgeActive)) {\\n    return;\\n  }\\n  window.postMessage(fullMsg, \\\"*\\\");\\n}\\nvar eventSource = makeEventSource();\\nif (process.env.NODE_ENV !== \\\"production\\\" && typeof window !== \\\"undefined\\\") {\\n  window.addEventListener(\\\"message\\\", (event) => {\\n    if (event.source === window && _optionalChain([event, 'access', _39 => _39.data, 'optionalAccess', _40 => _40.source]) === \\\"liveblocks-devtools-panel\\\") {\\n      eventSource.notify(event.data);\\n    } else {\\n    }\\n  });\\n}\\nvar onMessageFromPanel = eventSource.observable;\\n\\n// src/devtools/index.ts\\nvar VERSION = PKG_VERSION || \\\"dev\\\";\\nvar _devtoolsSetupHasRun = false;\\nfunction setupDevTools(getAllRooms) {\\n  if (process.env.NODE_ENV === \\\"production\\\" || typeof window === \\\"undefined\\\") {\\n    return;\\n  }\\n  if (_devtoolsSetupHasRun) {\\n    return;\\n  }\\n  _devtoolsSetupHasRun = true;\\n  onMessageFromPanel.subscribe((msg) => {\\n    switch (msg.msg) {\\n      case \\\"connect\\\": {\\n        activateBridge(true);\\n        for (const roomId of getAllRooms()) {\\n          sendToPanel({\\n            msg: \\\"room::available\\\",\\n            roomId,\\n            clientVersion: VERSION\\n          });\\n        }\\n        break;\\n      }\\n    }\\n  });\\n  sendToPanel({ msg: \\\"wake-up-devtools\\\" }, { force: true });\\n}\\nvar unsubsByRoomId = /* @__PURE__ */ new Map();\\nfunction stopSyncStream(roomId) {\\n  const unsubs = _nullishCoalesce(unsubsByRoomId.get(roomId), () => ( []));\\n  unsubsByRoomId.delete(roomId);\\n  for (const unsub of unsubs) {\\n    unsub();\\n  }\\n}\\nfunction startSyncStream(room) {\\n  stopSyncStream(room.id);\\n  fullSync(room);\\n  unsubsByRoomId.set(room.id, [\\n    // When the connection status changes\\n    room.events.status.subscribe(() => partialSyncConnection(room)),\\n    // When storage initializes, send the update\\n    room.events.storageDidLoad.subscribeOnce(() => partialSyncStorage(room)),\\n    // Any time storage updates, send the new storage root\\n    room.events.storageBatch.subscribe(() => partialSyncStorage(room)),\\n    // Any time \\\"me\\\" or \\\"others\\\" updates, send the new values accordingly\\n    room.events.self.subscribe(() => partialSyncMe(room)),\\n    room.events.others.subscribe(() => partialSyncOthers(room)),\\n    // Any time ydoc is updated, forward the update\\n    room.events.ydoc.subscribe((update) => syncYdocUpdate(room, update)),\\n    // Any time a custom room event is received, forward it\\n    room.events.customEvent.subscribe(\\n      (eventData) => forwardEvent(room, eventData)\\n    )\\n  ]);\\n}\\nfunction syncYdocUpdate(room, update) {\\n  sendToPanel({\\n    msg: \\\"room::sync::ydoc\\\",\\n    roomId: room.id,\\n    update\\n  });\\n}\\nvar loadedAt = Date.now();\\nvar eventCounter = 0;\\nfunction nextEventId() {\\n  return `event-${loadedAt}-${eventCounter++}`;\\n}\\nfunction forwardEvent(room, eventData) {\\n  sendToPanel({\\n    msg: \\\"room::events::custom-event\\\",\\n    roomId: room.id,\\n    event: {\\n      type: \\\"CustomEvent\\\",\\n      id: nextEventId(),\\n      key: \\\"Event\\\",\\n      connectionId: eventData.connectionId,\\n      payload: eventData.event\\n    }\\n  });\\n}\\nfunction partialSyncConnection(room) {\\n  sendToPanel({\\n    msg: \\\"room::sync::partial\\\",\\n    roomId: room.id,\\n    status: room.getStatus()\\n  });\\n}\\nfunction partialSyncStorage(room) {\\n  const root = room.getStorageSnapshot();\\n  if (root) {\\n    sendToPanel({\\n      msg: \\\"room::sync::partial\\\",\\n      roomId: room.id,\\n      storage: root.toTreeNode(\\\"root\\\").payload\\n    });\\n  }\\n}\\nfunction partialSyncMe(room) {\\n  const me = room[kInternal].getSelf_forDevTools();\\n  if (me) {\\n    sendToPanel({\\n      msg: \\\"room::sync::partial\\\",\\n      roomId: room.id,\\n      me\\n    });\\n  }\\n}\\nfunction partialSyncOthers(room) {\\n  const others = room[kInternal].getOthers_forDevTools();\\n  if (others) {\\n    sendToPanel({\\n      msg: \\\"room::sync::partial\\\",\\n      roomId: room.id,\\n      others\\n    });\\n  }\\n}\\nfunction fullSync(room) {\\n  const root = room.getStorageSnapshot();\\n  const me = room[kInternal].getSelf_forDevTools();\\n  const others = room[kInternal].getOthers_forDevTools();\\n  room.fetchYDoc(\\\"\\\");\\n  sendToPanel({\\n    msg: \\\"room::sync::full\\\",\\n    roomId: room.id,\\n    status: room.getStatus(),\\n    storage: _nullishCoalesce(_optionalChain([root, 'optionalAccess', _41 => _41.toTreeNode, 'call', _42 => _42(\\\"root\\\"), 'access', _43 => _43.payload]), () => ( null)),\\n    me,\\n    others\\n  });\\n}\\nvar roomChannelListeners = /* @__PURE__ */ new Map();\\nfunction stopRoomChannelListener(roomId) {\\n  const listener = roomChannelListeners.get(roomId);\\n  roomChannelListeners.delete(roomId);\\n  if (listener) {\\n    listener();\\n  }\\n}\\nfunction linkDevTools(roomId, room) {\\n  if (process.env.NODE_ENV === \\\"production\\\" || typeof window === \\\"undefined\\\") {\\n    return;\\n  }\\n  sendToPanel({ msg: \\\"room::available\\\", roomId, clientVersion: VERSION });\\n  stopRoomChannelListener(roomId);\\n  roomChannelListeners.set(\\n    roomId,\\n    // Returns the unsubscribe callback, that we store in the\\n    // roomChannelListeners registry\\n    onMessageFromPanel.subscribe((msg) => {\\n      switch (msg.msg) {\\n        case \\\"room::subscribe\\\": {\\n          if (msg.roomId === roomId) {\\n            startSyncStream(room);\\n          }\\n          break;\\n        }\\n        case \\\"room::unsubscribe\\\": {\\n          if (msg.roomId === roomId) {\\n            stopSyncStream(roomId);\\n          }\\n          break;\\n        }\\n      }\\n    })\\n  );\\n}\\nfunction unlinkDevTools(roomId) {\\n  if (process.env.NODE_ENV === \\\"production\\\" || typeof window === \\\"undefined\\\") {\\n    return;\\n  }\\n  stopSyncStream(roomId);\\n  stopRoomChannelListener(roomId);\\n  sendToPanel({\\n    msg: \\\"room::unavailable\\\",\\n    roomId\\n  });\\n}\\n\\n// src/lib/stringify.ts\\nfunction stringify(object, ...args) {\\n  if (typeof object !== \\\"object\\\" || object === null || Array.isArray(object)) {\\n    return JSON.stringify(object, ...args);\\n  }\\n  const sortedObject = Object.keys(object).sort().reduce(\\n    (sortedObject2, key) => {\\n      sortedObject2[key] = object[key];\\n      return sortedObject2;\\n    },\\n    {}\\n  );\\n  return JSON.stringify(sortedObject, ...args);\\n}\\n\\n// src/lib/batch.ts\\nvar DEFAULT_SIZE = 50;\\nvar BatchCall = class {\\n  constructor(input) {\\n    this.input = input;\\n    const { promise, resolve, reject } = Promise_withResolvers();\\n    this.promise = promise;\\n    this.resolve = resolve;\\n    this.reject = reject;\\n  }\\n};\\nvar Batch = class {\\n  constructor(callback, options) {\\n    this.queue = [];\\n    this.error = false;\\n    this.callback = callback;\\n    this.size = _nullishCoalesce(options.size, () => ( DEFAULT_SIZE));\\n    this.delay = options.delay;\\n  }\\n  clearDelayTimeout() {\\n    if (this.delayTimeoutId !== void 0) {\\n      clearTimeout(this.delayTimeoutId);\\n      this.delayTimeoutId = void 0;\\n    }\\n  }\\n  schedule() {\\n    if (this.queue.length === this.size) {\\n      void this.flush();\\n    } else if (this.queue.length === 1) {\\n      this.clearDelayTimeout();\\n      this.delayTimeoutId = setTimeout(() => void this.flush(), this.delay);\\n    }\\n  }\\n  async flush() {\\n    if (this.queue.length === 0) {\\n      return;\\n    }\\n    const calls = this.queue.splice(0);\\n    const inputs = calls.map((call) => call.input);\\n    try {\\n      const results = await this.callback(inputs);\\n      this.error = false;\\n      calls.forEach((call, index) => {\\n        const result = _optionalChain([results, 'optionalAccess', _44 => _44[index]]);\\n        if (!Array.isArray(results)) {\\n          call.reject(new Error(\\\"Callback must return an array.\\\"));\\n        } else if (calls.length !== results.length) {\\n          call.reject(\\n            new Error(\\n              `Callback must return an array of the same length as the number of provided items. Expected ${calls.length}, but got ${results.length}.`\\n            )\\n          );\\n        } else if (result instanceof Error) {\\n          call.reject(result);\\n        } else {\\n          call.resolve(result);\\n        }\\n      });\\n    } catch (error3) {\\n      this.error = true;\\n      calls.forEach((call) => {\\n        call.reject(error3);\\n      });\\n    }\\n  }\\n  get(input) {\\n    const existingCall = this.queue.find(\\n      (call2) => stringify(call2.input) === stringify(input)\\n    );\\n    if (existingCall) {\\n      return existingCall.promise;\\n    }\\n    const call = new BatchCall(input);\\n    this.queue.push(call);\\n    this.schedule();\\n    return call.promise;\\n  }\\n  clear() {\\n    this.queue = [];\\n    this.error = false;\\n    this.clearDelayTimeout();\\n  }\\n};\\nfunction createBatchStore(batch) {\\n  const cache = /* @__PURE__ */ new Map();\\n  const eventSource2 = makeEventSource();\\n  function getCacheKey(args) {\\n    return stringify(args);\\n  }\\n  function setStateAndNotify(cacheKey, state) {\\n    cache.set(cacheKey, state);\\n    eventSource2.notify();\\n  }\\n  function invalidate(inputs) {\\n    if (Array.isArray(inputs)) {\\n      for (const input of inputs) {\\n        cache.delete(getCacheKey(input));\\n      }\\n    } else {\\n      cache.clear();\\n    }\\n    eventSource2.notify();\\n  }\\n  async function get(input) {\\n    const cacheKey = getCacheKey(input);\\n    if (cache.has(cacheKey)) {\\n      return;\\n    }\\n    try {\\n      setStateAndNotify(cacheKey, { isLoading: true });\\n      const result = await batch.get(input);\\n      setStateAndNotify(cacheKey, { isLoading: false, data: result });\\n    } catch (error3) {\\n      setStateAndNotify(cacheKey, {\\n        isLoading: false,\\n        error: error3\\n      });\\n    }\\n  }\\n  function getState(input) {\\n    const cacheKey = getCacheKey(input);\\n    return cache.get(cacheKey);\\n  }\\n  function _cacheKeys() {\\n    return [...cache.keys()];\\n  }\\n  return {\\n    ...eventSource2.observable,\\n    get,\\n    getState,\\n    invalidate,\\n    _cacheKeys\\n  };\\n}\\n\\n// src/lib/create-store.ts\\nfunction createStore(initialState) {\\n  let notifyImmediately = true;\\n  let dirty = false;\\n  let state = initialState;\\n  const subscribers = /* @__PURE__ */ new Set();\\n  function get() {\\n    return state;\\n  }\\n  function set(callback) {\\n    const oldState = state;\\n    const newState = callback(oldState);\\n    if (newState !== oldState) {\\n      state = newState;\\n      dirty = true;\\n    }\\n    if (notifyImmediately) {\\n      notify();\\n    }\\n  }\\n  function notify() {\\n    if (!dirty) {\\n      return;\\n    }\\n    dirty = false;\\n    for (const subscriber of subscribers) {\\n      subscriber(state);\\n    }\\n  }\\n  function batch(cb) {\\n    if (notifyImmediately === false) {\\n      return cb();\\n    }\\n    notifyImmediately = false;\\n    try {\\n      cb();\\n    } finally {\\n      notifyImmediately = true;\\n      notify();\\n    }\\n  }\\n  function subscribe(callback) {\\n    subscribers.add(callback);\\n    return () => {\\n      subscribers.delete(callback);\\n    };\\n  }\\n  return {\\n    get,\\n    set,\\n    batch,\\n    subscribe\\n  };\\n}\\n\\n// src/convert-plain-data.ts\\nfunction convertToCommentData(data) {\\n  const editedAt = data.editedAt ? new Date(data.editedAt) : void 0;\\n  const createdAt = new Date(data.createdAt);\\n  const reactions = data.reactions.map((reaction) => ({\\n    ...reaction,\\n    createdAt: new Date(reaction.createdAt)\\n  }));\\n  if (data.body) {\\n    return {\\n      ...data,\\n      reactions,\\n      createdAt,\\n      editedAt\\n    };\\n  } else {\\n    const deletedAt = new Date(data.deletedAt);\\n    return {\\n      ...data,\\n      reactions,\\n      createdAt,\\n      editedAt,\\n      deletedAt\\n    };\\n  }\\n}\\nfunction convertToThreadData(data) {\\n  const createdAt = new Date(data.createdAt);\\n  const updatedAt = new Date(data.updatedAt);\\n  const comments = data.comments.map(\\n    (comment) => convertToCommentData(comment)\\n  );\\n  return {\\n    ...data,\\n    createdAt,\\n    updatedAt,\\n    comments\\n  };\\n}\\nfunction convertToCommentUserReaction(data) {\\n  return {\\n    ...data,\\n    createdAt: new Date(data.createdAt)\\n  };\\n}\\nfunction convertToInboxNotificationData(data) {\\n  const notifiedAt = new Date(data.notifiedAt);\\n  const readAt = data.readAt ? new Date(data.readAt) : null;\\n  if (\\\"activities\\\" in data) {\\n    const activities = data.activities.map((activity) => ({\\n      ...activity,\\n      createdAt: new Date(activity.createdAt)\\n    }));\\n    return {\\n      ...data,\\n      notifiedAt,\\n      readAt,\\n      activities\\n    };\\n  }\\n  return {\\n    ...data,\\n    notifiedAt,\\n    readAt\\n  };\\n}\\nfunction convertToThreadDeleteInfo(data) {\\n  const deletedAt = new Date(data.deletedAt);\\n  return {\\n    ...data,\\n    deletedAt\\n  };\\n}\\nfunction convertToInboxNotificationDeleteInfo(data) {\\n  const deletedAt = new Date(data.deletedAt);\\n  return {\\n    ...data,\\n    deletedAt\\n  };\\n}\\n\\n// src/lib/autoRetry.ts\\nvar HttpError = class extends Error {\\n  constructor(message, status, details) {\\n    super(message);\\n    this.message = message;\\n    this.status = status;\\n    this.details = details;\\n  }\\n};\\nvar DONT_RETRY_4XX = (x) => x instanceof HttpError && x.status >= 400 && x.status < 500;\\nasync function autoRetry(promiseFn, maxTries, backoff, shouldStopRetrying = DONT_RETRY_4XX) {\\n  const fallbackBackoff = backoff.length > 0 ? backoff[backoff.length - 1] : 0;\\n  let attempt = 0;\\n  while (true) {\\n    attempt++;\\n    try {\\n      return await promiseFn();\\n    } catch (err) {\\n      if (shouldStopRetrying(err)) {\\n        throw err;\\n      }\\n      if (attempt >= maxTries) {\\n        throw new Error(`Failed after ${maxTries} attempts: ${String(err)}`);\\n      }\\n    }\\n    const delay = _nullishCoalesce(backoff[attempt - 1], () => ( fallbackBackoff));\\n    warn(\\n      `Attempt ${attempt} was unsuccessful. Retrying in ${delay} milliseconds.`\\n    );\\n    await wait(delay);\\n  }\\n}\\n\\n// src/lib/url.ts\\nfunction toURLSearchParams(params) {\\n  const result = new URLSearchParams();\\n  for (const [key, value] of Object.entries(params)) {\\n    if (value !== void 0 && value !== null) {\\n      result.set(key, value.toString());\\n    }\\n  }\\n  return result;\\n}\\nfunction urljoin(baseUrl, path, params) {\\n  const url2 = new URL(path, baseUrl);\\n  if (params !== void 0) {\\n    url2.search = (params instanceof URLSearchParams ? params : toURLSearchParams(params)).toString();\\n  }\\n  return url2.toString();\\n}\\nfunction url(strings, ...values) {\\n  return strings.reduce(\\n    (result, str, i) => result + encodeURIComponent(_nullishCoalesce(values[i - 1], () => ( \\\"\\\"))) + str\\n  );\\n}\\n\\n// src/http-client.ts\\nfunction getBearerTokenFromAuthValue(authValue) {\\n  if (authValue.type === \\\"public\\\") {\\n    return authValue.publicApiKey;\\n  } else {\\n    return authValue.token.raw;\\n  }\\n}\\nvar HttpClient = class {\\n  constructor(baseUrl, fetchPolyfill, authCallback) {\\n    this._baseUrl = baseUrl;\\n    this._fetchPolyfill = fetchPolyfill;\\n    this._authCallback = authCallback;\\n  }\\n  // ------------------------------------------------------------------\\n  // Public methods\\n  // ------------------------------------------------------------------\\n  /**\\n   * Constructs and makes the HTTP request, but does not handle the response.\\n   *\\n   * This is what .rawFetch() does:    \\ud83d\\udc48 This method!\\n   *   1. Set Content-Type header\\n   *   2. Set Authorization header\\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\\n   *\\n   * This is what .fetch() does ON TOP of that:\\n   *   4. Parse response body as Json\\n   *   5. ...but silently return `{}` if that parsing fails\\n   *   6. Throw HttpError if response is an error\\n   */\\n  async rawFetch(endpoint, options, params) {\\n    if (!endpoint.startsWith(\\\"/v2/c/\\\")) {\\n      raise(\\\"This client can only be used to make /v2/c/* requests\\\");\\n    }\\n    const url2 = urljoin(this._baseUrl, endpoint, params);\\n    return await this._fetchPolyfill(url2, {\\n      ...options,\\n      headers: {\\n        // These headers are default, but can be overriden by custom headers\\n        \\\"Content-Type\\\": \\\"application/json; charset=utf-8\\\",\\n        // Possible header overrides\\n        ..._optionalChain([options, 'optionalAccess', _45 => _45.headers]),\\n        // Cannot be overriden by custom headers\\n        Authorization: `Bearer ${getBearerTokenFromAuthValue(await this._authCallback())}`,\\n        \\\"X-LB-Client\\\": PKG_VERSION || \\\"dev\\\"\\n      }\\n    });\\n  }\\n  /**\\n   * Constructs, makes the HTTP request, and handles the response by parsing\\n   * JSON and/or throwing an HttpError if it failed.\\n   *\\n   * This is what .rawFetch() does:\\n   *   1. Set Content-Type header\\n   *   2. Set Authorization header\\n   *   3. Call the callback to obtain the `authValue` to use in the Authorization header\\n   *\\n   * This is what .fetch() does ON TOP of that:   \\ud83d\\udc48 This method!\\n   *   4. Parse response body as Json\\n   *   5. ...but silently return `{}` if that parsing fails (\\ud83e\\udd14)\\n   *   6. Throw HttpError if response is an error\\n   */\\n  async fetch(endpoint, options, params) {\\n    const response = await this.rawFetch(endpoint, options, params);\\n    if (!response.ok) {\\n      let error3;\\n      try {\\n        const errorBody = await response.json();\\n        error3 = new HttpError(errorBody.message, response.status, errorBody);\\n      } catch (e3) {\\n        error3 = new HttpError(response.statusText, response.status);\\n      }\\n      throw error3;\\n    }\\n    let body;\\n    try {\\n      body = await response.json();\\n    } catch (e4) {\\n      body = {};\\n    }\\n    return body;\\n  }\\n  /**\\n   * Makes a GET request and returns the raw response.\\n   * Won't throw if the reponse is a non-2xx.\\n   * @deprecated Ideally, use .get() instead.\\n   */\\n  async rawGet(endpoint, params, options) {\\n    return await this.rawFetch(endpoint, options, params);\\n  }\\n  /**\\n   * Makes a POST request and returns the raw response.\\n   * Won't throw if the reponse is a non-2xx.\\n   * @deprecated Ideally, use .post() instead.\\n   */\\n  async rawPost(endpoint, body) {\\n    return await this.rawFetch(endpoint, {\\n      method: \\\"POST\\\",\\n      body: JSON.stringify(body)\\n    });\\n  }\\n  /**\\n   * Makes a DELETE request and returns the raw response.\\n   * Won't throw if the reponse is a non-2xx.\\n   * @deprecated Ideally, use .delete() instead.\\n   */\\n  async rawDelete(endpoint) {\\n    return await this.rawFetch(endpoint, { method: \\\"DELETE\\\" });\\n  }\\n  /**\\n   * Makes a GET request, and return the JSON response.\\n   * Will throw if the reponse is a non-2xx.\\n   */\\n  async get(endpoint, params, options) {\\n    return await this.fetch(endpoint, options, params);\\n  }\\n  /**\\n   * Makes a POST request, and return the JSON response.\\n   * Will throw if the reponse is a non-2xx.\\n   */\\n  async post(endpoint, body, options, params) {\\n    return await this.fetch(\\n      endpoint,\\n      {\\n        ...options,\\n        method: \\\"POST\\\",\\n        body: JSON.stringify(body)\\n      },\\n      params\\n    );\\n  }\\n  /**\\n   * Makes a DELETE request, and return the JSON response.\\n   * Will throw if the reponse is a non-2xx.\\n   */\\n  async delete(endpoint) {\\n    return await this.fetch(endpoint, { method: \\\"DELETE\\\" });\\n  }\\n  /**\\n   * Makes a PUT request for a Blob body, and return the JSON response.\\n   * Will throw if the reponse is a non-2xx.\\n   */\\n  async putBlob(endpoint, blob, params, options) {\\n    return await this.fetch(\\n      endpoint,\\n      {\\n        ...options,\\n        method: \\\"PUT\\\",\\n        headers: {\\n          \\\"Content-Type\\\": \\\"application/octet-stream\\\"\\n        },\\n        body: blob\\n      },\\n      params\\n    );\\n  }\\n};\\n\\n// src/notifications.ts\\nfunction createNotificationsApi({\\n  baseUrl,\\n  authManager,\\n  currentUserIdStore,\\n  fetchPolyfill\\n}) {\\n  async function getAuthValue() {\\n    const authValue = await authManager.getAuthValue({\\n      requestedScope: \\\"comments:read\\\"\\n    });\\n    if (authValue.type === \\\"secret\\\" && authValue.token.parsed.k === \\\"acc\\\" /* ACCESS_TOKEN */) {\\n      const userId = authValue.token.parsed.uid;\\n      currentUserIdStore.set(() => userId);\\n    }\\n    return authValue;\\n  }\\n  const httpClient = new HttpClient(baseUrl, fetchPolyfill, getAuthValue);\\n  async function getInboxNotifications(options) {\\n    const PAGE_SIZE = 50;\\n    const json = await httpClient.get(url`/v2/c/inbox-notifications`, {\\n      cursor: _optionalChain([options, 'optionalAccess', _46 => _46.cursor]),\\n      limit: PAGE_SIZE\\n    });\\n    return {\\n      inboxNotifications: json.inboxNotifications.map(\\n        convertToInboxNotificationData\\n      ),\\n      threads: json.threads.map(convertToThreadData),\\n      nextCursor: json.meta.nextCursor,\\n      requestedAt: new Date(json.meta.requestedAt)\\n    };\\n  }\\n  async function getInboxNotificationsSince(options) {\\n    const json = await httpClient.get(\\n      url`/v2/c/inbox-notifications/delta`,\\n      { since: options.since.toISOString() },\\n      { signal: _optionalChain([options, 'optionalAccess', _47 => _47.signal]) }\\n    );\\n    return {\\n      inboxNotifications: {\\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\\n        deleted: json.deletedInboxNotifications.map(\\n          convertToInboxNotificationDeleteInfo\\n        )\\n      },\\n      threads: {\\n        updated: json.threads.map(convertToThreadData),\\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\\n      },\\n      requestedAt: new Date(json.meta.requestedAt)\\n    };\\n  }\\n  async function getUnreadInboxNotificationsCount() {\\n    const { count } = await httpClient.get(\\n      url`/v2/c/inbox-notifications/count`\\n    );\\n    return count;\\n  }\\n  async function markAllInboxNotificationsAsRead() {\\n    await httpClient.post(url`/v2/c/inbox-notifications/read`, {\\n      inboxNotificationIds: \\\"all\\\"\\n    });\\n  }\\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\\n    await httpClient.post(url`/v2/c/inbox-notifications/read`, {\\n      inboxNotificationIds\\n    });\\n  }\\n  const batchedMarkInboxNotificationsAsRead = new Batch(\\n    async (batchedInboxNotificationIds) => {\\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\\n      await markInboxNotificationsAsRead(inboxNotificationIds);\\n      return inboxNotificationIds;\\n    },\\n    { delay: 50 }\\n  );\\n  async function markInboxNotificationAsRead(inboxNotificationId) {\\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\\n  }\\n  async function deleteAllInboxNotifications() {\\n    await httpClient.delete(url`/v2/c/inbox-notifications`);\\n  }\\n  async function deleteInboxNotification(inboxNotificationId) {\\n    await httpClient.delete(\\n      url`/v2/c/inbox-notifications/${inboxNotificationId}`\\n    );\\n  }\\n  async function getUserThreads_experimental(options) {\\n    let query;\\n    if (_optionalChain([options, 'optionalAccess', _48 => _48.query])) {\\n      query = objectToQuery(options.query);\\n    }\\n    const PAGE_SIZE = 50;\\n    const json = await httpClient.get(url`/v2/c/threads`, {\\n      cursor: options.cursor,\\n      query,\\n      limit: PAGE_SIZE\\n    });\\n    return {\\n      threads: json.threads.map(convertToThreadData),\\n      inboxNotifications: json.inboxNotifications.map(\\n        convertToInboxNotificationData\\n      ),\\n      nextCursor: json.meta.nextCursor,\\n      requestedAt: new Date(json.meta.requestedAt)\\n    };\\n  }\\n  async function getUserThreadsSince_experimental(options) {\\n    const json = await httpClient.get(\\n      url`/v2/c/threads/delta`,\\n      { since: options.since.toISOString() },\\n      { signal: options.signal }\\n    );\\n    return {\\n      threads: {\\n        updated: json.threads.map(convertToThreadData),\\n        deleted: json.deletedThreads.map(convertToThreadDeleteInfo)\\n      },\\n      inboxNotifications: {\\n        updated: json.inboxNotifications.map(convertToInboxNotificationData),\\n        deleted: json.deletedInboxNotifications.map(\\n          convertToInboxNotificationDeleteInfo\\n        )\\n      },\\n      requestedAt: new Date(json.meta.requestedAt)\\n    };\\n  }\\n  return {\\n    getInboxNotifications,\\n    getInboxNotificationsSince,\\n    getUnreadInboxNotificationsCount,\\n    markAllInboxNotificationsAsRead,\\n    markInboxNotificationAsRead,\\n    deleteAllInboxNotifications,\\n    deleteInboxNotification,\\n    getUserThreads_experimental,\\n    getUserThreadsSince_experimental\\n  };\\n}\\n\\n// src/lib/position.ts\\nvar MIN_CODE = 32;\\nvar MAX_CODE = 126;\\nvar NUM_DIGITS = MAX_CODE - MIN_CODE + 1;\\nvar ZERO = nthDigit(0);\\nvar ONE = nthDigit(1);\\nvar ZERO_NINE = ZERO + nthDigit(-1);\\nfunction nthDigit(n) {\\n  const code = MIN_CODE + (n < 0 ? NUM_DIGITS + n : n);\\n  if (code < MIN_CODE || code > MAX_CODE) {\\n    throw new Error(`Invalid n value: ${n}`);\\n  }\\n  return String.fromCharCode(code);\\n}\\nfunction makePosition(x, y) {\\n  if (x !== void 0 && y !== void 0) {\\n    return between(x, y);\\n  } else if (x !== void 0) {\\n    return after(x);\\n  } else if (y !== void 0) {\\n    return before(y);\\n  } else {\\n    return ONE;\\n  }\\n}\\nfunction before(pos) {\\n  const lastIndex = pos.length - 1;\\n  for (let i = 0; i <= lastIndex; i++) {\\n    const code = pos.charCodeAt(i);\\n    if (code <= MIN_CODE) {\\n      continue;\\n    }\\n    if (i === lastIndex) {\\n      if (code === MIN_CODE + 1) {\\n        return pos.substring(0, i) + ZERO_NINE;\\n      } else {\\n        return pos.substring(0, i) + String.fromCharCode(code - 1);\\n      }\\n    } else {\\n      return pos.substring(0, i + 1);\\n    }\\n  }\\n  return ONE;\\n}\\nfunction after(pos) {\\n  for (let i = 0; i <= pos.length - 1; i++) {\\n    const code = pos.charCodeAt(i);\\n    if (code >= MAX_CODE) {\\n      continue;\\n    }\\n    return pos.substring(0, i) + String.fromCharCode(code + 1);\\n  }\\n  return pos + ONE;\\n}\\nfunction between(lo, hi) {\\n  if (lo < hi) {\\n    return _between(lo, hi);\\n  } else if (lo > hi) {\\n    return _between(hi, lo);\\n  } else {\\n    throw new Error(\\\"Cannot compute value between two equal positions\\\");\\n  }\\n}\\nfunction _between(lo, hi) {\\n  let index = 0;\\n  const loLen = lo.length;\\n  const hiLen = hi.length;\\n  while (true) {\\n    const loCode = index < loLen ? lo.charCodeAt(index) : MIN_CODE;\\n    const hiCode = index < hiLen ? hi.charCodeAt(index) : MAX_CODE;\\n    if (loCode === hiCode) {\\n      index++;\\n      continue;\\n    }\\n    if (hiCode - loCode === 1) {\\n      const size = index + 1;\\n      let prefix = lo.substring(0, size);\\n      if (prefix.length < size) {\\n        prefix += ZERO.repeat(size - prefix.length);\\n      }\\n      const suffix = lo.substring(size);\\n      const nines = \\\"\\\";\\n      return prefix + _between(suffix, nines);\\n    } else {\\n      return takeN(lo, index) + String.fromCharCode(hiCode + loCode >> 1);\\n    }\\n  }\\n}\\nfunction takeN(pos, n) {\\n  return n < pos.length ? pos.substring(0, n) : pos + ZERO.repeat(n - pos.length);\\n}\\nvar MIN_NON_ZERO_CODE = MIN_CODE + 1;\\nfunction isPos(str) {\\n  if (str === \\\"\\\") {\\n    return false;\\n  }\\n  const lastIdx = str.length - 1;\\n  const last = str.charCodeAt(lastIdx);\\n  if (last < MIN_NON_ZERO_CODE || last > MAX_CODE) {\\n    return false;\\n  }\\n  for (let i = 0; i < lastIdx; i++) {\\n    const code = str.charCodeAt(i);\\n    if (code < MIN_CODE || code > MAX_CODE) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\nfunction convertToPos(str) {\\n  const codes = [];\\n  for (let i = 0; i < str.length; i++) {\\n    const code = str.charCodeAt(i);\\n    codes.push(code < MIN_CODE ? MIN_CODE : code > MAX_CODE ? MAX_CODE : code);\\n  }\\n  while (codes.length > 0 && codes[codes.length - 1] === MIN_CODE) {\\n    codes.length--;\\n  }\\n  return codes.length > 0 ? String.fromCharCode(...codes) : (\\n    // Edge case: the str was a 0-only string, which is invalid. Default back to .1\\n    ONE\\n  );\\n}\\nfunction asPos(str) {\\n  return isPos(str) ? str : convertToPos(str);\\n}\\n\\n// src/protocol/Op.ts\\nvar OpCode = /* @__PURE__ */ ((OpCode2) => {\\n  OpCode2[OpCode2[\\\"INIT\\\"] = 0] = \\\"INIT\\\";\\n  OpCode2[OpCode2[\\\"SET_PARENT_KEY\\\"] = 1] = \\\"SET_PARENT_KEY\\\";\\n  OpCode2[OpCode2[\\\"CREATE_LIST\\\"] = 2] = \\\"CREATE_LIST\\\";\\n  OpCode2[OpCode2[\\\"UPDATE_OBJECT\\\"] = 3] = \\\"UPDATE_OBJECT\\\";\\n  OpCode2[OpCode2[\\\"CREATE_OBJECT\\\"] = 4] = \\\"CREATE_OBJECT\\\";\\n  OpCode2[OpCode2[\\\"DELETE_CRDT\\\"] = 5] = \\\"DELETE_CRDT\\\";\\n  OpCode2[OpCode2[\\\"DELETE_OBJECT_KEY\\\"] = 6] = \\\"DELETE_OBJECT_KEY\\\";\\n  OpCode2[OpCode2[\\\"CREATE_MAP\\\"] = 7] = \\\"CREATE_MAP\\\";\\n  OpCode2[OpCode2[\\\"CREATE_REGISTER\\\"] = 8] = \\\"CREATE_REGISTER\\\";\\n  return OpCode2;\\n})(OpCode || {});\\nfunction ackOp(opId) {\\n  return {\\n    type: 5 /* DELETE_CRDT */,\\n    id: \\\"ACK\\\",\\n    // (H)ACK\\n    opId\\n  };\\n}\\nfunction isAckOp(op) {\\n  return op.type === 5 /* DELETE_CRDT */ && op.id === \\\"ACK\\\";\\n}\\n\\n// src/crdts/AbstractCrdt.ts\\nfunction crdtAsLiveNode(value) {\\n  return value;\\n}\\nfunction HasParent(node, key, pos = asPos(key)) {\\n  return Object.freeze({ type: \\\"HasParent\\\", node, key, pos });\\n}\\nvar NoParent = Object.freeze({ type: \\\"NoParent\\\" });\\nfunction Orphaned(oldKey, oldPos = asPos(oldKey)) {\\n  return Object.freeze({ type: \\\"Orphaned\\\", oldKey, oldPos });\\n}\\nvar AbstractCrdt = class {\\n  constructor() {\\n    /** @internal */\\n    this._parent = NoParent;\\n  }\\n  /** @internal */\\n  _getParentKeyOrThrow() {\\n    switch (this.parent.type) {\\n      case \\\"HasParent\\\":\\n        return this.parent.key;\\n      case \\\"NoParent\\\":\\n        throw new Error(\\\"Parent key is missing\\\");\\n      case \\\"Orphaned\\\":\\n        return this.parent.oldKey;\\n      default:\\n        return assertNever(this.parent, \\\"Unknown state\\\");\\n    }\\n  }\\n  /** @internal */\\n  get _parentPos() {\\n    switch (this.parent.type) {\\n      case \\\"HasParent\\\":\\n        return this.parent.pos;\\n      case \\\"NoParent\\\":\\n        throw new Error(\\\"Parent key is missing\\\");\\n      case \\\"Orphaned\\\":\\n        return this.parent.oldPos;\\n      default:\\n        return assertNever(this.parent, \\\"Unknown state\\\");\\n    }\\n  }\\n  /** @internal */\\n  get _pool() {\\n    return this.__pool;\\n  }\\n  get roomId() {\\n    return this.__pool ? this.__pool.roomId : null;\\n  }\\n  /** @internal */\\n  get _id() {\\n    return this.__id;\\n  }\\n  /** @internal */\\n  get parent() {\\n    return this._parent;\\n  }\\n  /** @internal */\\n  get _parentKey() {\\n    switch (this.parent.type) {\\n      case \\\"HasParent\\\":\\n        return this.parent.key;\\n      case \\\"NoParent\\\":\\n        return null;\\n      case \\\"Orphaned\\\":\\n        return this.parent.oldKey;\\n      default:\\n        return assertNever(this.parent, \\\"Unknown state\\\");\\n    }\\n  }\\n  /** @internal */\\n  _apply(op, _isLocal) {\\n    switch (op.type) {\\n      case 5 /* DELETE_CRDT */: {\\n        if (this.parent.type === \\\"HasParent\\\") {\\n          return this.parent.node._detachChild(crdtAsLiveNode(this));\\n        }\\n        return { modified: false };\\n      }\\n    }\\n    return { modified: false };\\n  }\\n  /** @internal */\\n  _setParentLink(newParentNode, newParentKey) {\\n    switch (this.parent.type) {\\n      case \\\"HasParent\\\":\\n        if (this.parent.node !== newParentNode) {\\n          throw new Error(\\\"Cannot set parent: node already has a parent\\\");\\n        } else {\\n          this._parent = HasParent(newParentNode, newParentKey);\\n          return;\\n        }\\n      case \\\"Orphaned\\\":\\n      case \\\"NoParent\\\": {\\n        this._parent = HasParent(newParentNode, newParentKey);\\n        return;\\n      }\\n      default:\\n        return assertNever(this.parent, \\\"Unknown state\\\");\\n    }\\n  }\\n  /** @internal */\\n  _attach(id, pool) {\\n    if (this.__id || this.__pool) {\\n      throw new Error(\\\"Cannot attach node: already attached\\\");\\n    }\\n    pool.addNode(id, crdtAsLiveNode(this));\\n    this.__id = id;\\n    this.__pool = pool;\\n  }\\n  /** @internal */\\n  _detach() {\\n    if (this.__pool && this.__id) {\\n      this.__pool.deleteNode(this.__id);\\n    }\\n    switch (this.parent.type) {\\n      case \\\"HasParent\\\": {\\n        this._parent = Orphaned(this.parent.key, this.parent.pos);\\n        break;\\n      }\\n      case \\\"NoParent\\\": {\\n        this._parent = NoParent;\\n        break;\\n      }\\n      case \\\"Orphaned\\\": {\\n        break;\\n      }\\n      default:\\n        assertNever(this.parent, \\\"Unknown state\\\");\\n    }\\n    this.__pool = void 0;\\n  }\\n  /**\\n   * @internal\\n   *\\n   * Clear the Immutable cache, so that the next call to `.toImmutable()` will\\n   * recompute the equivalent Immutable value again.  Call this after every\\n   * mutation to the Live node.\\n   */\\n  invalidate() {\\n    if (this._cachedImmutable !== void 0 || this._cachedTreeNode !== void 0) {\\n      this._cachedImmutable = void 0;\\n      this._cachedTreeNode = void 0;\\n      if (this.parent.type === \\\"HasParent\\\") {\\n        this.parent.node.invalidate();\\n      }\\n    }\\n  }\\n  /**\\n   * @internal\\n   *\\n   * Return an snapshot of this Live tree for use in DevTools.\\n   */\\n  toTreeNode(key) {\\n    if (this._cachedTreeNode === void 0 || this._cachedTreeNodeKey !== key) {\\n      this._cachedTreeNodeKey = key;\\n      this._cachedTreeNode = this._toTreeNode(key);\\n    }\\n    return this._cachedTreeNode;\\n  }\\n  /**\\n   * Return an immutable snapshot of this Live node and its children.\\n   */\\n  toImmutable() {\\n    if (this._cachedImmutable === void 0) {\\n      this._cachedImmutable = this._toImmutable();\\n    }\\n    return this._cachedImmutable;\\n  }\\n};\\n\\n// src/protocol/SerializedCrdt.ts\\nvar CrdtType = /* @__PURE__ */ ((CrdtType2) => {\\n  CrdtType2[CrdtType2[\\\"OBJECT\\\"] = 0] = \\\"OBJECT\\\";\\n  CrdtType2[CrdtType2[\\\"LIST\\\"] = 1] = \\\"LIST\\\";\\n  CrdtType2[CrdtType2[\\\"MAP\\\"] = 2] = \\\"MAP\\\";\\n  CrdtType2[CrdtType2[\\\"REGISTER\\\"] = 3] = \\\"REGISTER\\\";\\n  return CrdtType2;\\n})(CrdtType || {});\\nfunction isRootCrdt(crdt) {\\n  return crdt.type === 0 /* OBJECT */ && !isChildCrdt(crdt);\\n}\\nfunction isChildCrdt(crdt) {\\n  return crdt.parentId !== void 0 && crdt.parentKey !== void 0;\\n}\\n\\n// src/lib/nanoid.ts\\nvar nanoid = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce(\\n  (t2, e) => t2 += (e &= 63) < 36 ? e.toString(36) : e < 62 ? (e - 26).toString(36).toUpperCase() : e < 63 ? \\\"_\\\" : \\\"-\\\",\\n  \\\"\\\"\\n);\\n\\n// src/crdts/LiveRegister.ts\\nvar LiveRegister = class _LiveRegister extends AbstractCrdt {\\n  constructor(data) {\\n    super();\\n    this._data = data;\\n  }\\n  get data() {\\n    return this._data;\\n  }\\n  /** @internal */\\n  static _deserialize([id, item], _parentToChildren, pool) {\\n    const register = new _LiveRegister(item.data);\\n    register._attach(id, pool);\\n    return register;\\n  }\\n  /** @internal */\\n  _toOps(parentId, parentKey, pool) {\\n    if (this._id === void 0) {\\n      throw new Error(\\n        \\\"Cannot serialize register if parentId or parentKey is undefined\\\"\\n      );\\n    }\\n    return [\\n      {\\n        type: 8 /* CREATE_REGISTER */,\\n        opId: _optionalChain([pool, 'optionalAccess', _49 => _49.generateOpId, 'call', _50 => _50()]),\\n        id: this._id,\\n        parentId,\\n        parentKey,\\n        data: this.data\\n      }\\n    ];\\n  }\\n  /** @internal */\\n  _serialize() {\\n    if (this.parent.type !== \\\"HasParent\\\") {\\n      throw new Error(\\\"Cannot serialize LiveRegister if parent is missing\\\");\\n    }\\n    return {\\n      type: 3 /* REGISTER */,\\n      parentId: nn(this.parent.node._id, \\\"Parent node expected to have ID\\\"),\\n      parentKey: this.parent.key,\\n      data: this.data\\n    };\\n  }\\n  /** @internal */\\n  _attachChild(_op) {\\n    throw new Error(\\\"Method not implemented.\\\");\\n  }\\n  /** @internal */\\n  _detachChild(_crdt) {\\n    throw new Error(\\\"Method not implemented.\\\");\\n  }\\n  /** @internal */\\n  _apply(op, isLocal) {\\n    return super._apply(op, isLocal);\\n  }\\n  /** @internal */\\n  _toTreeNode(key) {\\n    return {\\n      type: \\\"Json\\\",\\n      id: _nullishCoalesce(this._id, () => ( nanoid())),\\n      key,\\n      payload: this._data\\n    };\\n  }\\n  /** @internal */\\n  _toImmutable() {\\n    return this._data;\\n  }\\n  clone() {\\n    return deepClone(this.data);\\n  }\\n};\\n\\n// src/crdts/LiveList.ts\\nfunction compareNodePosition(itemA, itemB) {\\n  const posA = itemA._parentPos;\\n  const posB = itemB._parentPos;\\n  return posA === posB ? 0 : posA < posB ? -1 : 1;\\n}\\nvar LiveList = class _LiveList extends AbstractCrdt {\\n  constructor(items) {\\n    super();\\n    this._items = [];\\n    this._implicitlyDeletedItems = /* @__PURE__ */ new WeakSet();\\n    this._unacknowledgedSets = /* @__PURE__ */ new Map();\\n    let position = void 0;\\n    for (const item of items) {\\n      const newPosition = makePosition(position);\\n      const node = lsonToLiveNode(item);\\n      node._setParentLink(this, newPosition);\\n      this._items.push(node);\\n      position = newPosition;\\n    }\\n  }\\n  /** @internal */\\n  static _deserialize([id], parentToChildren, pool) {\\n    const list = new _LiveList([]);\\n    list._attach(id, pool);\\n    const children = parentToChildren.get(id);\\n    if (children === void 0) {\\n      return list;\\n    }\\n    for (const [id2, crdt] of children) {\\n      const child = deserialize([id2, crdt], parentToChildren, pool);\\n      child._setParentLink(list, crdt.parentKey);\\n      list._insertAndSort(child);\\n    }\\n    return list;\\n  }\\n  /**\\n   * @internal\\n   * This function assumes that the resulting ops will be sent to the server if they have an 'opId'\\n   * so we mutate _unacknowledgedSets to avoid potential flickering\\n   * https://github.com/liveblocks/liveblocks/pull/1177\\n   *\\n   * This is quite unintuitive and should disappear as soon as\\n   * we introduce an explicit LiveList.Set operation\\n   */\\n  _toOps(parentId, parentKey, pool) {\\n    if (this._id === void 0) {\\n      throw new Error(\\\"Cannot serialize item is not attached\\\");\\n    }\\n    const ops = [];\\n    const op = {\\n      id: this._id,\\n      opId: _optionalChain([pool, 'optionalAccess', _51 => _51.generateOpId, 'call', _52 => _52()]),\\n      type: 2 /* CREATE_LIST */,\\n      parentId,\\n      parentKey\\n    };\\n    ops.push(op);\\n    for (const item of this._items) {\\n      const parentKey2 = item._getParentKeyOrThrow();\\n      const childOps = HACK_addIntentAndDeletedIdToOperation(\\n        item._toOps(this._id, parentKey2, pool),\\n        void 0\\n      );\\n      const childOpId = childOps[0].opId;\\n      if (childOpId !== void 0) {\\n        this._unacknowledgedSets.set(parentKey2, childOpId);\\n      }\\n      ops.push(...childOps);\\n    }\\n    return ops;\\n  }\\n  /**\\n   * @internal\\n   *\\n   * Adds a new item into the sorted list, in the correct position.\\n   */\\n  _insertAndSort(item) {\\n    this._items.push(item);\\n    this._sortItems();\\n  }\\n  /** @internal */\\n  _sortItems() {\\n    this._items.sort(compareNodePosition);\\n    this.invalidate();\\n  }\\n  /** @internal */\\n  _indexOfPosition(position) {\\n    return this._items.findIndex(\\n      (item) => item._getParentKeyOrThrow() === position\\n    );\\n  }\\n  /** @internal */\\n  _attach(id, pool) {\\n    super._attach(id, pool);\\n    for (const item of this._items) {\\n      item._attach(pool.generateId(), pool);\\n    }\\n  }\\n  /** @internal */\\n  _detach() {\\n    super._detach();\\n    for (const item of this._items) {\\n      item._detach();\\n    }\\n  }\\n  /** @internal */\\n  _applySetRemote(op) {\\n    if (this._pool === void 0) {\\n      throw new Error(\\\"Can't attach child if managed pool is not present\\\");\\n    }\\n    const { id, parentKey: key } = op;\\n    const child = creationOpToLiveNode(op);\\n    child._attach(id, this._pool);\\n    child._setParentLink(this, key);\\n    const deletedId = op.deletedId;\\n    const indexOfItemWithSamePosition = this._indexOfPosition(key);\\n    if (indexOfItemWithSamePosition !== -1) {\\n      const itemWithSamePosition = this._items[indexOfItemWithSamePosition];\\n      if (itemWithSamePosition._id === deletedId) {\\n        itemWithSamePosition._detach();\\n        this._items[indexOfItemWithSamePosition] = child;\\n        return {\\n          modified: makeUpdate(this, [\\n            setDelta(indexOfItemWithSamePosition, child)\\n          ]),\\n          reverse: []\\n        };\\n      } else {\\n        this._implicitlyDeletedItems.add(itemWithSamePosition);\\n        this._items[indexOfItemWithSamePosition] = child;\\n        const delta = [\\n          setDelta(indexOfItemWithSamePosition, child)\\n        ];\\n        const deleteDelta2 = this._detachItemAssociatedToSetOperation(\\n          op.deletedId\\n        );\\n        if (deleteDelta2) {\\n          delta.push(deleteDelta2);\\n        }\\n        return {\\n          modified: makeUpdate(this, delta),\\n          reverse: []\\n        };\\n      }\\n    } else {\\n      const updates = [];\\n      const deleteDelta2 = this._detachItemAssociatedToSetOperation(\\n        op.deletedId\\n      );\\n      if (deleteDelta2) {\\n        updates.push(deleteDelta2);\\n      }\\n      this._insertAndSort(child);\\n      updates.push(insertDelta(this._indexOfPosition(key), child));\\n      return {\\n        reverse: [],\\n        modified: makeUpdate(this, updates)\\n      };\\n    }\\n  }\\n  /** @internal */\\n  _applySetAck(op) {\\n    if (this._pool === void 0) {\\n      throw new Error(\\\"Can't attach child if managed pool is not present\\\");\\n    }\\n    const delta = [];\\n    const deletedDelta = this._detachItemAssociatedToSetOperation(op.deletedId);\\n    if (deletedDelta) {\\n      delta.push(deletedDelta);\\n    }\\n    const unacknowledgedOpId = this._unacknowledgedSets.get(op.parentKey);\\n    if (unacknowledgedOpId !== void 0) {\\n      if (unacknowledgedOpId !== op.opId) {\\n        return delta.length === 0 ? { modified: false } : { modified: makeUpdate(this, delta), reverse: [] };\\n      } else {\\n        this._unacknowledgedSets.delete(op.parentKey);\\n      }\\n    }\\n    const indexOfItemWithSamePosition = this._indexOfPosition(op.parentKey);\\n    const existingItem = this._items.find((item) => item._id === op.id);\\n    if (existingItem !== void 0) {\\n      if (existingItem._parentKey === op.parentKey) {\\n        return {\\n          modified: delta.length > 0 ? makeUpdate(this, delta) : false,\\n          reverse: []\\n        };\\n      }\\n      if (indexOfItemWithSamePosition !== -1) {\\n        this._implicitlyDeletedItems.add(\\n          this._items[indexOfItemWithSamePosition]\\n        );\\n        const [prevNode] = this._items.splice(indexOfItemWithSamePosition, 1);\\n        delta.push(deleteDelta(indexOfItemWithSamePosition, prevNode));\\n      }\\n      const prevIndex = this._items.indexOf(existingItem);\\n      existingItem._setParentLink(this, op.parentKey);\\n      this._sortItems();\\n      const newIndex = this._items.indexOf(existingItem);\\n      if (newIndex !== prevIndex) {\\n        delta.push(moveDelta(prevIndex, newIndex, existingItem));\\n      }\\n      return {\\n        modified: delta.length > 0 ? makeUpdate(this, delta) : false,\\n        reverse: []\\n      };\\n    } else {\\n      const orphan = this._pool.getNode(op.id);\\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\\n        orphan._setParentLink(this, op.parentKey);\\n        this._implicitlyDeletedItems.delete(orphan);\\n        this._insertAndSort(orphan);\\n        const recreatedItemIndex = this._items.indexOf(orphan);\\n        return {\\n          modified: makeUpdate(this, [\\n            // If there is an item at this position, update is a set, else it's an insert\\n            indexOfItemWithSamePosition === -1 ? insertDelta(recreatedItemIndex, orphan) : setDelta(recreatedItemIndex, orphan),\\n            ...delta\\n          ]),\\n          reverse: []\\n        };\\n      } else {\\n        if (indexOfItemWithSamePosition !== -1) {\\n          this._items.splice(indexOfItemWithSamePosition, 1);\\n        }\\n        const { newItem, newIndex } = this._createAttachItemAndSort(\\n          op,\\n          op.parentKey\\n        );\\n        return {\\n          modified: makeUpdate(this, [\\n            // If there is an item at this position, update is a set, else it's an insert\\n            indexOfItemWithSamePosition === -1 ? insertDelta(newIndex, newItem) : setDelta(newIndex, newItem),\\n            ...delta\\n          ]),\\n          reverse: []\\n        };\\n      }\\n    }\\n  }\\n  /**\\n   * Returns the update delta of the deletion or null\\n   * @internal\\n   */\\n  _detachItemAssociatedToSetOperation(deletedId) {\\n    if (deletedId === void 0 || this._pool === void 0) {\\n      return null;\\n    }\\n    const deletedItem = this._pool.getNode(deletedId);\\n    if (deletedItem === void 0) {\\n      return null;\\n    }\\n    const result = this._detachChild(deletedItem);\\n    if (result.modified === false) {\\n      return null;\\n    }\\n    return result.modified.updates[0];\\n  }\\n  /** @internal */\\n  _applyRemoteInsert(op) {\\n    if (this._pool === void 0) {\\n      throw new Error(\\\"Can't attach child if managed pool is not present\\\");\\n    }\\n    const key = asPos(op.parentKey);\\n    const existingItemIndex = this._indexOfPosition(key);\\n    if (existingItemIndex !== -1) {\\n      this._shiftItemPosition(existingItemIndex, key);\\n    }\\n    const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\\n    return {\\n      modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\\n      reverse: []\\n    };\\n  }\\n  /** @internal */\\n  _applyInsertAck(op) {\\n    const existingItem = this._items.find((item) => item._id === op.id);\\n    const key = asPos(op.parentKey);\\n    const itemIndexAtPosition = this._indexOfPosition(key);\\n    if (existingItem) {\\n      if (existingItem._parentKey === key) {\\n        return {\\n          modified: false\\n        };\\n      } else {\\n        const oldPositionIndex = this._items.indexOf(existingItem);\\n        if (itemIndexAtPosition !== -1) {\\n          this._shiftItemPosition(itemIndexAtPosition, key);\\n        }\\n        existingItem._setParentLink(this, key);\\n        this._sortItems();\\n        const newIndex = this._indexOfPosition(key);\\n        if (newIndex === oldPositionIndex) {\\n          return { modified: false };\\n        }\\n        return {\\n          modified: makeUpdate(this, [\\n            moveDelta(oldPositionIndex, newIndex, existingItem)\\n          ]),\\n          reverse: []\\n        };\\n      }\\n    } else {\\n      const orphan = nn(this._pool).getNode(op.id);\\n      if (orphan && this._implicitlyDeletedItems.has(orphan)) {\\n        orphan._setParentLink(this, key);\\n        this._implicitlyDeletedItems.delete(orphan);\\n        this._insertAndSort(orphan);\\n        const newIndex = this._indexOfPosition(key);\\n        return {\\n          modified: makeUpdate(this, [insertDelta(newIndex, orphan)]),\\n          reverse: []\\n        };\\n      } else {\\n        if (itemIndexAtPosition !== -1) {\\n          this._shiftItemPosition(itemIndexAtPosition, key);\\n        }\\n        const { newItem, newIndex } = this._createAttachItemAndSort(op, key);\\n        return {\\n          modified: makeUpdate(this, [insertDelta(newIndex, newItem)]),\\n          reverse: []\\n        };\\n      }\\n    }\\n  }\\n  /** @internal */\\n  _applyInsertUndoRedo(op) {\\n    const { id, parentKey: key } = op;\\n    const child = creationOpToLiveNode(op);\\n    if (_optionalChain([this, 'access', _53 => _53._pool, 'optionalAccess', _54 => _54.getNode, 'call', _55 => _55(id)]) !== void 0) {\\n      return { modified: false };\\n    }\\n    child._attach(id, nn(this._pool));\\n    child._setParentLink(this, key);\\n    const existingItemIndex = this._indexOfPosition(key);\\n    let newKey = key;\\n    if (existingItemIndex !== -1) {\\n      const before2 = _optionalChain([this, 'access', _56 => _56._items, 'access', _57 => _57[existingItemIndex], 'optionalAccess', _58 => _58._parentPos]);\\n      const after2 = _optionalChain([this, 'access', _59 => _59._items, 'access', _60 => _60[existingItemIndex + 1], 'optionalAccess', _61 => _61._parentPos]);\\n      newKey = makePosition(before2, after2);\\n      child._setParentLink(this, newKey);\\n    }\\n    this._insertAndSort(child);\\n    const newIndex = this._indexOfPosition(newKey);\\n    return {\\n      modified: makeUpdate(this, [insertDelta(newIndex, child)]),\\n      reverse: [{ type: 5 /* DELETE_CRDT */, id }]\\n    };\\n  }\\n  /** @internal */\\n  _applySetUndoRedo(op) {\\n    const { id, parentKey: key } = op;\\n    const child = creationOpToLiveNode(op);\\n    if (_optionalChain([this, 'access', _62 => _62._pool, 'optionalAccess', _63 => _63.getNode, 'call', _64 => _64(id)]) !== void 0) {\\n      return { modified: false };\\n    }\\n    this._unacknowledgedSets.set(key, nn(op.opId));\\n    const indexOfItemWithSameKey = this._indexOfPosition(key);\\n    child._attach(id, nn(this._pool));\\n    child._setParentLink(this, key);\\n    const newKey = key;\\n    if (indexOfItemWithSameKey !== -1) {\\n      const existingItem = this._items[indexOfItemWithSameKey];\\n      existingItem._detach();\\n      this._items[indexOfItemWithSameKey] = child;\\n      const reverse = HACK_addIntentAndDeletedIdToOperation(\\n        existingItem._toOps(nn(this._id), key, this._pool),\\n        op.id\\n      );\\n      const delta = [setDelta(indexOfItemWithSameKey, child)];\\n      const deletedDelta = this._detachItemAssociatedToSetOperation(\\n        op.deletedId\\n      );\\n      if (deletedDelta) {\\n        delta.push(deletedDelta);\\n      }\\n      return {\\n        modified: makeUpdate(this, delta),\\n        reverse\\n      };\\n    } else {\\n      this._insertAndSort(child);\\n      this._detachItemAssociatedToSetOperation(op.deletedId);\\n      const newIndex = this._indexOfPosition(newKey);\\n      return {\\n        reverse: [{ type: 5 /* DELETE_CRDT */, id }],\\n        modified: makeUpdate(this, [insertDelta(newIndex, child)])\\n      };\\n    }\\n  }\\n  /** @internal */\\n  _attachChild(op, source) {\\n    if (this._pool === void 0) {\\n      throw new Error(\\\"Can't attach child if managed pool is not present\\\");\\n    }\\n    let result;\\n    if (op.intent === \\\"set\\\") {\\n      if (source === 1 /* REMOTE */) {\\n        result = this._applySetRemote(op);\\n      } else if (source === 2 /* ACK */) {\\n        result = this._applySetAck(op);\\n      } else {\\n        result = this._applySetUndoRedo(op);\\n      }\\n    } else {\\n      if (source === 1 /* REMOTE */) {\\n        result = this._applyRemoteInsert(op);\\n      } else if (source === 2 /* ACK */) {\\n        result = this._applyInsertAck(op);\\n      } else {\\n        result = this._applyInsertUndoRedo(op);\\n      }\\n    }\\n    if (result.modified !== false) {\\n      this.invalidate();\\n    }\\n    return result;\\n  }\\n  /** @internal */\\n  _detachChild(child) {\\n    if (child) {\\n      const parentKey = nn(child._parentKey);\\n      const reverse = child._toOps(nn(this._id), parentKey, this._pool);\\n      const indexToDelete = this._items.indexOf(child);\\n      if (indexToDelete === -1) {\\n        return {\\n          modified: false\\n        };\\n      }\\n      const [previousNode] = this._items.splice(indexToDelete, 1);\\n      this.invalidate();\\n      child._detach();\\n      return {\\n        modified: makeUpdate(this, [deleteDelta(indexToDelete, previousNode)]),\\n        reverse\\n      };\\n    }\\n    return { modified: false };\\n  }\\n  /** @internal */\\n  _applySetChildKeyRemote(newKey, child) {\\n    if (this._implicitlyDeletedItems.has(child)) {\\n      this._implicitlyDeletedItems.delete(child);\\n      child._setParentLink(this, newKey);\\n      this._insertAndSort(child);\\n      const newIndex = this._items.indexOf(child);\\n      return {\\n        modified: makeUpdate(this, [insertDelta(newIndex, child)]),\\n        reverse: []\\n      };\\n    }\\n    const previousKey = child._parentKey;\\n    if (newKey === previousKey) {\\n      return {\\n        modified: false\\n      };\\n    }\\n    const existingItemIndex = this._indexOfPosition(newKey);\\n    if (existingItemIndex === -1) {\\n      const previousIndex = this._items.indexOf(child);\\n      child._setParentLink(this, newKey);\\n      this._sortItems();\\n      const newIndex = this._items.indexOf(child);\\n      if (newIndex === previousIndex) {\\n        return {\\n          modified: false\\n        };\\n      }\\n      return {\\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\\n        reverse: []\\n      };\\n    } else {\\n      this._items[existingItemIndex]._setParentLink(\\n        this,\\n        makePosition(newKey, _optionalChain([this, 'access', _65 => _65._items, 'access', _66 => _66[existingItemIndex + 1], 'optionalAccess', _67 => _67._parentPos]))\\n      );\\n      const previousIndex = this._items.indexOf(child);\\n      child._setParentLink(this, newKey);\\n      this._sortItems();\\n      const newIndex = this._items.indexOf(child);\\n      if (newIndex === previousIndex) {\\n        return {\\n          modified: false\\n        };\\n      }\\n      return {\\n        modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\\n        reverse: []\\n      };\\n    }\\n  }\\n  /** @internal */\\n  _applySetChildKeyAck(newKey, child) {\\n    const previousKey = nn(child._parentKey);\\n    if (this._implicitlyDeletedItems.has(child)) {\\n      const existingItemIndex = this._indexOfPosition(newKey);\\n      this._implicitlyDeletedItems.delete(child);\\n      if (existingItemIndex !== -1) {\\n        this._items[existingItemIndex]._setParentLink(\\n          this,\\n          makePosition(newKey, _optionalChain([this, 'access', _68 => _68._items, 'access', _69 => _69[existingItemIndex + 1], 'optionalAccess', _70 => _70._parentPos]))\\n        );\\n      }\\n      child._setParentLink(this, newKey);\\n      this._insertAndSort(child);\\n      return {\\n        modified: false\\n      };\\n    } else {\\n      if (newKey === previousKey) {\\n        return {\\n          modified: false\\n        };\\n      }\\n      const previousIndex = this._items.indexOf(child);\\n      const existingItemIndex = this._indexOfPosition(newKey);\\n      if (existingItemIndex !== -1) {\\n        this._items[existingItemIndex]._setParentLink(\\n          this,\\n          makePosition(newKey, _optionalChain([this, 'access', _71 => _71._items, 'access', _72 => _72[existingItemIndex + 1], 'optionalAccess', _73 => _73._parentPos]))\\n        );\\n      }\\n      child._setParentLink(this, newKey);\\n      this._sortItems();\\n      const newIndex = this._items.indexOf(child);\\n      if (previousIndex === newIndex) {\\n        return {\\n          modified: false\\n        };\\n      } else {\\n        return {\\n          modified: makeUpdate(this, [\\n            moveDelta(previousIndex, newIndex, child)\\n          ]),\\n          reverse: []\\n        };\\n      }\\n    }\\n  }\\n  /** @internal */\\n  _applySetChildKeyUndoRedo(newKey, child) {\\n    const previousKey = nn(child._parentKey);\\n    const previousIndex = this._items.indexOf(child);\\n    const existingItemIndex = this._indexOfPosition(newKey);\\n    if (existingItemIndex !== -1) {\\n      this._items[existingItemIndex]._setParentLink(\\n        this,\\n        makePosition(newKey, _optionalChain([this, 'access', _74 => _74._items, 'access', _75 => _75[existingItemIndex + 1], 'optionalAccess', _76 => _76._parentPos]))\\n      );\\n    }\\n    child._setParentLink(this, newKey);\\n    this._sortItems();\\n    const newIndex = this._items.indexOf(child);\\n    if (previousIndex === newIndex) {\\n      return {\\n        modified: false\\n      };\\n    }\\n    return {\\n      modified: makeUpdate(this, [moveDelta(previousIndex, newIndex, child)]),\\n      reverse: [\\n        {\\n          type: 1 /* SET_PARENT_KEY */,\\n          id: nn(child._id),\\n          parentKey: previousKey\\n        }\\n      ]\\n    };\\n  }\\n  /** @internal */\\n  _setChildKey(newKey, child, source) {\\n    if (source === 1 /* REMOTE */) {\\n      return this._applySetChildKeyRemote(newKey, child);\\n    } else if (source === 2 /* ACK */) {\\n      return this._applySetChildKeyAck(newKey, child);\\n    } else {\\n      return this._applySetChildKeyUndoRedo(newKey, child);\\n    }\\n  }\\n  /** @internal */\\n  _apply(op, isLocal) {\\n    return super._apply(op, isLocal);\\n  }\\n  /** @internal */\\n  _serialize() {\\n    if (this.parent.type !== \\\"HasParent\\\") {\\n      throw new Error(\\\"Cannot serialize LiveList if parent is missing\\\");\\n    }\\n    return {\\n      type: 1 /* LIST */,\\n      parentId: nn(this.parent.node._id, \\\"Parent node expected to have ID\\\"),\\n      parentKey: this.parent.key\\n    };\\n  }\\n  /**\\n   * Returns the number of elements.\\n   */\\n  get length() {\\n    return this._items.length;\\n  }\\n  /**\\n   * Adds one element to the end of the LiveList.\\n   * @param element The element to add to the end of the LiveList.\\n   */\\n  push(element) {\\n    _optionalChain([this, 'access', _77 => _77._pool, 'optionalAccess', _78 => _78.assertStorageIsWritable, 'call', _79 => _79()]);\\n    return this.insert(element, this.length);\\n  }\\n  /**\\n   * Inserts one element at a specified index.\\n   * @param element The element to insert.\\n   * @param index The index at which you want to insert the element.\\n   */\\n  insert(element, index) {\\n    _optionalChain([this, 'access', _80 => _80._pool, 'optionalAccess', _81 => _81.assertStorageIsWritable, 'call', _82 => _82()]);\\n    if (index < 0 || index > this._items.length) {\\n      throw new Error(\\n        `Cannot insert list item at index \\\"\\u001d${index}\\\". index should be between 0 and ${this._items.length}`\\n      );\\n    }\\n    const before2 = this._items[index - 1] ? this._items[index - 1]._parentPos : void 0;\\n    const after2 = this._items[index] ? this._items[index]._parentPos : void 0;\\n    const position = makePosition(before2, after2);\\n    const value = lsonToLiveNode(element);\\n    value._setParentLink(this, position);\\n    this._insertAndSort(value);\\n    if (this._pool && this._id) {\\n      const id = this._pool.generateId();\\n      value._attach(id, this._pool);\\n      this._pool.dispatch(\\n        value._toOps(this._id, position, this._pool),\\n        [{ type: 5 /* DELETE_CRDT */, id }],\\n        /* @__PURE__ */ new Map([\\n          [this._id, makeUpdate(this, [insertDelta(index, value)])]\\n        ])\\n      );\\n    }\\n  }\\n  /**\\n   * Move one element from one index to another.\\n   * @param index The index of the element to move\\n   * @param targetIndex The index where the element should be after moving.\\n   */\\n  move(index, targetIndex) {\\n    _optionalChain([this, 'access', _83 => _83._pool, 'optionalAccess', _84 => _84.assertStorageIsWritable, 'call', _85 => _85()]);\\n    if (targetIndex < 0) {\\n      throw new Error(\\\"targetIndex cannot be less than 0\\\");\\n    }\\n    if (targetIndex >= this._items.length) {\\n      throw new Error(\\n        \\\"targetIndex cannot be greater or equal than the list length\\\"\\n      );\\n    }\\n    if (index < 0) {\\n      throw new Error(\\\"index cannot be less than 0\\\");\\n    }\\n    if (index >= this._items.length) {\\n      throw new Error(\\\"index cannot be greater or equal than the list length\\\");\\n    }\\n    let beforePosition = null;\\n    let afterPosition = null;\\n    if (index < targetIndex) {\\n      afterPosition = targetIndex === this._items.length - 1 ? void 0 : this._items[targetIndex + 1]._parentPos;\\n      beforePosition = this._items[targetIndex]._parentPos;\\n    } else {\\n      afterPosition = this._items[targetIndex]._parentPos;\\n      beforePosition = targetIndex === 0 ? void 0 : this._items[targetIndex - 1]._parentPos;\\n    }\\n    const position = makePosition(beforePosition, afterPosition);\\n    const item = this._items[index];\\n    const previousPosition = item._getParentKeyOrThrow();\\n    item._setParentLink(this, position);\\n    this._sortItems();\\n    if (this._pool && this._id) {\\n      const storageUpdates = /* @__PURE__ */ new Map([\\n        [this._id, makeUpdate(this, [moveDelta(index, targetIndex, item)])]\\n      ]);\\n      this._pool.dispatch(\\n        [\\n          {\\n            type: 1 /* SET_PARENT_KEY */,\\n            id: nn(item._id),\\n            opId: this._pool.generateOpId(),\\n            parentKey: position\\n          }\\n        ],\\n        [\\n          {\\n            type: 1 /* SET_PARENT_KEY */,\\n            id: nn(item._id),\\n            parentKey: previousPosition\\n          }\\n        ],\\n        storageUpdates\\n      );\\n    }\\n  }\\n  /**\\n   * Deletes an element at the specified index\\n   * @param index The index of the element to delete\\n   */\\n  delete(index) {\\n    _optionalChain([this, 'access', _86 => _86._pool, 'optionalAccess', _87 => _87.assertStorageIsWritable, 'call', _88 => _88()]);\\n    if (index < 0 || index >= this._items.length) {\\n      throw new Error(\\n        `Cannot delete list item at index \\\"${index}\\\". index should be between 0 and ${this._items.length - 1}`\\n      );\\n    }\\n    const item = this._items[index];\\n    item._detach();\\n    const [prev] = this._items.splice(index, 1);\\n    this.invalidate();\\n    if (this._pool) {\\n      const childRecordId = item._id;\\n      if (childRecordId) {\\n        const storageUpdates = /* @__PURE__ */ new Map();\\n        storageUpdates.set(\\n          nn(this._id),\\n          makeUpdate(this, [deleteDelta(index, prev)])\\n        );\\n        this._pool.dispatch(\\n          [\\n            {\\n              id: childRecordId,\\n              opId: this._pool.generateOpId(),\\n              type: 5 /* DELETE_CRDT */\\n            }\\n          ],\\n          item._toOps(nn(this._id), item._getParentKeyOrThrow()),\\n          storageUpdates\\n        );\\n      }\\n    }\\n  }\\n  clear() {\\n    _optionalChain([this, 'access', _89 => _89._pool, 'optionalAccess', _90 => _90.assertStorageIsWritable, 'call', _91 => _91()]);\\n    if (this._pool) {\\n      const ops = [];\\n      const reverseOps = [];\\n      const updateDelta = [];\\n      for (const item of this._items) {\\n        item._detach();\\n        const childId = item._id;\\n        if (childId) {\\n          ops.push({\\n            type: 5 /* DELETE_CRDT */,\\n            id: childId,\\n            opId: this._pool.generateOpId()\\n          });\\n          reverseOps.push(\\n            ...item._toOps(nn(this._id), item._getParentKeyOrThrow())\\n          );\\n          updateDelta.push(deleteDelta(0, item));\\n        }\\n      }\\n      this._items = [];\\n      this.invalidate();\\n      const storageUpdates = /* @__PURE__ */ new Map();\\n      storageUpdates.set(nn(this._id), makeUpdate(this, updateDelta));\\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\\n    } else {\\n      for (const item of this._items) {\\n        item._detach();\\n      }\\n      this._items = [];\\n      this.invalidate();\\n    }\\n  }\\n  set(index, item) {\\n    _optionalChain([this, 'access', _92 => _92._pool, 'optionalAccess', _93 => _93.assertStorageIsWritable, 'call', _94 => _94()]);\\n    if (index < 0 || index >= this._items.length) {\\n      throw new Error(\\n        `Cannot set list item at index \\\"\\u001d${index}\\\". index should be between 0 and ${this._items.length - 1}`\\n      );\\n    }\\n    const existingItem = this._items[index];\\n    const position = existingItem._getParentKeyOrThrow();\\n    const existingId = existingItem._id;\\n    existingItem._detach();\\n    const value = lsonToLiveNode(item);\\n    value._setParentLink(this, position);\\n    this._items[index] = value;\\n    this.invalidate();\\n    if (this._pool && this._id) {\\n      const id = this._pool.generateId();\\n      value._attach(id, this._pool);\\n      const storageUpdates = /* @__PURE__ */ new Map();\\n      storageUpdates.set(this._id, makeUpdate(this, [setDelta(index, value)]));\\n      const ops = HACK_addIntentAndDeletedIdToOperation(\\n        value._toOps(this._id, position, this._pool),\\n        existingId\\n      );\\n      this._unacknowledgedSets.set(position, nn(ops[0].opId));\\n      const reverseOps = HACK_addIntentAndDeletedIdToOperation(\\n        existingItem._toOps(this._id, position, void 0),\\n        id\\n      );\\n      this._pool.dispatch(ops, reverseOps, storageUpdates);\\n    }\\n  }\\n  /**\\n   * Returns an Array of all the elements in the LiveList.\\n   */\\n  toArray() {\\n    return this._items.map(\\n      (entry) => liveNodeToLson(entry)\\n      //                               ^^^^^^^^\\n      //                               FIXME! This isn't safe.\\n    );\\n  }\\n  /**\\n   * Tests whether all elements pass the test implemented by the provided function.\\n   * @param predicate Function to test for each element, taking two arguments (the element and its index).\\n   * @returns true if the predicate function returns a truthy value for every element. Otherwise, false.\\n   */\\n  every(predicate) {\\n    return this.toArray().every(predicate);\\n  }\\n  /**\\n   * Creates an array with all elements that pass the test implemented by the provided function.\\n   * @param predicate Function to test each element of the LiveList. Return a value that coerces to true to keep the element, or to false otherwise.\\n   * @returns An array with the elements that pass the test.\\n   */\\n  filter(predicate) {\\n    return this.toArray().filter(predicate);\\n  }\\n  /**\\n   * Returns the first element that satisfies the provided testing function.\\n   * @param predicate Function to execute on each value.\\n   * @returns The value of the first element in the LiveList that satisfies the provided testing function. Otherwise, undefined is returned.\\n   */\\n  find(predicate) {\\n    return this.toArray().find(predicate);\\n  }\\n  /**\\n   * Returns the index of the first element in the LiveList that satisfies the provided testing function.\\n   * @param predicate Function to execute on each value until the function returns true, indicating that the satisfying element was found.\\n   * @returns The index of the first element in the LiveList that passes the test. Otherwise, -1.\\n   */\\n  findIndex(predicate) {\\n    return this.toArray().findIndex(predicate);\\n  }\\n  /**\\n   * Executes a provided function once for each element.\\n   * @param callbackfn Function to execute on each element.\\n   */\\n  forEach(callbackfn) {\\n    return this.toArray().forEach(callbackfn);\\n  }\\n  /**\\n   * Get the element at the specified index.\\n   * @param index The index on the element to get.\\n   * @returns The element at the specified index or undefined.\\n   */\\n  get(index) {\\n    if (index < 0 || index >= this._items.length) {\\n      return void 0;\\n    }\\n    return liveNodeToLson(this._items[index]);\\n  }\\n  /**\\n   * Returns the first index at which a given element can be found in the LiveList, or -1 if it is not present.\\n   * @param searchElement Element to locate.\\n   * @param fromIndex The index to start the search at.\\n   * @returns The first index of the element in the LiveList; -1 if not found.\\n   */\\n  indexOf(searchElement, fromIndex) {\\n    return this.toArray().indexOf(searchElement, fromIndex);\\n  }\\n  /**\\n   * Returns the last index at which a given element can be found in the LiveList, or -1 if it is not present. The LiveLsit is searched backwards, starting at fromIndex.\\n   * @param searchElement Element to locate.\\n   * @param fromIndex The index at which to start searching backwards.\\n   * @returns\\n   */\\n  lastIndexOf(searchElement, fromIndex) {\\n    return this.toArray().lastIndexOf(searchElement, fromIndex);\\n  }\\n  /**\\n   * Creates an array populated with the results of calling a provided function on every element.\\n   * @param callback Function that is called for every element.\\n   * @returns An array with each element being the result of the callback function.\\n   */\\n  map(callback) {\\n    return this._items.map(\\n      (entry, i) => callback(\\n        liveNodeToLson(entry),\\n        //                    ^^^^^^^^\\n        //                    FIXME! This isn't safe.\\n        i\\n      )\\n    );\\n  }\\n  /**\\n   * Tests whether at least one element in the LiveList passes the test implemented by the provided function.\\n   * @param predicate Function to test for each element.\\n   * @returns true if the callback function returns a truthy value for at least one element. Otherwise, false.\\n   */\\n  some(predicate) {\\n    return this.toArray().some(predicate);\\n  }\\n  [Symbol.iterator]() {\\n    return new LiveListIterator(this._items);\\n  }\\n  /** @internal */\\n  _createAttachItemAndSort(op, key) {\\n    const newItem = creationOpToLiveNode(op);\\n    newItem._attach(op.id, nn(this._pool));\\n    newItem._setParentLink(this, key);\\n    this._insertAndSort(newItem);\\n    const newIndex = this._indexOfPosition(key);\\n    return { newItem, newIndex };\\n  }\\n  /** @internal */\\n  _shiftItemPosition(index, key) {\\n    const shiftedPosition = makePosition(\\n      key,\\n      this._items.length > index + 1 ? _optionalChain([this, 'access', _95 => _95._items, 'access', _96 => _96[index + 1], 'optionalAccess', _97 => _97._parentPos]) : void 0\\n    );\\n    this._items[index]._setParentLink(this, shiftedPosition);\\n  }\\n  /** @internal */\\n  _toTreeNode(key) {\\n    return {\\n      type: \\\"LiveList\\\",\\n      id: _nullishCoalesce(this._id, () => ( nanoid())),\\n      key,\\n      payload: this._items.map(\\n        (item, index) => item.toTreeNode(index.toString())\\n      )\\n    };\\n  }\\n  toImmutable() {\\n    return super.toImmutable();\\n  }\\n  /** @internal */\\n  _toImmutable() {\\n    const result = this._items.map((node) => node.toImmutable());\\n    return process.env.NODE_ENV === \\\"production\\\" ? result : Object.freeze(result);\\n  }\\n  clone() {\\n    return new _LiveList(this._items.map((item) => item.clone()));\\n  }\\n};\\nvar LiveListIterator = class {\\n  constructor(items) {\\n    this._innerIterator = items[Symbol.iterator]();\\n  }\\n  [Symbol.iterator]() {\\n    return this;\\n  }\\n  next() {\\n    const result = this._innerIterator.next();\\n    if (result.done) {\\n      return {\\n        done: true,\\n        value: void 0\\n      };\\n    }\\n    const value = liveNodeToLson(result.value);\\n    return { value };\\n  }\\n};\\nfunction makeUpdate(liveList, deltaUpdates) {\\n  return {\\n    node: liveList,\\n    type: \\\"LiveList\\\",\\n    updates: deltaUpdates\\n  };\\n}\\nfunction setDelta(index, item) {\\n  return {\\n    index,\\n    type: \\\"set\\\",\\n    item: item instanceof LiveRegister ? item.data : item\\n  };\\n}\\nfunction deleteDelta(index, deletedNode) {\\n  return {\\n    type: \\\"delete\\\",\\n    index,\\n    deletedItem: deletedNode instanceof LiveRegister ? deletedNode.data : deletedNode\\n  };\\n}\\nfunction insertDelta(index, item) {\\n  return {\\n    index,\\n    type: \\\"insert\\\",\\n    item: item instanceof LiveRegister ? item.data : item\\n  };\\n}\\nfunction moveDelta(previousIndex, index, item) {\\n  return {\\n    type: \\\"move\\\",\\n    index,\\n    item: item instanceof LiveRegister ? item.data : item,\\n    previousIndex\\n  };\\n}\\nfunction HACK_addIntentAndDeletedIdToOperation(ops, deletedId) {\\n  return ops.map((op, index) => {\\n    if (index === 0) {\\n      const firstOp = op;\\n      return {\\n        ...firstOp,\\n        intent: \\\"set\\\",\\n        deletedId\\n      };\\n    } else {\\n      return op;\\n    }\\n  });\\n}\\n\\n// src/lib/freeze.ts\\nvar freeze = process.env.NODE_ENV === \\\"production\\\" ? (\\n  /* istanbul ignore next */\\n  (x) => x\\n) : Object.freeze;\\n\\n// src/crdts/LiveMap.ts\\nvar LiveMap = class _LiveMap extends AbstractCrdt {\\n  constructor(entries2) {\\n    super();\\n    this.unacknowledgedSet = /* @__PURE__ */ new Map();\\n    if (entries2) {\\n      const mappedEntries = [];\\n      for (const [key, value] of entries2) {\\n        const node = lsonToLiveNode(value);\\n        node._setParentLink(this, key);\\n        mappedEntries.push([key, node]);\\n      }\\n      this._map = new Map(mappedEntries);\\n    } else {\\n      this._map = /* @__PURE__ */ new Map();\\n    }\\n  }\\n  /**\\n   * @internal\\n   */\\n  _toOps(parentId, parentKey, pool) {\\n    if (this._id === void 0) {\\n      throw new Error(\\\"Cannot serialize item is not attached\\\");\\n    }\\n    const ops = [];\\n    const op = {\\n      id: this._id,\\n      opId: _optionalChain([pool, 'optionalAccess', _98 => _98.generateOpId, 'call', _99 => _99()]),\\n      type: 7 /* CREATE_MAP */,\\n      parentId,\\n      parentKey\\n    };\\n    ops.push(op);\\n    for (const [key, value] of this._map) {\\n      ops.push(...value._toOps(this._id, key, pool));\\n    }\\n    return ops;\\n  }\\n  /**\\n   * @internal\\n   */\\n  static _deserialize([id, _item], parentToChildren, pool) {\\n    const map = new _LiveMap();\\n    map._attach(id, pool);\\n    const children = parentToChildren.get(id);\\n    if (children === void 0) {\\n      return map;\\n    }\\n    for (const [id2, crdt] of children) {\\n      const child = deserialize([id2, crdt], parentToChildren, pool);\\n      child._setParentLink(map, crdt.parentKey);\\n      map._map.set(crdt.parentKey, child);\\n      map.invalidate();\\n    }\\n    return map;\\n  }\\n  /**\\n   * @internal\\n   */\\n  _attach(id, pool) {\\n    super._attach(id, pool);\\n    for (const [_key, value] of this._map) {\\n      if (isLiveNode(value)) {\\n        value._attach(pool.generateId(), pool);\\n      }\\n    }\\n  }\\n  /**\\n   * @internal\\n   */\\n  _attachChild(op, source) {\\n    if (this._pool === void 0) {\\n      throw new Error(\\\"Can't attach child if managed pool is not present\\\");\\n    }\\n    const { id, parentKey, opId } = op;\\n    const key = parentKey;\\n    const child = creationOpToLiveNode(op);\\n    if (this._pool.getNode(id) !== void 0) {\\n      return { modified: false };\\n    }\\n    if (source === 2 /* ACK */) {\\n      const lastUpdateOpId = this.unacknowledgedSet.get(key);\\n      if (lastUpdateOpId === opId) {\\n        this.unacknowledgedSet.delete(key);\\n        return { modified: false };\\n      } else if (lastUpdateOpId !== void 0) {\\n        return { modified: false };\\n      }\\n    } else if (source === 1 /* REMOTE */) {\\n      this.unacknowledgedSet.delete(key);\\n    }\\n    const previousValue = this._map.get(key);\\n    let reverse;\\n    if (previousValue) {\\n      const thisId = nn(this._id);\\n      reverse = previousValue._toOps(thisId, key);\\n      previousValue._detach();\\n    } else {\\n      reverse = [{ type: 5 /* DELETE_CRDT */, id }];\\n    }\\n    child._setParentLink(this, key);\\n    child._attach(id, this._pool);\\n    this._map.set(key, child);\\n    this.invalidate();\\n    return {\\n      modified: {\\n        node: this,\\n        type: \\\"LiveMap\\\",\\n        updates: { [key]: { type: \\\"update\\\" } }\\n      },\\n      reverse\\n    };\\n  }\\n  /**\\n   * @internal\\n   */\\n  _detach() {\\n    super._detach();\\n    for (const item of this._map.values()) {\\n      item._detach();\\n    }\\n  }\\n  /**\\n   * @internal\\n   */\\n  _detachChild(child) {\\n    const id = nn(this._id);\\n    const parentKey = nn(child._parentKey);\\n    const reverse = child._toOps(id, parentKey, this._pool);\\n    for (const [key, value] of this._map) {\\n      if (value === child) {\\n        this._map.delete(key);\\n        this.invalidate();\\n      }\\n    }\\n    child._detach();\\n    const storageUpdate = {\\n      node: this,\\n      type: \\\"LiveMap\\\",\\n      updates: { [parentKey]: { type: \\\"delete\\\" } }\\n    };\\n    return { modified: storageUpdate, reverse };\\n  }\\n  /**\\n   * @internal\\n   */\\n  _serialize() {\\n    if (this.parent.type !== \\\"HasParent\\\") {\\n      throw new Error(\\\"Cannot serialize LiveMap if parent is missing\\\");\\n    }\\n    return {\\n      type: 2 /* MAP */,\\n      parentId: nn(this.parent.node._id, \\\"Parent node expected to have ID\\\"),\\n      parentKey: this.parent.key\\n    };\\n  }\\n  /**\\n   * Returns a specified element from the LiveMap.\\n   * @param key The key of the element to return.\\n   * @returns The element associated with the specified key, or undefined if the key can't be found in the LiveMap.\\n   */\\n  get(key) {\\n    const value = this._map.get(key);\\n    if (value === void 0) {\\n      return void 0;\\n    }\\n    return liveNodeToLson(value);\\n  }\\n  /**\\n   * Adds or updates an element with a specified key and a value.\\n   * @param key The key of the element to add. Should be a string.\\n   * @param value The value of the element to add. Should be serializable to JSON.\\n   */\\n  set(key, value) {\\n    _optionalChain([this, 'access', _100 => _100._pool, 'optionalAccess', _101 => _101.assertStorageIsWritable, 'call', _102 => _102()]);\\n    const oldValue = this._map.get(key);\\n    if (oldValue) {\\n      oldValue._detach();\\n    }\\n    const item = lsonToLiveNode(value);\\n    item._setParentLink(this, key);\\n    this._map.set(key, item);\\n    this.invalidate();\\n    if (this._pool && this._id) {\\n      const id = this._pool.generateId();\\n      item._attach(id, this._pool);\\n      const storageUpdates = /* @__PURE__ */ new Map();\\n      storageUpdates.set(this._id, {\\n        node: this,\\n        type: \\\"LiveMap\\\",\\n        updates: { [key]: { type: \\\"update\\\" } }\\n      });\\n      const ops = item._toOps(this._id, key, this._pool);\\n      this.unacknowledgedSet.set(key, nn(ops[0].opId));\\n      this._pool.dispatch(\\n        item._toOps(this._id, key, this._pool),\\n        oldValue ? oldValue._toOps(this._id, key) : [{ type: 5 /* DELETE_CRDT */, id }],\\n        storageUpdates\\n      );\\n    }\\n  }\\n  /**\\n   * Returns the number of elements in the LiveMap.\\n   */\\n  get size() {\\n    return this._map.size;\\n  }\\n  /**\\n   * Returns a boolean indicating whether an element with the specified key exists or not.\\n   * @param key The key of the element to test for presence.\\n   */\\n  has(key) {\\n    return this._map.has(key);\\n  }\\n  /**\\n   * Removes the specified element by key.\\n   * @param key The key of the element to remove.\\n   * @returns true if an element existed and has been removed, or false if the element does not exist.\\n   */\\n  delete(key) {\\n    _optionalChain([this, 'access', _103 => _103._pool, 'optionalAccess', _104 => _104.assertStorageIsWritable, 'call', _105 => _105()]);\\n    const item = this._map.get(key);\\n    if (item === void 0) {\\n      return false;\\n    }\\n    item._detach();\\n    this._map.delete(key);\\n    this.invalidate();\\n    if (this._pool && item._id) {\\n      const thisId = nn(this._id);\\n      const storageUpdates = /* @__PURE__ */ new Map();\\n      storageUpdates.set(thisId, {\\n        node: this,\\n        type: \\\"LiveMap\\\",\\n        updates: { [key]: { type: \\\"delete\\\" } }\\n      });\\n      this._pool.dispatch(\\n        [\\n          {\\n            type: 5 /* DELETE_CRDT */,\\n            id: item._id,\\n            opId: this._pool.generateOpId()\\n          }\\n        ],\\n        item._toOps(thisId, key),\\n        storageUpdates\\n      );\\n    }\\n    return true;\\n  }\\n  /**\\n   * Returns a new Iterator object that contains the [key, value] pairs for each element.\\n   */\\n  entries() {\\n    const innerIterator = this._map.entries();\\n    return {\\n      [Symbol.iterator]() {\\n        return this;\\n      },\\n      next() {\\n        const iteratorValue = innerIterator.next();\\n        if (iteratorValue.done) {\\n          return {\\n            done: true,\\n            value: void 0\\n          };\\n        }\\n        const entry = iteratorValue.value;\\n        const key = entry[0];\\n        const value = liveNodeToLson(iteratorValue.value[1]);\\n        return {\\n          value: [key, value]\\n        };\\n      }\\n    };\\n  }\\n  /**\\n   * Same function object as the initial value of the entries method.\\n   */\\n  [Symbol.iterator]() {\\n    return this.entries();\\n  }\\n  /**\\n   * Returns a new Iterator object that contains the keys for each element.\\n   */\\n  keys() {\\n    return this._map.keys();\\n  }\\n  /**\\n   * Returns a new Iterator object that contains the values for each element.\\n   */\\n  values() {\\n    const innerIterator = this._map.values();\\n    return {\\n      [Symbol.iterator]() {\\n        return this;\\n      },\\n      next() {\\n        const iteratorValue = innerIterator.next();\\n        if (iteratorValue.done) {\\n          return {\\n            done: true,\\n            value: void 0\\n          };\\n        }\\n        const value = liveNodeToLson(iteratorValue.value);\\n        return { value };\\n      }\\n    };\\n  }\\n  /**\\n   * Executes a provided function once per each key/value pair in the Map object, in insertion order.\\n   * @param callback Function to execute for each entry in the map.\\n   */\\n  forEach(callback) {\\n    for (const entry of this) {\\n      callback(entry[1], entry[0], this);\\n    }\\n  }\\n  /** @internal */\\n  _toTreeNode(key) {\\n    return {\\n      type: \\\"LiveMap\\\",\\n      id: _nullishCoalesce(this._id, () => ( nanoid())),\\n      key,\\n      payload: Array.from(this._map.entries()).map(\\n        ([key2, val]) => val.toTreeNode(key2)\\n      )\\n    };\\n  }\\n  toImmutable() {\\n    return super.toImmutable();\\n  }\\n  /** @internal */\\n  _toImmutable() {\\n    const result = /* @__PURE__ */ new Map();\\n    for (const [key, value] of this._map) {\\n      result.set(key, value.toImmutable());\\n    }\\n    return freeze(result);\\n  }\\n  clone() {\\n    return new _LiveMap(\\n      Array.from(this._map).map(([key, node]) => [key, node.clone()])\\n    );\\n  }\\n};\\n\\n// src/crdts/LiveObject.ts\\nvar LiveObject = class _LiveObject extends AbstractCrdt {\\n  /** @internal */\\n  static _buildRootAndParentToChildren(items) {\\n    const parentToChildren = /* @__PURE__ */ new Map();\\n    let root = null;\\n    for (const [id, crdt] of items) {\\n      if (isRootCrdt(crdt)) {\\n        root = [id, crdt];\\n      } else {\\n        const tuple = [id, crdt];\\n        const children = parentToChildren.get(crdt.parentId);\\n        if (children !== void 0) {\\n          children.push(tuple);\\n        } else {\\n          parentToChildren.set(crdt.parentId, [tuple]);\\n        }\\n      }\\n    }\\n    if (root === null) {\\n      throw new Error(\\\"Root can't be null\\\");\\n    }\\n    return [root, parentToChildren];\\n  }\\n  /** @internal */\\n  static _fromItems(items, pool) {\\n    const [root, parentToChildren] = _LiveObject._buildRootAndParentToChildren(items);\\n    return _LiveObject._deserialize(\\n      root,\\n      parentToChildren,\\n      pool\\n    );\\n  }\\n  constructor(obj = {}) {\\n    super();\\n    this._propToLastUpdate = /* @__PURE__ */ new Map();\\n    const o = compactObject(obj);\\n    for (const key of Object.keys(o)) {\\n      const value = o[key];\\n      if (isLiveNode(value)) {\\n        value._setParentLink(this, key);\\n      }\\n    }\\n    this._map = new Map(Object.entries(o));\\n  }\\n  /** @internal */\\n  _toOps(parentId, parentKey, pool) {\\n    if (this._id === void 0) {\\n      throw new Error(\\\"Cannot serialize item is not attached\\\");\\n    }\\n    const opId = _optionalChain([pool, 'optionalAccess', _106 => _106.generateOpId, 'call', _107 => _107()]);\\n    const ops = [];\\n    const op = {\\n      type: 4 /* CREATE_OBJECT */,\\n      id: this._id,\\n      opId,\\n      parentId,\\n      parentKey,\\n      data: {}\\n    };\\n    ops.push(op);\\n    for (const [key, value] of this._map) {\\n      if (isLiveNode(value)) {\\n        ops.push(...value._toOps(this._id, key, pool));\\n      } else {\\n        op.data[key] = value;\\n      }\\n    }\\n    return ops;\\n  }\\n  /** @internal */\\n  static _deserialize([id, item], parentToChildren, pool) {\\n    const liveObj = new _LiveObject(item.data);\\n    liveObj._attach(id, pool);\\n    return this._deserializeChildren(liveObj, parentToChildren, pool);\\n  }\\n  /** @internal */\\n  static _deserializeChildren(liveObj, parentToChildren, pool) {\\n    const children = parentToChildren.get(nn(liveObj._id));\\n    if (children === void 0) {\\n      return liveObj;\\n    }\\n    for (const [id, crdt] of children) {\\n      const child = deserializeToLson([id, crdt], parentToChildren, pool);\\n      if (isLiveStructure(child)) {\\n        child._setParentLink(liveObj, crdt.parentKey);\\n      }\\n      liveObj._map.set(crdt.parentKey, child);\\n      liveObj.invalidate();\\n    }\\n    return liveObj;\\n  }\\n  /** @internal */\\n  _attach(id, pool) {\\n    super._attach(id, pool);\\n    for (const [_key, value] of this._map) {\\n      if (isLiveNode(value)) {\\n        value._attach(pool.generateId(), pool);\\n      }\\n    }\\n  }\\n  /** @internal */\\n  _attachChild(op, source) {\\n    if (this._pool === void 0) {\\n      throw new Error(\\\"Can't attach child if managed pool is not present\\\");\\n    }\\n    const { id, opId, parentKey: key } = op;\\n    const child = creationOpToLson(op);\\n    if (this._pool.getNode(id) !== void 0) {\\n      if (this._propToLastUpdate.get(key) === opId) {\\n        this._propToLastUpdate.delete(key);\\n      }\\n      return { modified: false };\\n    }\\n    if (source === 0 /* UNDOREDO_RECONNECT */) {\\n      this._propToLastUpdate.set(key, nn(opId));\\n    } else if (this._propToLastUpdate.get(key) === void 0) {\\n    } else if (this._propToLastUpdate.get(key) === opId) {\\n      this._propToLastUpdate.delete(key);\\n      return { modified: false };\\n    } else {\\n      return { modified: false };\\n    }\\n    const thisId = nn(this._id);\\n    const previousValue = this._map.get(key);\\n    let reverse;\\n    if (isLiveNode(previousValue)) {\\n      reverse = previousValue._toOps(thisId, key);\\n      previousValue._detach();\\n    } else if (previousValue === void 0) {\\n      reverse = [{ type: 6 /* DELETE_OBJECT_KEY */, id: thisId, key }];\\n    } else {\\n      reverse = [\\n        {\\n          type: 3 /* UPDATE_OBJECT */,\\n          id: thisId,\\n          data: { [key]: previousValue }\\n        }\\n      ];\\n    }\\n    this._map.set(key, child);\\n    this.invalidate();\\n    if (isLiveStructure(child)) {\\n      child._setParentLink(this, key);\\n      child._attach(id, this._pool);\\n    }\\n    return {\\n      reverse,\\n      modified: {\\n        node: this,\\n        type: \\\"LiveObject\\\",\\n        updates: { [key]: { type: \\\"update\\\" } }\\n      }\\n    };\\n  }\\n  /** @internal */\\n  _detachChild(child) {\\n    if (child) {\\n      const id = nn(this._id);\\n      const parentKey = nn(child._parentKey);\\n      const reverse = child._toOps(id, parentKey, this._pool);\\n      for (const [key, value] of this._map) {\\n        if (value === child) {\\n          this._map.delete(key);\\n          this.invalidate();\\n        }\\n      }\\n      child._detach();\\n      const storageUpdate = {\\n        node: this,\\n        type: \\\"LiveObject\\\",\\n        updates: {\\n          [parentKey]: { type: \\\"delete\\\" }\\n        }\\n      };\\n      return { modified: storageUpdate, reverse };\\n    }\\n    return { modified: false };\\n  }\\n  /**\\n   * @internal\\n   */\\n  _detach() {\\n    super._detach();\\n    for (const value of this._map.values()) {\\n      if (isLiveNode(value)) {\\n        value._detach();\\n      }\\n    }\\n  }\\n  /** @internal */\\n  _apply(op, isLocal) {\\n    if (op.type === 3 /* UPDATE_OBJECT */) {\\n      return this._applyUpdate(op, isLocal);\\n    } else if (op.type === 6 /* DELETE_OBJECT_KEY */) {\\n      return this._applyDeleteObjectKey(op, isLocal);\\n    }\\n    return super._apply(op, isLocal);\\n  }\\n  /**\\n   * @internal\\n   */\\n  _serialize() {\\n    const data = {};\\n    for (const [key, value] of this._map) {\\n      if (!isLiveNode(value)) {\\n        data[key] = value;\\n      }\\n    }\\n    if (this.parent.type === \\\"HasParent\\\" && this.parent.node._id) {\\n      return {\\n        type: 0 /* OBJECT */,\\n        parentId: this.parent.node._id,\\n        parentKey: this.parent.key,\\n        data\\n      };\\n    } else {\\n      return {\\n        type: 0 /* OBJECT */,\\n        data\\n      };\\n    }\\n  }\\n  /** @internal */\\n  _applyUpdate(op, isLocal) {\\n    let isModified = false;\\n    const id = nn(this._id);\\n    const reverse = [];\\n    const reverseUpdate = {\\n      type: 3 /* UPDATE_OBJECT */,\\n      id,\\n      data: {}\\n    };\\n    for (const key in op.data) {\\n      const oldValue = this._map.get(key);\\n      if (isLiveNode(oldValue)) {\\n        reverse.push(...oldValue._toOps(id, key));\\n        oldValue._detach();\\n      } else if (oldValue !== void 0) {\\n        reverseUpdate.data[key] = oldValue;\\n      } else if (oldValue === void 0) {\\n        reverse.push({ type: 6 /* DELETE_OBJECT_KEY */, id, key });\\n      }\\n    }\\n    const updateDelta = {};\\n    for (const key in op.data) {\\n      const value = op.data[key];\\n      if (value === void 0) {\\n        continue;\\n      }\\n      if (isLocal) {\\n        this._propToLastUpdate.set(key, nn(op.opId));\\n      } else if (this._propToLastUpdate.get(key) === void 0) {\\n        isModified = true;\\n      } else if (this._propToLastUpdate.get(key) === op.opId) {\\n        this._propToLastUpdate.delete(key);\\n        continue;\\n      } else {\\n        continue;\\n      }\\n      const oldValue = this._map.get(key);\\n      if (isLiveNode(oldValue)) {\\n        oldValue._detach();\\n      }\\n      isModified = true;\\n      updateDelta[key] = { type: \\\"update\\\" };\\n      this._map.set(key, value);\\n      this.invalidate();\\n    }\\n    if (Object.keys(reverseUpdate.data).length !== 0) {\\n      reverse.unshift(reverseUpdate);\\n    }\\n    return isModified ? {\\n      modified: {\\n        node: this,\\n        type: \\\"LiveObject\\\",\\n        updates: updateDelta\\n      },\\n      reverse\\n    } : { modified: false };\\n  }\\n  /** @internal */\\n  _applyDeleteObjectKey(op, isLocal) {\\n    const key = op.key;\\n    if (this._map.has(key) === false) {\\n      return { modified: false };\\n    }\\n    if (!isLocal && this._propToLastUpdate.get(key) !== void 0) {\\n      return { modified: false };\\n    }\\n    const oldValue = this._map.get(key);\\n    const id = nn(this._id);\\n    let reverse = [];\\n    if (isLiveNode(oldValue)) {\\n      reverse = oldValue._toOps(id, op.key);\\n      oldValue._detach();\\n    } else if (oldValue !== void 0) {\\n      reverse = [\\n        {\\n          type: 3 /* UPDATE_OBJECT */,\\n          id,\\n          data: { [key]: oldValue }\\n        }\\n      ];\\n    }\\n    this._map.delete(key);\\n    this.invalidate();\\n    return {\\n      modified: {\\n        node: this,\\n        type: \\\"LiveObject\\\",\\n        updates: { [op.key]: { type: \\\"delete\\\" } }\\n      },\\n      reverse\\n    };\\n  }\\n  /**\\n   * Transform the LiveObject into a javascript object\\n   */\\n  toObject() {\\n    return Object.fromEntries(this._map);\\n  }\\n  /**\\n   * Adds or updates a property with a specified key and a value.\\n   * @param key The key of the property to add\\n   * @param value The value of the property to add\\n   */\\n  set(key, value) {\\n    _optionalChain([this, 'access', _108 => _108._pool, 'optionalAccess', _109 => _109.assertStorageIsWritable, 'call', _110 => _110()]);\\n    this.update({ [key]: value });\\n  }\\n  /**\\n   * Returns a specified property from the LiveObject.\\n   * @param key The key of the property to get\\n   */\\n  get(key) {\\n    return this._map.get(key);\\n  }\\n  /**\\n   * Deletes a key from the LiveObject\\n   * @param key The key of the property to delete\\n   */\\n  delete(key) {\\n    _optionalChain([this, 'access', _111 => _111._pool, 'optionalAccess', _112 => _112.assertStorageIsWritable, 'call', _113 => _113()]);\\n    const keyAsString = key;\\n    const oldValue = this._map.get(keyAsString);\\n    if (oldValue === void 0) {\\n      return;\\n    }\\n    if (this._pool === void 0 || this._id === void 0) {\\n      if (isLiveNode(oldValue)) {\\n        oldValue._detach();\\n      }\\n      this._map.delete(keyAsString);\\n      this.invalidate();\\n      return;\\n    }\\n    let reverse;\\n    if (isLiveNode(oldValue)) {\\n      oldValue._detach();\\n      reverse = oldValue._toOps(this._id, keyAsString);\\n    } else {\\n      reverse = [\\n        {\\n          type: 3 /* UPDATE_OBJECT */,\\n          data: { [keyAsString]: oldValue },\\n          id: this._id\\n        }\\n      ];\\n    }\\n    this._map.delete(keyAsString);\\n    this.invalidate();\\n    const storageUpdates = /* @__PURE__ */ new Map();\\n    storageUpdates.set(this._id, {\\n      node: this,\\n      type: \\\"LiveObject\\\",\\n      updates: { [key]: { type: \\\"delete\\\" } }\\n    });\\n    this._pool.dispatch(\\n      [\\n        {\\n          type: 6 /* DELETE_OBJECT_KEY */,\\n          key: keyAsString,\\n          id: this._id,\\n          opId: this._pool.generateOpId()\\n        }\\n      ],\\n      reverse,\\n      storageUpdates\\n    );\\n  }\\n  /**\\n   * Adds or updates multiple properties at once with an object.\\n   * @param patch The object used to overrides properties\\n   */\\n  update(patch) {\\n    _optionalChain([this, 'access', _114 => _114._pool, 'optionalAccess', _115 => _115.assertStorageIsWritable, 'call', _116 => _116()]);\\n    if (this._pool === void 0 || this._id === void 0) {\\n      for (const key in patch) {\\n        const newValue = patch[key];\\n        if (newValue === void 0) {\\n          continue;\\n        }\\n        const oldValue = this._map.get(key);\\n        if (isLiveNode(oldValue)) {\\n          oldValue._detach();\\n        }\\n        if (isLiveNode(newValue)) {\\n          newValue._setParentLink(this, key);\\n        }\\n        this._map.set(key, newValue);\\n        this.invalidate();\\n      }\\n      return;\\n    }\\n    const ops = [];\\n    const reverseOps = [];\\n    const opId = this._pool.generateOpId();\\n    const updatedProps = {};\\n    const reverseUpdateOp = {\\n      id: this._id,\\n      type: 3 /* UPDATE_OBJECT */,\\n      data: {}\\n    };\\n    const updateDelta = {};\\n    for (const key in patch) {\\n      const newValue = patch[key];\\n      if (newValue === void 0) {\\n        continue;\\n      }\\n      const oldValue = this._map.get(key);\\n      if (isLiveNode(oldValue)) {\\n        reverseOps.push(...oldValue._toOps(this._id, key));\\n        oldValue._detach();\\n      } else if (oldValue === void 0) {\\n        reverseOps.push({ type: 6 /* DELETE_OBJECT_KEY */, id: this._id, key });\\n      } else {\\n        reverseUpdateOp.data[key] = oldValue;\\n      }\\n      if (isLiveNode(newValue)) {\\n        newValue._setParentLink(this, key);\\n        newValue._attach(this._pool.generateId(), this._pool);\\n        const newAttachChildOps = newValue._toOps(this._id, key, this._pool);\\n        const createCrdtOp = newAttachChildOps.find(\\n          (op) => op.parentId === this._id\\n        );\\n        if (createCrdtOp) {\\n          this._propToLastUpdate.set(key, nn(createCrdtOp.opId));\\n        }\\n        ops.push(...newAttachChildOps);\\n      } else {\\n        updatedProps[key] = newValue;\\n        this._propToLastUpdate.set(key, opId);\\n      }\\n      this._map.set(key, newValue);\\n      this.invalidate();\\n      updateDelta[key] = { type: \\\"update\\\" };\\n    }\\n    if (Object.keys(reverseUpdateOp.data).length !== 0) {\\n      reverseOps.unshift(reverseUpdateOp);\\n    }\\n    if (Object.keys(updatedProps).length !== 0) {\\n      ops.unshift({\\n        opId,\\n        id: this._id,\\n        type: 3 /* UPDATE_OBJECT */,\\n        data: updatedProps\\n      });\\n    }\\n    const storageUpdates = /* @__PURE__ */ new Map();\\n    storageUpdates.set(this._id, {\\n      node: this,\\n      type: \\\"LiveObject\\\",\\n      updates: updateDelta\\n    });\\n    this._pool.dispatch(ops, reverseOps, storageUpdates);\\n  }\\n  toImmutable() {\\n    return super.toImmutable();\\n  }\\n  /** @internal */\\n  toTreeNode(key) {\\n    return super.toTreeNode(key);\\n  }\\n  /** @internal */\\n  _toTreeNode(key) {\\n    const nodeId = _nullishCoalesce(this._id, () => ( nanoid()));\\n    return {\\n      type: \\\"LiveObject\\\",\\n      id: nodeId,\\n      key,\\n      payload: Array.from(this._map.entries()).map(\\n        ([key2, value]) => isLiveNode(value) ? value.toTreeNode(key2) : { type: \\\"Json\\\", id: `${nodeId}:${key2}`, key: key2, payload: value }\\n      )\\n    };\\n  }\\n  /** @internal */\\n  _toImmutable() {\\n    const result = {};\\n    for (const [key, val] of this._map) {\\n      result[key] = isLiveStructure(val) ? val.toImmutable() : val;\\n    }\\n    return process.env.NODE_ENV === \\\"production\\\" ? result : Object.freeze(result);\\n  }\\n  clone() {\\n    return new _LiveObject(\\n      Object.fromEntries(\\n        Array.from(this._map).map(([key, value]) => [\\n          key,\\n          isLiveStructure(value) ? value.clone() : deepClone(value)\\n        ])\\n      )\\n    );\\n  }\\n};\\n\\n// src/crdts/liveblocks-helpers.ts\\nfunction creationOpToLiveNode(op) {\\n  return lsonToLiveNode(creationOpToLson(op));\\n}\\nfunction creationOpToLson(op) {\\n  switch (op.type) {\\n    case 8 /* CREATE_REGISTER */:\\n      return op.data;\\n    case 4 /* CREATE_OBJECT */:\\n      return new LiveObject(op.data);\\n    case 7 /* CREATE_MAP */:\\n      return new LiveMap();\\n    case 2 /* CREATE_LIST */:\\n      return new LiveList([]);\\n    default:\\n      return assertNever(op, \\\"Unknown creation Op\\\");\\n  }\\n}\\nfunction isSameNodeOrChildOf(node, parent) {\\n  if (node === parent) {\\n    return true;\\n  }\\n  if (node.parent.type === \\\"HasParent\\\") {\\n    return isSameNodeOrChildOf(node.parent.node, parent);\\n  }\\n  return false;\\n}\\nfunction deserialize([id, crdt], parentToChildren, pool) {\\n  switch (crdt.type) {\\n    case 0 /* OBJECT */: {\\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\\n    }\\n    case 1 /* LIST */: {\\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\\n    }\\n    case 2 /* MAP */: {\\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\\n    }\\n    case 3 /* REGISTER */: {\\n      return LiveRegister._deserialize([id, crdt], parentToChildren, pool);\\n    }\\n    default: {\\n      throw new Error(\\\"Unexpected CRDT type\\\");\\n    }\\n  }\\n}\\nfunction deserializeToLson([id, crdt], parentToChildren, pool) {\\n  switch (crdt.type) {\\n    case 0 /* OBJECT */: {\\n      return LiveObject._deserialize([id, crdt], parentToChildren, pool);\\n    }\\n    case 1 /* LIST */: {\\n      return LiveList._deserialize([id, crdt], parentToChildren, pool);\\n    }\\n    case 2 /* MAP */: {\\n      return LiveMap._deserialize([id, crdt], parentToChildren, pool);\\n    }\\n    case 3 /* REGISTER */: {\\n      return crdt.data;\\n    }\\n    default: {\\n      throw new Error(\\\"Unexpected CRDT type\\\");\\n    }\\n  }\\n}\\nfunction isLiveStructure(value) {\\n  return isLiveList(value) || isLiveMap(value) || isLiveObject(value);\\n}\\nfunction isLiveNode(value) {\\n  return isLiveStructure(value) || isLiveRegister(value);\\n}\\nfunction isLiveList(value) {\\n  return value instanceof LiveList;\\n}\\nfunction isLiveMap(value) {\\n  return value instanceof LiveMap;\\n}\\nfunction isLiveObject(value) {\\n  return value instanceof LiveObject;\\n}\\nfunction isLiveRegister(value) {\\n  return value instanceof LiveRegister;\\n}\\nfunction cloneLson(value) {\\n  return value === void 0 ? void 0 : isLiveStructure(value) ? value.clone() : deepClone(value);\\n}\\nfunction liveNodeToLson(obj) {\\n  if (obj instanceof LiveRegister) {\\n    return obj.data;\\n  } else if (obj instanceof LiveList || obj instanceof LiveMap || obj instanceof LiveObject) {\\n    return obj;\\n  } else {\\n    return assertNever(obj, \\\"Unknown AbstractCrdt\\\");\\n  }\\n}\\nfunction lsonToLiveNode(value) {\\n  if (value instanceof LiveObject || value instanceof LiveMap || value instanceof LiveList) {\\n    return value;\\n  } else {\\n    return new LiveRegister(value);\\n  }\\n}\\nfunction getTreesDiffOperations(currentItems, newItems) {\\n  const ops = [];\\n  currentItems.forEach((_, id) => {\\n    if (!newItems.get(id)) {\\n      ops.push({\\n        type: 5 /* DELETE_CRDT */,\\n        id\\n      });\\n    }\\n  });\\n  newItems.forEach((crdt, id) => {\\n    const currentCrdt = currentItems.get(id);\\n    if (currentCrdt) {\\n      if (crdt.type === 0 /* OBJECT */) {\\n        if (currentCrdt.type !== 0 /* OBJECT */ || JSON.stringify(crdt.data) !== JSON.stringify(currentCrdt.data)) {\\n          ops.push({\\n            type: 3 /* UPDATE_OBJECT */,\\n            id,\\n            data: crdt.data\\n          });\\n        }\\n      }\\n      if (crdt.parentKey !== currentCrdt.parentKey) {\\n        ops.push({\\n          type: 1 /* SET_PARENT_KEY */,\\n          id,\\n          parentKey: nn(crdt.parentKey, \\\"Parent key must not be missing\\\")\\n        });\\n      }\\n    } else {\\n      switch (crdt.type) {\\n        case 3 /* REGISTER */:\\n          ops.push({\\n            type: 8 /* CREATE_REGISTER */,\\n            id,\\n            parentId: crdt.parentId,\\n            parentKey: crdt.parentKey,\\n            data: crdt.data\\n          });\\n          break;\\n        case 1 /* LIST */:\\n          ops.push({\\n            type: 2 /* CREATE_LIST */,\\n            id,\\n            parentId: crdt.parentId,\\n            parentKey: crdt.parentKey\\n          });\\n          break;\\n        case 0 /* OBJECT */:\\n          if (crdt.parentId === void 0 || crdt.parentKey === void 0) {\\n            throw new Error(\\n              \\\"Internal error. Cannot serialize storage root into an operation\\\"\\n            );\\n          }\\n          ops.push({\\n            type: 4 /* CREATE_OBJECT */,\\n            id,\\n            parentId: crdt.parentId,\\n            parentKey: crdt.parentKey,\\n            data: crdt.data\\n          });\\n          break;\\n        case 2 /* MAP */:\\n          ops.push({\\n            type: 7 /* CREATE_MAP */,\\n            id,\\n            parentId: crdt.parentId,\\n            parentKey: crdt.parentKey\\n          });\\n          break;\\n      }\\n    }\\n  });\\n  return ops;\\n}\\nfunction mergeObjectStorageUpdates(first, second) {\\n  const updates = first.updates;\\n  for (const [key, value] of entries(second.updates)) {\\n    updates[key] = value;\\n  }\\n  return {\\n    ...second,\\n    updates\\n  };\\n}\\nfunction mergeMapStorageUpdates(first, second) {\\n  const updates = first.updates;\\n  for (const [key, value] of entries(second.updates)) {\\n    updates[key] = value;\\n  }\\n  return {\\n    ...second,\\n    updates\\n  };\\n}\\nfunction mergeListStorageUpdates(first, second) {\\n  const updates = first.updates;\\n  return {\\n    ...second,\\n    updates: updates.concat(second.updates)\\n  };\\n}\\nfunction mergeStorageUpdates(first, second) {\\n  if (first === void 0) {\\n    return second;\\n  }\\n  if (first.type === \\\"LiveObject\\\" && second.type === \\\"LiveObject\\\") {\\n    return mergeObjectStorageUpdates(first, second);\\n  } else if (first.type === \\\"LiveMap\\\" && second.type === \\\"LiveMap\\\") {\\n    return mergeMapStorageUpdates(first, second);\\n  } else if (first.type === \\\"LiveList\\\" && second.type === \\\"LiveList\\\") {\\n    return mergeListStorageUpdates(first, second);\\n  } else {\\n  }\\n  return second;\\n}\\nfunction isPlain(value) {\\n  const type = typeof value;\\n  return value === void 0 || value === null || type === \\\"string\\\" || type === \\\"boolean\\\" || type === \\\"number\\\" || Array.isArray(value) || isPlainObject(value);\\n}\\nfunction findNonSerializableValue(value, path = \\\"\\\") {\\n  if (!isPlain) {\\n    return {\\n      path: path || \\\"root\\\",\\n      value\\n    };\\n  }\\n  if (typeof value !== \\\"object\\\" || value === null) {\\n    return false;\\n  }\\n  for (const [key, nestedValue] of Object.entries(value)) {\\n    const nestedPath = path ? path + \\\".\\\" + key : key;\\n    if (!isPlain(nestedValue)) {\\n      return {\\n        path: nestedPath,\\n        value: nestedValue\\n      };\\n    }\\n    if (typeof nestedValue === \\\"object\\\") {\\n      const nonSerializableNestedValue = findNonSerializableValue(\\n        nestedValue,\\n        nestedPath\\n      );\\n      if (nonSerializableNestedValue) {\\n        return nonSerializableNestedValue;\\n      }\\n    }\\n  }\\n  return false;\\n}\\n\\n// src/lib/chunk.ts\\nfunction chunk(array, size) {\\n  const chunks = [];\\n  for (let i = 0, j = array.length; i < j; i += size) {\\n    chunks.push(array.slice(i, i + size));\\n  }\\n  return chunks;\\n}\\n\\n// src/lib/createIds.ts\\nvar THREAD_ID_PREFIX = \\\"th\\\";\\nvar COMMENT_ID_PREFIX = \\\"cm\\\";\\nvar COMMENT_ATTACHMENT_ID_PREFIX = \\\"at\\\";\\nvar INBOX_NOTIFICATION_ID_PREFIX = \\\"in\\\";\\nfunction createOptimisticId(prefix) {\\n  return `${prefix}_${nanoid()}`;\\n}\\nfunction createThreadId() {\\n  return createOptimisticId(THREAD_ID_PREFIX);\\n}\\nfunction createCommentId() {\\n  return createOptimisticId(COMMENT_ID_PREFIX);\\n}\\nfunction createCommentAttachmentId() {\\n  return createOptimisticId(COMMENT_ATTACHMENT_ID_PREFIX);\\n}\\nfunction createInboxNotificationId() {\\n  return createOptimisticId(INBOX_NOTIFICATION_ID_PREFIX);\\n}\\n\\n// src/lib/debug.ts\\nfunction captureStackTrace(msg, traceRoot) {\\n  const errorLike = { name: msg };\\n  if (typeof Error.captureStackTrace !== \\\"function\\\") {\\n    return void 0;\\n  }\\n  Error.captureStackTrace(errorLike, traceRoot);\\n  return errorLike.stack;\\n}\\n\\n// src/lib/Json.ts\\nfunction isJsonScalar(data) {\\n  return data === null || typeof data === \\\"string\\\" || typeof data === \\\"number\\\" || typeof data === \\\"boolean\\\";\\n}\\nfunction isJsonArray(data) {\\n  return Array.isArray(data);\\n}\\nfunction isJsonObject(data) {\\n  return !isJsonScalar(data) && !isJsonArray(data);\\n}\\n\\n// src/lib/objectToQuery.ts\\nvar identifierRegex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\\nfunction objectToQuery(obj) {\\n  let filterList = [];\\n  const entries2 = Object.entries(obj);\\n  const keyValuePairs = [];\\n  const keyValuePairsWithOperator = [];\\n  const indexedKeys = [];\\n  entries2.forEach(([key, value]) => {\\n    if (!identifierRegex.test(key)) {\\n      throw new Error(\\\"Key must only contain letters, numbers, _\\\");\\n    }\\n    if (isSimpleValue(value)) {\\n      keyValuePairs.push([key, value]);\\n    } else if (isValueWithOperator(value)) {\\n      keyValuePairsWithOperator.push([key, value]);\\n    } else if (typeof value === \\\"object\\\" && !(\\\"startsWith\\\" in value)) {\\n      indexedKeys.push([key, value]);\\n    }\\n  });\\n  filterList = [\\n    ...getFiltersFromKeyValuePairs(keyValuePairs),\\n    ...getFiltersFromKeyValuePairsWithOperator(keyValuePairsWithOperator)\\n  ];\\n  indexedKeys.forEach(([key, value]) => {\\n    const nestedEntries = Object.entries(value);\\n    const nKeyValuePairs = [];\\n    const nKeyValuePairsWithOperator = [];\\n    nestedEntries.forEach(([nestedKey, nestedValue]) => {\\n      if (isStringEmpty(nestedKey)) {\\n        throw new Error(\\\"Key cannot be empty\\\");\\n      }\\n      if (isSimpleValue(nestedValue)) {\\n        nKeyValuePairs.push([formatFilterKey(key, nestedKey), nestedValue]);\\n      } else if (isValueWithOperator(nestedValue)) {\\n        nKeyValuePairsWithOperator.push([\\n          formatFilterKey(key, nestedKey),\\n          nestedValue\\n        ]);\\n      }\\n    });\\n    filterList = [\\n      ...filterList,\\n      ...getFiltersFromKeyValuePairs(nKeyValuePairs),\\n      ...getFiltersFromKeyValuePairsWithOperator(nKeyValuePairsWithOperator)\\n    ];\\n  });\\n  return filterList.map(\\n    ({ key, operator, value }) => formatFilter(key, operator, formatFilterValue(value))\\n  ).join(\\\" AND \\\");\\n}\\nvar getFiltersFromKeyValuePairs = (keyValuePairs) => {\\n  const filters = [];\\n  keyValuePairs.forEach(([key, value]) => {\\n    filters.push({\\n      key,\\n      operator: \\\":\\\",\\n      value\\n    });\\n  });\\n  return filters;\\n};\\nvar getFiltersFromKeyValuePairsWithOperator = (keyValuePairsWithOperator) => {\\n  const filters = [];\\n  keyValuePairsWithOperator.forEach(([key, value]) => {\\n    if (\\\"startsWith\\\" in value && typeof value.startsWith === \\\"string\\\") {\\n      filters.push({\\n        key,\\n        operator: \\\"^\\\",\\n        value: value.startsWith\\n      });\\n    }\\n  });\\n  return filters;\\n};\\nvar isSimpleValue = (value) => {\\n  if (typeof value === \\\"string\\\" || typeof value === \\\"number\\\" || typeof value === \\\"boolean\\\") {\\n    return true;\\n  }\\n  return false;\\n};\\nvar isValueWithOperator = (value) => {\\n  if (typeof value === \\\"object\\\" && value !== null && \\\"startsWith\\\" in value) {\\n    return true;\\n  }\\n  return false;\\n};\\nvar formatFilter = (key, operator, value) => {\\n  return `${key}${operator}${value}`;\\n};\\nvar formatFilterKey = (key, nestedKey) => {\\n  if (nestedKey) {\\n    return `${key}[${JSON.stringify(nestedKey)}]`;\\n  }\\n  return key;\\n};\\nvar formatFilterValue = (value) => {\\n  if (typeof value === \\\"string\\\") {\\n    if (isStringEmpty(value)) {\\n      throw new Error(\\\"Value cannot be empty\\\");\\n    }\\n    return JSON.stringify(value);\\n  }\\n  return value.toString();\\n};\\nvar isStringEmpty = (value) => {\\n  return !value || value.toString().trim() === \\\"\\\";\\n};\\n\\n// src/protocol/ClientMsg.ts\\nvar ClientMsgCode = /* @__PURE__ */ ((ClientMsgCode2) => {\\n  ClientMsgCode2[ClientMsgCode2[\\\"UPDATE_PRESENCE\\\"] = 100] = \\\"UPDATE_PRESENCE\\\";\\n  ClientMsgCode2[ClientMsgCode2[\\\"BROADCAST_EVENT\\\"] = 103] = \\\"BROADCAST_EVENT\\\";\\n  ClientMsgCode2[ClientMsgCode2[\\\"FETCH_STORAGE\\\"] = 200] = \\\"FETCH_STORAGE\\\";\\n  ClientMsgCode2[ClientMsgCode2[\\\"UPDATE_STORAGE\\\"] = 201] = \\\"UPDATE_STORAGE\\\";\\n  ClientMsgCode2[ClientMsgCode2[\\\"FETCH_YDOC\\\"] = 300] = \\\"FETCH_YDOC\\\";\\n  ClientMsgCode2[ClientMsgCode2[\\\"UPDATE_YDOC\\\"] = 301] = \\\"UPDATE_YDOC\\\";\\n  return ClientMsgCode2;\\n})(ClientMsgCode || {});\\n\\n// src/refs/ImmutableRef.ts\\nfunction merge(target, patch) {\\n  let updated = false;\\n  const newValue = { ...target };\\n  Object.keys(patch).forEach((k) => {\\n    const key = k;\\n    const val = patch[key];\\n    if (newValue[key] !== val) {\\n      if (val === void 0) {\\n        delete newValue[key];\\n      } else {\\n        newValue[key] = val;\\n      }\\n      updated = true;\\n    }\\n  });\\n  return updated ? newValue : target;\\n}\\nvar ImmutableRef = class {\\n  constructor() {\\n    this._ev = makeEventSource();\\n  }\\n  get didInvalidate() {\\n    return this._ev.observable;\\n  }\\n  invalidate() {\\n    if (this._cache !== void 0) {\\n      this._cache = void 0;\\n      this._ev.notify();\\n    }\\n  }\\n  get current() {\\n    return _nullishCoalesce(this._cache, () => ( (this._cache = this._toImmutable())));\\n  }\\n};\\n\\n// src/refs/OthersRef.ts\\nfunction makeUser(conn, presence) {\\n  const { connectionId, id, info } = conn;\\n  const canWrite = canWriteStorage(conn.scopes);\\n  return freeze(\\n    compactObject({\\n      connectionId,\\n      id,\\n      info,\\n      canWrite,\\n      canComment: canComment(conn.scopes),\\n      isReadOnly: !canWrite,\\n      // Deprecated, kept for backward-compatibility\\n      presence\\n    })\\n  );\\n}\\nvar OthersRef = class extends ImmutableRef {\\n  //\\n  // --------------------------------------------------------------\\n  //\\n  constructor() {\\n    super();\\n    this._connections = /* @__PURE__ */ new Map();\\n    this._presences = /* @__PURE__ */ new Map();\\n    this._users = /* @__PURE__ */ new Map();\\n  }\\n  connectionIds() {\\n    return this._connections.keys();\\n  }\\n  /** @internal */\\n  _toImmutable() {\\n    const users = compact(\\n      Array.from(this._presences.keys()).map(\\n        (connectionId) => this.getUser(Number(connectionId))\\n      )\\n    );\\n    return users;\\n  }\\n  clearOthers() {\\n    this._connections = /* @__PURE__ */ new Map();\\n    this._presences = /* @__PURE__ */ new Map();\\n    this._users = /* @__PURE__ */ new Map();\\n    this.invalidate();\\n  }\\n  /** @internal */\\n  _getUser(connectionId) {\\n    const conn = this._connections.get(connectionId);\\n    const presence = this._presences.get(connectionId);\\n    if (conn !== void 0 && presence !== void 0) {\\n      return makeUser(conn, presence);\\n    }\\n    return void 0;\\n  }\\n  getUser(connectionId) {\\n    const cachedUser = this._users.get(connectionId);\\n    if (cachedUser) {\\n      return cachedUser;\\n    }\\n    const computedUser = this._getUser(connectionId);\\n    if (computedUser) {\\n      this._users.set(connectionId, computedUser);\\n      return computedUser;\\n    }\\n    return void 0;\\n  }\\n  /** @internal */\\n  _invalidateUser(connectionId) {\\n    if (this._users.has(connectionId)) {\\n      this._users.delete(connectionId);\\n    }\\n    this.invalidate();\\n  }\\n  /**\\n   * Records a known connection. This records the connection ID and the\\n   * associated metadata.\\n   */\\n  setConnection(connectionId, metaUserId, metaUserInfo, scopes) {\\n    this._connections.set(\\n      connectionId,\\n      freeze({\\n        connectionId,\\n        id: metaUserId,\\n        info: metaUserInfo,\\n        scopes\\n      })\\n    );\\n    if (this._presences.has(connectionId)) {\\n      this._invalidateUser(connectionId);\\n    }\\n  }\\n  /**\\n   * Removes a known connectionId. Removes both the connection's metadata and\\n   * the presence information.\\n   */\\n  removeConnection(connectionId) {\\n    this._connections.delete(connectionId);\\n    this._presences.delete(connectionId);\\n    this._invalidateUser(connectionId);\\n  }\\n  /**\\n   * Stores a new user from a full presence update. If the user already exists,\\n   * its known presence data is overwritten.\\n   */\\n  setOther(connectionId, presence) {\\n    this._presences.set(connectionId, freeze(compactObject(presence)));\\n    if (this._connections.has(connectionId)) {\\n      this._invalidateUser(connectionId);\\n    }\\n  }\\n  /**\\n   * Patches the presence data for an existing \\\"other\\\". If we don't know the\\n   * initial presence data for this user yet, discard this patch and await the\\n   * full .setOther() call first.\\n   */\\n  patchOther(connectionId, patch) {\\n    const oldPresence = this._presences.get(connectionId);\\n    if (oldPresence === void 0) {\\n      return;\\n    }\\n    const newPresence = merge(oldPresence, patch);\\n    if (oldPresence !== newPresence) {\\n      this._presences.set(connectionId, freeze(newPresence));\\n      this._invalidateUser(connectionId);\\n    }\\n  }\\n};\\n\\n// src/refs/PatchableRef.ts\\nvar PatchableRef = class extends ImmutableRef {\\n  constructor(data) {\\n    super();\\n    this._data = freeze(compactObject(data));\\n  }\\n  /** @internal */\\n  _toImmutable() {\\n    return this._data;\\n  }\\n  /**\\n   * Patches the current object.\\n   */\\n  patch(patch) {\\n    const oldData = this._data;\\n    const newData = merge(oldData, patch);\\n    if (oldData !== newData) {\\n      this._data = freeze(newData);\\n      this.invalidate();\\n    }\\n  }\\n};\\n\\n// src/refs/ValueRef.ts\\nvar ValueRef = class extends ImmutableRef {\\n  constructor(initialValue) {\\n    super();\\n    this._value = freeze(initialValue);\\n  }\\n  /** @internal */\\n  _toImmutable() {\\n    return this._value;\\n  }\\n  set(newValue) {\\n    this._value = freeze(newValue);\\n    this.invalidate();\\n  }\\n};\\nvar DerivedRef = class extends ImmutableRef {\\n  constructor(...args) {\\n    super();\\n    const transformFn = args.pop();\\n    const otherRefs = args;\\n    this._refs = otherRefs;\\n    this._refs.forEach((ref) => {\\n      ref.didInvalidate.subscribe(() => this.invalidate());\\n    });\\n    this._transform = transformFn;\\n  }\\n  /** @internal */\\n  _toImmutable() {\\n    return this._transform(\\n      ...this._refs.map((ref) => ref.current)\\n    );\\n  }\\n};\\n\\n// src/room.ts\\nvar MAX_SOCKET_MESSAGE_SIZE = 1024 * 1024 - 1024;\\nfunction makeIdFactory(connectionId) {\\n  let count = 0;\\n  return () => `${connectionId}:${count++}`;\\n}\\nfunction userToTreeNode(key, user) {\\n  return {\\n    type: \\\"User\\\",\\n    id: `${user.connectionId}`,\\n    key,\\n    payload: {\\n      connectionId: user.connectionId,\\n      id: user.id,\\n      info: user.info,\\n      presence: user.presence,\\n      isReadOnly: !user.canWrite\\n    }\\n  };\\n}\\nfunction installBackgroundTabSpy() {\\n  const doc = typeof document !== \\\"undefined\\\" ? document : void 0;\\n  const inBackgroundSince = { current: null };\\n  function onVisibilityChange() {\\n    if (_optionalChain([doc, 'optionalAccess', _117 => _117.visibilityState]) === \\\"hidden\\\") {\\n      inBackgroundSince.current = _nullishCoalesce(inBackgroundSince.current, () => ( Date.now()));\\n    } else {\\n      inBackgroundSince.current = null;\\n    }\\n  }\\n  _optionalChain([doc, 'optionalAccess', _118 => _118.addEventListener, 'call', _119 => _119(\\\"visibilitychange\\\", onVisibilityChange)]);\\n  const unsub = () => {\\n    _optionalChain([doc, 'optionalAccess', _120 => _120.removeEventListener, 'call', _121 => _121(\\\"visibilitychange\\\", onVisibilityChange)]);\\n  };\\n  return [inBackgroundSince, unsub];\\n}\\nvar GET_ATTACHMENT_URLS_BATCH_DELAY = 50;\\nvar ATTACHMENT_PART_SIZE = 5 * 1024 * 1024;\\nvar ATTACHMENT_PART_BATCH_SIZE = 5;\\nvar RETRY_ATTEMPTS = 10;\\nvar RETRY_DELAYS = [\\n  2e3,\\n  2e3,\\n  2e3,\\n  2e3,\\n  2e3,\\n  2e3,\\n  2e3,\\n  2e3,\\n  2e3,\\n  2e3\\n];\\nfunction splitFileIntoParts(file) {\\n  const parts = [];\\n  let start = 0;\\n  while (start < file.size) {\\n    const end = Math.min(start + ATTACHMENT_PART_SIZE, file.size);\\n    parts.push({\\n      partNumber: parts.length + 1,\\n      part: file.slice(start, end)\\n    });\\n    start = end;\\n  }\\n  return parts;\\n}\\nfunction createRoom(options, config) {\\n  const initialPresence = options.initialPresence;\\n  const initialStorage = options.initialStorage;\\n  const [inBackgroundSince, uninstallBgTabSpy] = installBackgroundTabSpy();\\n  const delegates = {\\n    ...config.delegates,\\n    // A connection is allowed to go into \\\"zombie state\\\" only if all of the\\n    // following conditions apply:\\n    //\\n    // - The `backgroundKeepAliveTimeout` client option is configured\\n    // - The browser window has been in the background for at least\\n    //   `backgroundKeepAliveTimeout` milliseconds\\n    // - There are no pending changes\\n    //\\n    canZombie() {\\n      return config.backgroundKeepAliveTimeout !== void 0 && inBackgroundSince.current !== null && Date.now() > inBackgroundSince.current + config.backgroundKeepAliveTimeout && getStorageStatus() !== \\\"synchronizing\\\";\\n    }\\n  };\\n  const managedSocket = new ManagedSocket(\\n    delegates,\\n    config.enableDebugLogging\\n  );\\n  const context = {\\n    buffer: {\\n      flushTimerID: void 0,\\n      lastFlushedAt: 0,\\n      presenceUpdates: (\\n        // Queue up the initial presence message as a Full Presence\\u2122 update\\n        {\\n          type: \\\"full\\\",\\n          data: initialPresence\\n        }\\n      ),\\n      messages: [],\\n      storageOperations: []\\n    },\\n    staticSessionInfo: new ValueRef(null),\\n    dynamicSessionInfo: new ValueRef(null),\\n    myPresence: new PatchableRef(initialPresence),\\n    others: new OthersRef(),\\n    initialStorage,\\n    idFactory: null,\\n    // Y.js\\n    provider: void 0,\\n    onProviderUpdate: makeEventSource(),\\n    // Storage\\n    clock: 0,\\n    opClock: 0,\\n    nodes: /* @__PURE__ */ new Map(),\\n    root: void 0,\\n    undoStack: [],\\n    redoStack: [],\\n    pausedHistory: null,\\n    activeBatch: null,\\n    unacknowledgedOps: /* @__PURE__ */ new Map(),\\n    // Debug\\n    opStackTraces: process.env.NODE_ENV !== \\\"production\\\" ? /* @__PURE__ */ new Map() : void 0\\n  };\\n  const doNotBatchUpdates = (cb) => cb();\\n  const batchUpdates = _nullishCoalesce(config.unstable_batchedUpdates, () => ( doNotBatchUpdates));\\n  let lastTokenKey;\\n  function onStatusDidChange(newStatus) {\\n    const authValue = managedSocket.authValue;\\n    if (authValue !== null) {\\n      const tokenKey = getBearerTokenFromAuthValue(authValue);\\n      if (tokenKey !== lastTokenKey) {\\n        lastTokenKey = tokenKey;\\n        if (authValue.type === \\\"secret\\\") {\\n          const token = authValue.token.parsed;\\n          context.staticSessionInfo.set({\\n            userId: token.k === \\\"sec-legacy\\\" /* SECRET_LEGACY */ ? token.id : token.uid,\\n            userInfo: token.k === \\\"sec-legacy\\\" /* SECRET_LEGACY */ ? token.info : token.ui\\n          });\\n        } else {\\n          context.staticSessionInfo.set({\\n            userId: void 0,\\n            userInfo: void 0\\n          });\\n        }\\n      }\\n    }\\n    batchUpdates(() => {\\n      eventHub.status.notify(newStatus);\\n      notifySelfChanged(doNotBatchUpdates);\\n    });\\n  }\\n  let _connectionLossTimerId;\\n  let _hasLostConnection = false;\\n  function handleConnectionLossEvent(newStatus) {\\n    if (newStatus === \\\"reconnecting\\\") {\\n      _connectionLossTimerId = setTimeout(() => {\\n        batchUpdates(() => {\\n          eventHub.lostConnection.notify(\\\"lost\\\");\\n          _hasLostConnection = true;\\n          context.others.clearOthers();\\n          notify({ others: [{ type: \\\"reset\\\" }] }, doNotBatchUpdates);\\n        });\\n      }, config.lostConnectionTimeout);\\n    } else {\\n      clearTimeout(_connectionLossTimerId);\\n      if (_hasLostConnection) {\\n        if (newStatus === \\\"disconnected\\\") {\\n          batchUpdates(() => {\\n            eventHub.lostConnection.notify(\\\"failed\\\");\\n          });\\n        } else {\\n          batchUpdates(() => {\\n            eventHub.lostConnection.notify(\\\"restored\\\");\\n          });\\n        }\\n        _hasLostConnection = false;\\n      }\\n    }\\n  }\\n  function onDidConnect() {\\n    context.buffer.presenceUpdates = {\\n      type: \\\"full\\\",\\n      data: (\\n        // Because context.me.current is a readonly object, we'll have to\\n        // make a copy here. Otherwise, type errors happen later when\\n        // \\\"patching\\\" my presence.\\n        { ...context.myPresence.current }\\n      )\\n    };\\n    if (_getStorage$ !== null) {\\n      refreshStorage({ flush: false });\\n    }\\n    flushNowOrSoon();\\n  }\\n  function onDidDisconnect() {\\n    clearTimeout(context.buffer.flushTimerID);\\n  }\\n  managedSocket.events.onMessage.subscribe(handleServerMessage);\\n  managedSocket.events.statusDidChange.subscribe(onStatusDidChange);\\n  managedSocket.events.statusDidChange.subscribe(handleConnectionLossEvent);\\n  managedSocket.events.didConnect.subscribe(onDidConnect);\\n  managedSocket.events.didDisconnect.subscribe(onDidDisconnect);\\n  managedSocket.events.onLiveblocksError.subscribe((err) => {\\n    batchUpdates(() => {\\n      if (process.env.NODE_ENV !== \\\"production\\\") {\\n        error2(\\n          `Connection to websocket server closed. Reason: ${err.message} (code: ${err.code}).`\\n        );\\n      }\\n      eventHub.error.notify(err);\\n    });\\n  });\\n  const pool = {\\n    roomId: config.roomId,\\n    getNode: (id) => context.nodes.get(id),\\n    addNode: (id, node) => void context.nodes.set(id, node),\\n    deleteNode: (id) => void context.nodes.delete(id),\\n    generateId: () => `${getConnectionId()}:${context.clock++}`,\\n    generateOpId: () => `${getConnectionId()}:${context.opClock++}`,\\n    dispatch(ops, reverse, storageUpdates) {\\n      const activeBatch = context.activeBatch;\\n      if (process.env.NODE_ENV !== \\\"production\\\") {\\n        const stackTrace = captureStackTrace(\\\"Storage mutation\\\", this.dispatch);\\n        if (stackTrace) {\\n          for (const op of ops) {\\n            if (op.opId) {\\n              nn(context.opStackTraces).set(op.opId, stackTrace);\\n            }\\n          }\\n        }\\n      }\\n      if (activeBatch) {\\n        for (const op of ops) {\\n          activeBatch.ops.push(op);\\n        }\\n        for (const [key, value] of storageUpdates) {\\n          activeBatch.updates.storageUpdates.set(\\n            key,\\n            mergeStorageUpdates(\\n              activeBatch.updates.storageUpdates.get(key),\\n              value\\n            )\\n          );\\n        }\\n        activeBatch.reverseOps.unshift(...reverse);\\n      } else {\\n        batchUpdates(() => {\\n          addToUndoStack(reverse, doNotBatchUpdates);\\n          context.redoStack.length = 0;\\n          dispatchOps(ops);\\n          notify({ storageUpdates }, doNotBatchUpdates);\\n        });\\n      }\\n    },\\n    assertStorageIsWritable: () => {\\n      const scopes = _optionalChain([context, 'access', _122 => _122.dynamicSessionInfo, 'access', _123 => _123.current, 'optionalAccess', _124 => _124.scopes]);\\n      if (scopes === void 0) {\\n        return;\\n      }\\n      const canWrite = canWriteStorage(scopes);\\n      if (!canWrite) {\\n        throw new Error(\\n          \\\"Cannot write to storage with a read only user, please ensure the user has write permissions\\\"\\n        );\\n      }\\n    }\\n  };\\n  const eventHub = {\\n    status: makeEventSource(),\\n    // New/recommended API\\n    lostConnection: makeEventSource(),\\n    customEvent: makeEventSource(),\\n    self: makeEventSource(),\\n    myPresence: makeEventSource(),\\n    others: makeEventSource(),\\n    error: makeEventSource(),\\n    storageBatch: makeEventSource(),\\n    history: makeEventSource(),\\n    storageDidLoad: makeEventSource(),\\n    storageStatus: makeEventSource(),\\n    ydoc: makeEventSource(),\\n    comments: makeEventSource()\\n  };\\n  const fetchPolyfill = _optionalChain([config, 'access', _125 => _125.polyfills, 'optionalAccess', _126 => _126.fetch]) || /* istanbul ignore next */\\n  _optionalChain([globalThis, 'access', _127 => _127.fetch, 'optionalAccess', _128 => _128.bind, 'call', _129 => _129(globalThis)]);\\n  const httpClient1 = new HttpClient(\\n    config.baseUrl,\\n    fetchPolyfill,\\n    () => Promise.resolve(_nullishCoalesce(managedSocket.authValue, () => ( raise(\\\"Not authorized\\\"))))\\n  );\\n  const httpClient2 = new HttpClient(\\n    config.baseUrl,\\n    fetchPolyfill,\\n    () => (\\n      // TODO: Use the right scope\\n      delegates.authenticate()\\n    )\\n  );\\n  async function createTextMention(userId, mentionId) {\\n    await httpClient1.rawPost(url`/v2/c/rooms/${config.roomId}/text-mentions`, {\\n      userId,\\n      mentionId\\n    });\\n  }\\n  async function deleteTextMention(mentionId) {\\n    await httpClient1.rawDelete(\\n      url`/v2/c/rooms/${config.roomId}/text-mentions/${mentionId}`\\n    );\\n  }\\n  async function reportTextEditor(type, rootKey) {\\n    await httpClient2.rawPost(url`/v2/c/rooms/${config.roomId}/text-metadata`, {\\n      type,\\n      rootKey\\n    });\\n  }\\n  async function listTextVersions() {\\n    const result = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/versions`);\\n    return {\\n      versions: result.versions.map(({ createdAt, ...version }) => {\\n        return {\\n          createdAt: new Date(createdAt),\\n          ...version\\n        };\\n      }),\\n      requestedAt: new Date(result.meta.requestedAt)\\n    };\\n  }\\n  async function listTextVersionsSince(options2) {\\n    const result = await httpClient2.get(\\n      url`/v2/c/rooms/${config.roomId}/versions/delta`,\\n      { since: options2.since.toISOString() },\\n      { signal: options2.signal }\\n    );\\n    return {\\n      versions: result.versions.map(({ createdAt, ...version }) => {\\n        return {\\n          createdAt: new Date(createdAt),\\n          ...version\\n        };\\n      }),\\n      requestedAt: new Date(result.meta.requestedAt)\\n    };\\n  }\\n  async function getTextVersion(versionId) {\\n    return httpClient2.rawGet(\\n      url`/v2/c/rooms/${config.roomId}/y-version/${versionId}`\\n    );\\n  }\\n  async function createTextVersion() {\\n    await httpClient2.rawPost(url`/v2/c/rooms/${config.roomId}/version`);\\n  }\\n  function sendMessages(messages) {\\n    const serializedPayload = JSON.stringify(messages);\\n    const nonce = _optionalChain([context, 'access', _130 => _130.dynamicSessionInfo, 'access', _131 => _131.current, 'optionalAccess', _132 => _132.nonce]);\\n    if (config.unstable_fallbackToHTTP && nonce) {\\n      const size = new TextEncoder().encode(serializedPayload).length;\\n      if (size > MAX_SOCKET_MESSAGE_SIZE) {\\n        void httpClient1.rawPost(url`/v2/c/rooms/${config.roomId}/send-message`, {\\n          nonce,\\n          messages\\n        }).then((resp) => {\\n          if (!resp.ok && resp.status === 403) {\\n            managedSocket.reconnect();\\n          }\\n        });\\n        warn(\\n          \\\"Message was too large for websockets and sent over HTTP instead\\\"\\n        );\\n        return;\\n      }\\n    }\\n    managedSocket.send(serializedPayload);\\n  }\\n  const self = new DerivedRef(\\n    context.staticSessionInfo,\\n    context.dynamicSessionInfo,\\n    context.myPresence,\\n    (staticSession, dynamicSession, myPresence) => {\\n      if (staticSession === null || dynamicSession === null) {\\n        return null;\\n      } else {\\n        const canWrite = canWriteStorage(dynamicSession.scopes);\\n        return {\\n          connectionId: dynamicSession.actor,\\n          id: staticSession.userId,\\n          info: staticSession.userInfo,\\n          presence: myPresence,\\n          canWrite,\\n          canComment: canComment(dynamicSession.scopes)\\n        };\\n      }\\n    }\\n  );\\n  let _lastSelf;\\n  function notifySelfChanged(batchedUpdatesWrapper) {\\n    const currSelf = self.current;\\n    if (currSelf !== null && currSelf !== _lastSelf) {\\n      batchedUpdatesWrapper(() => {\\n        eventHub.self.notify(currSelf);\\n      });\\n      _lastSelf = currSelf;\\n    }\\n  }\\n  const selfAsTreeNode = new DerivedRef(\\n    self,\\n    (me) => me !== null ? userToTreeNode(\\\"Me\\\", me) : null\\n  );\\n  function createOrUpdateRootFromMessage(message, batchedUpdatesWrapper) {\\n    if (message.items.length === 0) {\\n      throw new Error(\\\"Internal error: cannot load storage without items\\\");\\n    }\\n    if (context.root !== void 0) {\\n      updateRoot(message.items, batchedUpdatesWrapper);\\n    } else {\\n      context.root = LiveObject._fromItems(message.items, pool);\\n    }\\n    const canWrite = _nullishCoalesce(_optionalChain([self, 'access', _133 => _133.current, 'optionalAccess', _134 => _134.canWrite]), () => ( true));\\n    const stackSizeBefore = context.undoStack.length;\\n    for (const key in context.initialStorage) {\\n      if (context.root.get(key) === void 0) {\\n        if (canWrite) {\\n          context.root.set(key, cloneLson(context.initialStorage[key]));\\n        } else {\\n          warn(\\n            `Attempted to populate missing storage key '${key}', but current user has no write access`\\n          );\\n        }\\n      }\\n    }\\n    context.undoStack.length = stackSizeBefore;\\n  }\\n  function updateRoot(items, batchedUpdatesWrapper) {\\n    if (context.root === void 0) {\\n      return;\\n    }\\n    const currentItems = /* @__PURE__ */ new Map();\\n    for (const [id, node] of context.nodes) {\\n      currentItems.set(id, node._serialize());\\n    }\\n    const ops = getTreesDiffOperations(currentItems, new Map(items));\\n    const result = applyOps(ops, false);\\n    notify(result.updates, batchedUpdatesWrapper);\\n  }\\n  function _addToRealUndoStack(historyOps, batchedUpdatesWrapper) {\\n    if (context.undoStack.length >= 50) {\\n      context.undoStack.shift();\\n    }\\n    context.undoStack.push(historyOps);\\n    onHistoryChange(batchedUpdatesWrapper);\\n  }\\n  function addToUndoStack(historyOps, batchedUpdatesWrapper) {\\n    if (context.pausedHistory !== null) {\\n      context.pausedHistory.unshift(...historyOps);\\n    } else {\\n      _addToRealUndoStack(historyOps, batchedUpdatesWrapper);\\n    }\\n  }\\n  function notify(updates, batchedUpdatesWrapper) {\\n    const storageUpdates = updates.storageUpdates;\\n    const othersUpdates = updates.others;\\n    batchedUpdatesWrapper(() => {\\n      if (othersUpdates !== void 0 && othersUpdates.length > 0) {\\n        const others = context.others.current;\\n        for (const event of othersUpdates) {\\n          eventHub.others.notify({ ...event, others });\\n        }\\n      }\\n      if (_nullishCoalesce(updates.presence, () => ( false))) {\\n        notifySelfChanged(doNotBatchUpdates);\\n        eventHub.myPresence.notify(context.myPresence.current);\\n      }\\n      if (storageUpdates !== void 0 && storageUpdates.size > 0) {\\n        const updates2 = Array.from(storageUpdates.values());\\n        eventHub.storageBatch.notify(updates2);\\n      }\\n      notifyStorageStatus();\\n    });\\n  }\\n  function getConnectionId() {\\n    const info = context.dynamicSessionInfo.current;\\n    if (info) {\\n      return info.actor;\\n    }\\n    throw new Error(\\n      \\\"Internal. Tried to get connection id but connection was never open\\\"\\n    );\\n  }\\n  function applyOps(rawOps, isLocal) {\\n    const output = {\\n      reverse: [],\\n      storageUpdates: /* @__PURE__ */ new Map(),\\n      presence: false\\n    };\\n    const createdNodeIds = /* @__PURE__ */ new Set();\\n    const ops = rawOps.map((op) => {\\n      if (op.type !== \\\"presence\\\" && !op.opId) {\\n        return { ...op, opId: pool.generateOpId() };\\n      } else {\\n        return op;\\n      }\\n    });\\n    for (const op of ops) {\\n      if (op.type === \\\"presence\\\") {\\n        const reverse = {\\n          type: \\\"presence\\\",\\n          data: {}\\n        };\\n        for (const key in op.data) {\\n          reverse.data[key] = context.myPresence.current[key];\\n        }\\n        context.myPresence.patch(op.data);\\n        if (context.buffer.presenceUpdates === null) {\\n          context.buffer.presenceUpdates = { type: \\\"partial\\\", data: op.data };\\n        } else {\\n          for (const key in op.data) {\\n            context.buffer.presenceUpdates.data[key] = op.data[key];\\n          }\\n        }\\n        output.reverse.unshift(reverse);\\n        output.presence = true;\\n      } else {\\n        let source;\\n        if (isLocal) {\\n          source = 0 /* UNDOREDO_RECONNECT */;\\n        } else {\\n          const opId = nn(op.opId);\\n          if (process.env.NODE_ENV !== \\\"production\\\") {\\n            nn(context.opStackTraces).delete(opId);\\n          }\\n          const deleted = context.unacknowledgedOps.delete(opId);\\n          source = deleted ? 2 /* ACK */ : 1 /* REMOTE */;\\n        }\\n        const applyOpResult = applyOp(op, source);\\n        if (applyOpResult.modified) {\\n          const nodeId = applyOpResult.modified.node._id;\\n          if (!(nodeId && createdNodeIds.has(nodeId))) {\\n            output.storageUpdates.set(\\n              nn(applyOpResult.modified.node._id),\\n              mergeStorageUpdates(\\n                output.storageUpdates.get(nn(applyOpResult.modified.node._id)),\\n                applyOpResult.modified\\n              )\\n            );\\n            output.reverse.unshift(...applyOpResult.reverse);\\n          }\\n          if (op.type === 2 /* CREATE_LIST */ || op.type === 7 /* CREATE_MAP */ || op.type === 4 /* CREATE_OBJECT */) {\\n            createdNodeIds.add(nn(op.id));\\n          }\\n        }\\n      }\\n    }\\n    return {\\n      ops,\\n      reverse: output.reverse,\\n      updates: {\\n        storageUpdates: output.storageUpdates,\\n        presence: output.presence\\n      }\\n    };\\n  }\\n  function applyOp(op, source) {\\n    if (isAckOp(op)) {\\n      return { modified: false };\\n    }\\n    switch (op.type) {\\n      case 6 /* DELETE_OBJECT_KEY */:\\n      case 3 /* UPDATE_OBJECT */:\\n      case 5 /* DELETE_CRDT */: {\\n        const node = context.nodes.get(op.id);\\n        if (node === void 0) {\\n          return { modified: false };\\n        }\\n        return node._apply(op, source === 0 /* UNDOREDO_RECONNECT */);\\n      }\\n      case 1 /* SET_PARENT_KEY */: {\\n        const node = context.nodes.get(op.id);\\n        if (node === void 0) {\\n          return { modified: false };\\n        }\\n        if (node.parent.type === \\\"HasParent\\\" && isLiveList(node.parent.node)) {\\n          return node.parent.node._setChildKey(\\n            asPos(op.parentKey),\\n            node,\\n            source\\n          );\\n        }\\n        return { modified: false };\\n      }\\n      case 4 /* CREATE_OBJECT */:\\n      case 2 /* CREATE_LIST */:\\n      case 7 /* CREATE_MAP */:\\n      case 8 /* CREATE_REGISTER */: {\\n        if (op.parentId === void 0) {\\n          return { modified: false };\\n        }\\n        const parentNode = context.nodes.get(op.parentId);\\n        if (parentNode === void 0) {\\n          return { modified: false };\\n        }\\n        return parentNode._attachChild(op, source);\\n      }\\n    }\\n  }\\n  function updatePresence(patch, options2) {\\n    const oldValues = {};\\n    if (context.buffer.presenceUpdates === null) {\\n      context.buffer.presenceUpdates = {\\n        type: \\\"partial\\\",\\n        data: {}\\n      };\\n    }\\n    for (const key in patch) {\\n      const overrideValue = patch[key];\\n      if (overrideValue === void 0) {\\n        continue;\\n      }\\n      context.buffer.presenceUpdates.data[key] = overrideValue;\\n      oldValues[key] = context.myPresence.current[key];\\n    }\\n    context.myPresence.patch(patch);\\n    if (context.activeBatch) {\\n      if (_optionalChain([options2, 'optionalAccess', _135 => _135.addToHistory])) {\\n        context.activeBatch.reverseOps.unshift({\\n          type: \\\"presence\\\",\\n          data: oldValues\\n        });\\n      }\\n      context.activeBatch.updates.presence = true;\\n    } else {\\n      flushNowOrSoon();\\n      batchUpdates(() => {\\n        if (_optionalChain([options2, 'optionalAccess', _136 => _136.addToHistory])) {\\n          addToUndoStack(\\n            [{ type: \\\"presence\\\", data: oldValues }],\\n            doNotBatchUpdates\\n          );\\n        }\\n        notify({ presence: true }, doNotBatchUpdates);\\n      });\\n    }\\n  }\\n  function onUpdatePresenceMessage(message) {\\n    if (message.targetActor !== void 0) {\\n      const oldUser = context.others.getUser(message.actor);\\n      context.others.setOther(message.actor, message.data);\\n      const newUser = context.others.getUser(message.actor);\\n      if (oldUser === void 0 && newUser !== void 0) {\\n        return { type: \\\"enter\\\", user: newUser };\\n      }\\n    } else {\\n      context.others.patchOther(message.actor, message.data), message;\\n    }\\n    const user = context.others.getUser(message.actor);\\n    if (user) {\\n      return {\\n        type: \\\"update\\\",\\n        updates: message.data,\\n        user\\n      };\\n    } else {\\n      return void 0;\\n    }\\n  }\\n  function onUserLeftMessage(message) {\\n    const user = context.others.getUser(message.actor);\\n    if (user) {\\n      context.others.removeConnection(message.actor);\\n      return { type: \\\"leave\\\", user };\\n    }\\n    return null;\\n  }\\n  function onRoomStateMessage(message, batchedUpdatesWrapper) {\\n    context.dynamicSessionInfo.set({\\n      actor: message.actor,\\n      nonce: message.nonce,\\n      scopes: message.scopes\\n    });\\n    context.idFactory = makeIdFactory(message.actor);\\n    notifySelfChanged(batchedUpdatesWrapper);\\n    for (const connectionId of context.others.connectionIds()) {\\n      const user = message.users[connectionId];\\n      if (user === void 0) {\\n        context.others.removeConnection(connectionId);\\n      }\\n    }\\n    for (const key in message.users) {\\n      const user = message.users[key];\\n      const connectionId = Number(key);\\n      context.others.setConnection(\\n        connectionId,\\n        user.id,\\n        user.info,\\n        user.scopes\\n      );\\n    }\\n    return { type: \\\"reset\\\" };\\n  }\\n  function canUndo() {\\n    return context.undoStack.length > 0;\\n  }\\n  function canRedo() {\\n    return context.redoStack.length > 0;\\n  }\\n  function onHistoryChange(batchedUpdatesWrapper) {\\n    batchedUpdatesWrapper(() => {\\n      eventHub.history.notify({ canUndo: canUndo(), canRedo: canRedo() });\\n    });\\n  }\\n  function onUserJoinedMessage(message) {\\n    context.others.setConnection(\\n      message.actor,\\n      message.id,\\n      message.info,\\n      message.scopes\\n    );\\n    context.buffer.messages.push({\\n      type: 100 /* UPDATE_PRESENCE */,\\n      data: context.myPresence.current,\\n      targetActor: message.actor\\n    });\\n    flushNowOrSoon();\\n    const user = context.others.getUser(message.actor);\\n    return user ? { type: \\\"enter\\\", user } : void 0;\\n  }\\n  function parseServerMessage(data) {\\n    if (!isJsonObject(data)) {\\n      return null;\\n    }\\n    return data;\\n  }\\n  function parseServerMessages(text) {\\n    const data = tryParseJson(text);\\n    if (data === void 0) {\\n      return null;\\n    } else if (isJsonArray(data)) {\\n      return compact(data.map((item) => parseServerMessage(item)));\\n    } else {\\n      return compact([parseServerMessage(data)]);\\n    }\\n  }\\n  function applyAndSendOps(offlineOps, batchedUpdatesWrapper) {\\n    if (offlineOps.size === 0) {\\n      return;\\n    }\\n    const messages = [];\\n    const ops = Array.from(offlineOps.values());\\n    const result = applyOps(ops, true);\\n    messages.push({\\n      type: 201 /* UPDATE_STORAGE */,\\n      ops: result.ops\\n    });\\n    notify(result.updates, batchedUpdatesWrapper);\\n    sendMessages(messages);\\n  }\\n  function handleServerMessage(event) {\\n    if (typeof event.data !== \\\"string\\\") {\\n      return;\\n    }\\n    const messages = parseServerMessages(event.data);\\n    if (messages === null || messages.length === 0) {\\n      return;\\n    }\\n    const updates = {\\n      storageUpdates: /* @__PURE__ */ new Map(),\\n      others: []\\n    };\\n    batchUpdates(() => {\\n      for (const message of messages) {\\n        switch (message.type) {\\n          case 101 /* USER_JOINED */: {\\n            const userJoinedUpdate = onUserJoinedMessage(message);\\n            if (userJoinedUpdate) {\\n              updates.others.push(userJoinedUpdate);\\n            }\\n            break;\\n          }\\n          case 100 /* UPDATE_PRESENCE */: {\\n            const othersPresenceUpdate = onUpdatePresenceMessage(message);\\n            if (othersPresenceUpdate) {\\n              updates.others.push(othersPresenceUpdate);\\n            }\\n            break;\\n          }\\n          case 103 /* BROADCASTED_EVENT */: {\\n            const others = context.others.current;\\n            eventHub.customEvent.notify({\\n              connectionId: message.actor,\\n              user: message.actor < 0 ? null : _nullishCoalesce(others.find((u) => u.connectionId === message.actor), () => ( null)),\\n              event: message.event\\n            });\\n            break;\\n          }\\n          case 102 /* USER_LEFT */: {\\n            const event2 = onUserLeftMessage(message);\\n            if (event2) {\\n              updates.others.push(event2);\\n            }\\n            break;\\n          }\\n          case 300 /* UPDATE_YDOC */: {\\n            eventHub.ydoc.notify(message);\\n            break;\\n          }\\n          case 104 /* ROOM_STATE */: {\\n            updates.others.push(onRoomStateMessage(message, doNotBatchUpdates));\\n            break;\\n          }\\n          case 200 /* INITIAL_STORAGE_STATE */: {\\n            processInitialStorage(message);\\n            break;\\n          }\\n          case 201 /* UPDATE_STORAGE */: {\\n            const applyResult = applyOps(message.ops, false);\\n            for (const [key, value] of applyResult.updates.storageUpdates) {\\n              updates.storageUpdates.set(\\n                key,\\n                mergeStorageUpdates(updates.storageUpdates.get(key), value)\\n              );\\n            }\\n            break;\\n          }\\n          case 299 /* REJECT_STORAGE_OP */: {\\n            errorWithTitle(\\n              \\\"Storage mutation rejection error\\\",\\n              message.reason\\n            );\\n            if (process.env.NODE_ENV !== \\\"production\\\") {\\n              const traces = /* @__PURE__ */ new Set();\\n              for (const opId of message.opIds) {\\n                const trace = _optionalChain([context, 'access', _137 => _137.opStackTraces, 'optionalAccess', _138 => _138.get, 'call', _139 => _139(opId)]);\\n                if (trace) {\\n                  traces.add(trace);\\n                }\\n              }\\n              if (traces.size > 0) {\\n                warnWithTitle(\\n                  \\\"The following function calls caused the rejected storage mutations:\\\",\\n                  `\\n\\n${Array.from(traces).join(\\\"\\\\n\\\\n\\\")}`\\n                );\\n              }\\n              throw new Error(\\n                `Storage mutations rejected by server: ${message.reason}`\\n              );\\n            }\\n            break;\\n          }\\n          case 400 /* THREAD_CREATED */:\\n          case 407 /* THREAD_DELETED */:\\n          case 401 /* THREAD_METADATA_UPDATED */:\\n          case 408 /* THREAD_UPDATED */:\\n          case 405 /* COMMENT_REACTION_ADDED */:\\n          case 406 /* COMMENT_REACTION_REMOVED */:\\n          case 402 /* COMMENT_CREATED */:\\n          case 403 /* COMMENT_EDITED */:\\n          case 404 /* COMMENT_DELETED */: {\\n            eventHub.comments.notify(message);\\n            break;\\n          }\\n        }\\n      }\\n      notify(updates, doNotBatchUpdates);\\n    });\\n  }\\n  function flushNowOrSoon() {\\n    const storageOps = context.buffer.storageOperations;\\n    if (storageOps.length > 0) {\\n      for (const op of storageOps) {\\n        context.unacknowledgedOps.set(nn(op.opId), op);\\n      }\\n      notifyStorageStatus();\\n    }\\n    if (managedSocket.getStatus() !== \\\"connected\\\") {\\n      context.buffer.storageOperations = [];\\n      return;\\n    }\\n    const now = Date.now();\\n    const elapsedMillis = now - context.buffer.lastFlushedAt;\\n    if (elapsedMillis >= config.throttleDelay) {\\n      const messagesToFlush = serializeBuffer();\\n      if (messagesToFlush.length === 0) {\\n        return;\\n      }\\n      sendMessages(messagesToFlush);\\n      context.buffer = {\\n        flushTimerID: void 0,\\n        lastFlushedAt: now,\\n        messages: [],\\n        storageOperations: [],\\n        presenceUpdates: null\\n      };\\n    } else {\\n      clearTimeout(context.buffer.flushTimerID);\\n      context.buffer.flushTimerID = setTimeout(\\n        flushNowOrSoon,\\n        config.throttleDelay - elapsedMillis\\n      );\\n    }\\n  }\\n  function serializeBuffer() {\\n    const messages = [];\\n    if (context.buffer.presenceUpdates) {\\n      messages.push(\\n        context.buffer.presenceUpdates.type === \\\"full\\\" ? {\\n          type: 100 /* UPDATE_PRESENCE */,\\n          // Populating the `targetActor` field turns this message into\\n          // a Full Presence\\u2122 update message (not a patch), which will get\\n          // interpreted by other clients as such.\\n          targetActor: -1,\\n          data: context.buffer.presenceUpdates.data\\n        } : {\\n          type: 100 /* UPDATE_PRESENCE */,\\n          data: context.buffer.presenceUpdates.data\\n        }\\n      );\\n    }\\n    for (const event of context.buffer.messages) {\\n      messages.push(event);\\n    }\\n    if (context.buffer.storageOperations.length > 0) {\\n      messages.push({\\n        type: 201 /* UPDATE_STORAGE */,\\n        ops: context.buffer.storageOperations\\n      });\\n    }\\n    return messages;\\n  }\\n  function updateYDoc(update, guid) {\\n    const clientMsg = {\\n      type: 301 /* UPDATE_YDOC */,\\n      update,\\n      guid\\n    };\\n    context.buffer.messages.push(clientMsg);\\n    eventHub.ydoc.notify(clientMsg);\\n    flushNowOrSoon();\\n  }\\n  function broadcastEvent(event, options2 = {\\n    shouldQueueEventIfNotReady: false\\n  }) {\\n    if (managedSocket.getStatus() !== \\\"connected\\\" && !options2.shouldQueueEventIfNotReady) {\\n      return;\\n    }\\n    context.buffer.messages.push({\\n      type: 103 /* BROADCAST_EVENT */,\\n      event\\n    });\\n    flushNowOrSoon();\\n  }\\n  function dispatchOps(ops) {\\n    const { storageOperations } = context.buffer;\\n    for (const op of ops) {\\n      storageOperations.push(op);\\n    }\\n    flushNowOrSoon();\\n  }\\n  let _getStorage$ = null;\\n  let _resolveStoragePromise = null;\\n  function processInitialStorage(message) {\\n    const unacknowledgedOps = new Map(context.unacknowledgedOps);\\n    createOrUpdateRootFromMessage(message, doNotBatchUpdates);\\n    applyAndSendOps(unacknowledgedOps, doNotBatchUpdates);\\n    _optionalChain([_resolveStoragePromise, 'optionalCall', _140 => _140()]);\\n    notifyStorageStatus();\\n    eventHub.storageDidLoad.notify();\\n  }\\n  async function streamStorage() {\\n    if (!managedSocket.authValue) return;\\n    const result = await httpClient1.rawGet(\\n      url`/v2/c/rooms/${config.roomId}/storage`\\n    );\\n    const items = await result.json();\\n    processInitialStorage({ type: 200 /* INITIAL_STORAGE_STATE */, items });\\n  }\\n  function refreshStorage(options2) {\\n    const messages = context.buffer.messages;\\n    if (config.unstable_streamData) {\\n      void streamStorage();\\n    } else if (!messages.some((msg) => msg.type === 200 /* FETCH_STORAGE */)) {\\n      messages.push({ type: 200 /* FETCH_STORAGE */ });\\n    }\\n    if (options2.flush) {\\n      flushNowOrSoon();\\n    }\\n  }\\n  function startLoadingStorage() {\\n    if (_getStorage$ === null) {\\n      refreshStorage({ flush: true });\\n      _getStorage$ = new Promise((resolve) => {\\n        _resolveStoragePromise = resolve;\\n      });\\n      notifyStorageStatus();\\n    }\\n    return _getStorage$;\\n  }\\n  function getStorageSnapshot() {\\n    const root = context.root;\\n    if (root !== void 0) {\\n      return root;\\n    } else {\\n      void startLoadingStorage();\\n      return null;\\n    }\\n  }\\n  async function getStorage() {\\n    if (context.root !== void 0) {\\n      return Promise.resolve({\\n        root: context.root\\n      });\\n    }\\n    await startLoadingStorage();\\n    return {\\n      root: nn(context.root)\\n    };\\n  }\\n  function fetchYDoc(vector, guid) {\\n    if (!context.buffer.messages.find((m) => {\\n      return m.type === 300 /* FETCH_YDOC */ && m.vector === vector && m.guid === guid;\\n    })) {\\n      context.buffer.messages.push({\\n        type: 300 /* FETCH_YDOC */,\\n        vector,\\n        guid\\n      });\\n    }\\n    flushNowOrSoon();\\n  }\\n  function undo() {\\n    if (context.activeBatch) {\\n      throw new Error(\\\"undo is not allowed during a batch\\\");\\n    }\\n    const historyOps = context.undoStack.pop();\\n    if (historyOps === void 0) {\\n      return;\\n    }\\n    context.pausedHistory = null;\\n    const result = applyOps(historyOps, true);\\n    batchUpdates(() => {\\n      notify(result.updates, doNotBatchUpdates);\\n      context.redoStack.push(result.reverse);\\n      onHistoryChange(doNotBatchUpdates);\\n    });\\n    for (const op of result.ops) {\\n      if (op.type !== \\\"presence\\\") {\\n        context.buffer.storageOperations.push(op);\\n      }\\n    }\\n    flushNowOrSoon();\\n  }\\n  function redo() {\\n    if (context.activeBatch) {\\n      throw new Error(\\\"redo is not allowed during a batch\\\");\\n    }\\n    const historyOps = context.redoStack.pop();\\n    if (historyOps === void 0) {\\n      return;\\n    }\\n    context.pausedHistory = null;\\n    const result = applyOps(historyOps, true);\\n    batchUpdates(() => {\\n      notify(result.updates, doNotBatchUpdates);\\n      context.undoStack.push(result.reverse);\\n      onHistoryChange(doNotBatchUpdates);\\n    });\\n    for (const op of result.ops) {\\n      if (op.type !== \\\"presence\\\") {\\n        context.buffer.storageOperations.push(op);\\n      }\\n    }\\n    flushNowOrSoon();\\n  }\\n  function clear() {\\n    context.undoStack.length = 0;\\n    context.redoStack.length = 0;\\n  }\\n  function batch(callback) {\\n    if (context.activeBatch) {\\n      return callback();\\n    }\\n    let returnValue = void 0;\\n    batchUpdates(() => {\\n      context.activeBatch = {\\n        ops: [],\\n        updates: {\\n          storageUpdates: /* @__PURE__ */ new Map(),\\n          presence: false,\\n          others: []\\n        },\\n        reverseOps: []\\n      };\\n      try {\\n        returnValue = callback();\\n      } finally {\\n        const currentBatch = context.activeBatch;\\n        context.activeBatch = null;\\n        if (currentBatch.reverseOps.length > 0) {\\n          addToUndoStack(currentBatch.reverseOps, doNotBatchUpdates);\\n        }\\n        if (currentBatch.ops.length > 0) {\\n          context.redoStack.length = 0;\\n        }\\n        if (currentBatch.ops.length > 0) {\\n          dispatchOps(currentBatch.ops);\\n        }\\n        notify(currentBatch.updates, doNotBatchUpdates);\\n        flushNowOrSoon();\\n      }\\n    });\\n    return returnValue;\\n  }\\n  function pauseHistory() {\\n    if (context.pausedHistory === null) {\\n      context.pausedHistory = [];\\n    }\\n  }\\n  function resumeHistory() {\\n    const historyOps = context.pausedHistory;\\n    context.pausedHistory = null;\\n    if (historyOps !== null && historyOps.length > 0) {\\n      _addToRealUndoStack(historyOps, batchUpdates);\\n    }\\n  }\\n  function getStorageStatus() {\\n    if (context.root === void 0) {\\n      return _getStorage$ === null ? \\\"not-loaded\\\" : \\\"loading\\\";\\n    } else {\\n      return context.unacknowledgedOps.size === 0 ? \\\"synchronized\\\" : \\\"synchronizing\\\";\\n    }\\n  }\\n  let _lastStorageStatus = getStorageStatus();\\n  function notifyStorageStatus() {\\n    const storageStatus = getStorageStatus();\\n    if (_lastStorageStatus !== storageStatus) {\\n      _lastStorageStatus = storageStatus;\\n      eventHub.storageStatus.notify(storageStatus);\\n    }\\n  }\\n  function isPresenceReady() {\\n    return self.current !== null;\\n  }\\n  async function waitUntilPresenceReady() {\\n    while (!isPresenceReady()) {\\n      const { promise, resolve } = Promise_withResolvers();\\n      const unsub1 = events.self.subscribeOnce(resolve);\\n      const unsub2 = events.status.subscribeOnce(resolve);\\n      await promise;\\n      unsub1();\\n      unsub2();\\n    }\\n  }\\n  function isStorageReady() {\\n    return getStorageSnapshot() !== null;\\n  }\\n  async function waitUntilStorageReady() {\\n    while (!isStorageReady()) {\\n      await getStorage();\\n    }\\n  }\\n  const others_forDevTools = new DerivedRef(\\n    context.others,\\n    (others) => others.map((other, index) => userToTreeNode(`Other ${index}`, other))\\n  );\\n  const events = {\\n    status: eventHub.status.observable,\\n    lostConnection: eventHub.lostConnection.observable,\\n    customEvent: eventHub.customEvent.observable,\\n    others: eventHub.others.observable,\\n    self: eventHub.self.observable,\\n    myPresence: eventHub.myPresence.observable,\\n    error: eventHub.error.observable,\\n    /** @deprecated */\\n    storage: eventHub.storageBatch.observable,\\n    storageBatch: eventHub.storageBatch.observable,\\n    history: eventHub.history.observable,\\n    storageDidLoad: eventHub.storageDidLoad.observable,\\n    storageStatus: eventHub.storageStatus.observable,\\n    ydoc: eventHub.ydoc.observable,\\n    comments: eventHub.comments.observable\\n  };\\n  async function getThreadsSince(options2) {\\n    const result = await httpClient2.get(\\n      url`/v2/c/rooms/${config.roomId}/threads/delta`,\\n      { since: _optionalChain([options2, 'optionalAccess', _141 => _141.since, 'optionalAccess', _142 => _142.toISOString, 'call', _143 => _143()]) },\\n      { signal: options2.signal }\\n    );\\n    return {\\n      threads: {\\n        updated: result.data.map(convertToThreadData),\\n        deleted: result.deletedThreads.map(convertToThreadDeleteInfo)\\n      },\\n      inboxNotifications: {\\n        updated: result.inboxNotifications.map(convertToInboxNotificationData),\\n        deleted: result.deletedInboxNotifications.map(\\n          convertToInboxNotificationDeleteInfo\\n        )\\n      },\\n      requestedAt: new Date(result.meta.requestedAt)\\n    };\\n  }\\n  async function getThreads(options2) {\\n    let query;\\n    if (_optionalChain([options2, 'optionalAccess', _144 => _144.query])) {\\n      query = objectToQuery(options2.query);\\n    }\\n    const PAGE_SIZE = 50;\\n    const result = await httpClient2.get(url`/v2/c/rooms/${config.roomId}/threads`, {\\n      cursor: _optionalChain([options2, 'optionalAccess', _145 => _145.cursor]),\\n      query,\\n      limit: PAGE_SIZE\\n    });\\n    return {\\n      threads: result.data.map(convertToThreadData),\\n      inboxNotifications: result.inboxNotifications.map(\\n        convertToInboxNotificationData\\n      ),\\n      nextCursor: result.meta.nextCursor,\\n      requestedAt: new Date(result.meta.requestedAt)\\n    };\\n  }\\n  async function getThread(threadId) {\\n    const response = await httpClient2.rawGet(\\n      url`/v2/c/rooms/${config.roomId}/thread-with-notification/${threadId}`\\n    );\\n    if (response.ok) {\\n      const json = await response.json();\\n      return {\\n        thread: convertToThreadData(json.thread),\\n        inboxNotification: json.inboxNotification ? convertToInboxNotificationData(json.inboxNotification) : void 0\\n      };\\n    } else if (response.status === 404) {\\n      return {\\n        thread: void 0,\\n        inboxNotification: void 0\\n      };\\n    } else {\\n      throw new Error(`There was an error while getting thread ${threadId}.`);\\n    }\\n  }\\n  async function createThread({\\n    metadata,\\n    body,\\n    commentId = createCommentId(),\\n    threadId = createThreadId(),\\n    attachmentIds\\n  }) {\\n    const thread = await httpClient2.post(\\n      url`/v2/c/rooms/${config.roomId}/threads`,\\n      {\\n        id: threadId,\\n        comment: {\\n          id: commentId,\\n          body,\\n          attachmentIds\\n        },\\n        metadata\\n      }\\n    );\\n    return convertToThreadData(thread);\\n  }\\n  async function deleteThread(threadId) {\\n    await httpClient2.delete(\\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}`\\n    );\\n  }\\n  async function editThreadMetadata({\\n    metadata,\\n    threadId\\n  }) {\\n    return await httpClient2.post(\\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/metadata`,\\n      metadata\\n    );\\n  }\\n  async function markThreadAsResolved(threadId) {\\n    await httpClient2.post(\\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-resolved`\\n    );\\n  }\\n  async function markThreadAsUnresolved(threadId) {\\n    await httpClient2.post(\\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/mark-as-unresolved`\\n    );\\n  }\\n  async function createComment({\\n    threadId,\\n    commentId = createCommentId(),\\n    body,\\n    attachmentIds\\n  }) {\\n    const comment = await httpClient2.post(\\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments`,\\n      {\\n        id: commentId,\\n        body,\\n        attachmentIds\\n      }\\n    );\\n    return convertToCommentData(comment);\\n  }\\n  async function editComment({\\n    threadId,\\n    commentId,\\n    body,\\n    attachmentIds\\n  }) {\\n    const comment = await httpClient2.post(\\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`,\\n      {\\n        body,\\n        attachmentIds\\n      }\\n    );\\n    return convertToCommentData(comment);\\n  }\\n  async function deleteComment({\\n    threadId,\\n    commentId\\n  }) {\\n    await httpClient2.delete(\\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}`\\n    );\\n  }\\n  async function addReaction({\\n    threadId,\\n    commentId,\\n    emoji\\n  }) {\\n    const reaction = await httpClient2.post(\\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions`,\\n      { emoji }\\n    );\\n    return convertToCommentUserReaction(reaction);\\n  }\\n  async function removeReaction({\\n    threadId,\\n    commentId,\\n    emoji\\n  }) {\\n    await httpClient2.delete(\\n      url`/v2/c/rooms/${config.roomId}/threads/${threadId}/comments/${commentId}/reactions/${emoji}`\\n    );\\n  }\\n  function prepareAttachment(file) {\\n    return {\\n      type: \\\"localAttachment\\\",\\n      status: \\\"idle\\\",\\n      id: createCommentAttachmentId(),\\n      name: file.name,\\n      size: file.size,\\n      mimeType: file.type,\\n      file\\n    };\\n  }\\n  async function uploadAttachment(attachment, options2 = {}) {\\n    const abortSignal = options2.signal;\\n    const abortError = abortSignal ? new DOMException(\\n      `Upload of attachment ${attachment.id} was aborted.`,\\n      \\\"AbortError\\\"\\n    ) : void 0;\\n    if (_optionalChain([abortSignal, 'optionalAccess', _146 => _146.aborted])) {\\n      throw abortError;\\n    }\\n    const handleRetryError = (err) => {\\n      if (_optionalChain([abortSignal, 'optionalAccess', _147 => _147.aborted])) {\\n        throw abortError;\\n      }\\n      if (err instanceof HttpError && err.status === 413) {\\n        throw err;\\n      }\\n      return false;\\n    };\\n    if (attachment.size <= ATTACHMENT_PART_SIZE) {\\n      return autoRetry(\\n        () => httpClient2.putBlob(\\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/upload/${encodeURIComponent(attachment.name)}`,\\n          attachment.file,\\n          { fileSize: attachment.size },\\n          { signal: abortSignal }\\n        ),\\n        RETRY_ATTEMPTS,\\n        RETRY_DELAYS,\\n        handleRetryError\\n      );\\n    } else {\\n      let uploadId;\\n      const uploadedParts = [];\\n      const createMultiPartUpload = await autoRetry(\\n        () => httpClient2.post(\\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${encodeURIComponent(attachment.name)}`,\\n          void 0,\\n          { signal: abortSignal },\\n          { fileSize: attachment.size }\\n        ),\\n        RETRY_ATTEMPTS,\\n        RETRY_DELAYS,\\n        handleRetryError\\n      );\\n      try {\\n        uploadId = createMultiPartUpload.uploadId;\\n        const parts = splitFileIntoParts(attachment.file);\\n        if (_optionalChain([abortSignal, 'optionalAccess', _148 => _148.aborted])) {\\n          throw abortError;\\n        }\\n        const batches = chunk(parts, ATTACHMENT_PART_BATCH_SIZE);\\n        for (const parts2 of batches) {\\n          const uploadedPartsPromises = [];\\n          for (const { part, partNumber } of parts2) {\\n            uploadedPartsPromises.push(\\n              autoRetry(\\n                () => httpClient2.putBlob(\\n                  url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${createMultiPartUpload.uploadId}/${String(partNumber)}`,\\n                  part,\\n                  void 0,\\n                  { signal: abortSignal }\\n                ),\\n                RETRY_ATTEMPTS,\\n                RETRY_DELAYS,\\n                handleRetryError\\n              )\\n            );\\n          }\\n          uploadedParts.push(...await Promise.all(uploadedPartsPromises));\\n        }\\n        if (_optionalChain([abortSignal, 'optionalAccess', _149 => _149.aborted])) {\\n          throw abortError;\\n        }\\n        const sortedUploadedParts = uploadedParts.sort(\\n          (a, b) => a.partNumber - b.partNumber\\n        );\\n        return httpClient2.post(\\n          url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}/complete`,\\n          { parts: sortedUploadedParts },\\n          { signal: abortSignal }\\n        );\\n      } catch (error3) {\\n        if (uploadId && _optionalChain([error3, 'optionalAccess', _150 => _150.name]) && (error3.name === \\\"AbortError\\\" || error3.name === \\\"TimeoutError\\\")) {\\n          try {\\n            await httpClient2.rawDelete(\\n              url`/v2/c/rooms/${config.roomId}/attachments/${attachment.id}/multipart/${uploadId}`\\n            );\\n          } catch (error4) {\\n          }\\n        }\\n        throw error3;\\n      }\\n    }\\n  }\\n  async function getAttachmentUrls(attachmentIds) {\\n    const { urls } = await httpClient2.post(url`/v2/c/rooms/${config.roomId}/attachments/presigned-urls`, {\\n      attachmentIds\\n    });\\n    return urls;\\n  }\\n  const batchedGetAttachmentUrls = new Batch(\\n    async (batchedAttachmentIds) => {\\n      const attachmentIds = batchedAttachmentIds.flat();\\n      const attachmentUrls = await getAttachmentUrls(attachmentIds);\\n      return attachmentUrls.map(\\n        (url2) => _nullishCoalesce(url2, () => ( new Error(\\\"There was an error while getting this attachment's URL\\\")))\\n      );\\n    },\\n    { delay: GET_ATTACHMENT_URLS_BATCH_DELAY }\\n  );\\n  const attachmentUrlsStore = createBatchStore(batchedGetAttachmentUrls);\\n  function getAttachmentUrl(attachmentId) {\\n    return batchedGetAttachmentUrls.get(attachmentId);\\n  }\\n  async function fetchNotificationsJson(endpoint, options2) {\\n    return await httpClient2.get(endpoint, void 0, options2);\\n  }\\n  function getNotificationSettings(options2) {\\n    return fetchNotificationsJson(\\n      url`/v2/c/rooms/${config.roomId}/notification-settings`,\\n      { signal: _optionalChain([options2, 'optionalAccess', _151 => _151.signal]) }\\n    );\\n  }\\n  function updateNotificationSettings(settings) {\\n    return fetchNotificationsJson(\\n      url`/v2/c/rooms/${config.roomId}/notification-settings`,\\n      {\\n        method: \\\"POST\\\",\\n        body: JSON.stringify(settings)\\n      }\\n    );\\n  }\\n  async function markInboxNotificationsAsRead(inboxNotificationIds) {\\n    await fetchNotificationsJson(\\n      url`/v2/c/rooms/${config.roomId}/inbox-notifications/read`,\\n      {\\n        method: \\\"POST\\\",\\n        body: JSON.stringify({ inboxNotificationIds })\\n      }\\n    );\\n  }\\n  const batchedMarkInboxNotificationsAsRead = new Batch(\\n    async (batchedInboxNotificationIds) => {\\n      const inboxNotificationIds = batchedInboxNotificationIds.flat();\\n      await markInboxNotificationsAsRead(inboxNotificationIds);\\n      return inboxNotificationIds;\\n    },\\n    { delay: 50 }\\n  );\\n  async function markInboxNotificationAsRead(inboxNotificationId) {\\n    await batchedMarkInboxNotificationsAsRead.get(inboxNotificationId);\\n  }\\n  return Object.defineProperty(\\n    {\\n      [kInternal]: {\\n        get presenceBuffer() {\\n          return deepClone(_nullishCoalesce(_optionalChain([context, 'access', _152 => _152.buffer, 'access', _153 => _153.presenceUpdates, 'optionalAccess', _154 => _154.data]), () => ( null)));\\n        },\\n        // prettier-ignore\\n        get undoStack() {\\n          return deepClone(context.undoStack);\\n        },\\n        // prettier-ignore\\n        get nodeCount() {\\n          return context.nodes.size;\\n        },\\n        // prettier-ignore\\n        getProvider() {\\n          return context.provider;\\n        },\\n        setProvider(provider) {\\n          context.provider = provider;\\n          context.onProviderUpdate.notify();\\n        },\\n        onProviderUpdate: context.onProviderUpdate.observable,\\n        // send metadata when using a text editor\\n        reportTextEditor,\\n        // create a text mention when using a text editor\\n        createTextMention,\\n        // delete a text mention when using a text editor\\n        deleteTextMention,\\n        // list versions of the document\\n        listTextVersions,\\n        // List versions of the document since the specified date\\n        listTextVersionsSince,\\n        // get a specific version\\n        getTextVersion,\\n        // create a version\\n        createTextVersion,\\n        // Support for the Liveblocks browser extension\\n        getSelf_forDevTools: () => selfAsTreeNode.current,\\n        getOthers_forDevTools: () => others_forDevTools.current,\\n        // prettier-ignore\\n        simulate: {\\n          // These exist only for our E2E testing app\\n          explicitClose: (event) => managedSocket._privateSendMachineEvent({ type: \\\"EXPLICIT_SOCKET_CLOSE\\\", event }),\\n          rawSend: (data) => managedSocket.send(data)\\n        },\\n        attachmentUrlsStore\\n      },\\n      id: config.roomId,\\n      subscribe: makeClassicSubscribeFn(events),\\n      connect: () => managedSocket.connect(),\\n      reconnect: () => managedSocket.reconnect(),\\n      disconnect: () => managedSocket.disconnect(),\\n      destroy: () => {\\n        uninstallBgTabSpy();\\n        managedSocket.destroy();\\n      },\\n      // Presence\\n      updatePresence,\\n      updateYDoc,\\n      broadcastEvent,\\n      // Storage\\n      batch,\\n      history: {\\n        undo,\\n        redo,\\n        canUndo,\\n        canRedo,\\n        clear,\\n        pause: pauseHistory,\\n        resume: resumeHistory\\n      },\\n      fetchYDoc,\\n      getStorage,\\n      getStorageSnapshot,\\n      getStorageStatus,\\n      isPresenceReady,\\n      isStorageReady,\\n      waitUntilPresenceReady: memoizeOnSuccess(waitUntilPresenceReady),\\n      waitUntilStorageReady: memoizeOnSuccess(waitUntilStorageReady),\\n      events,\\n      // Core\\n      getStatus: () => managedSocket.getStatus(),\\n      getSelf: () => self.current,\\n      // Presence\\n      getPresence: () => context.myPresence.current,\\n      getOthers: () => context.others.current,\\n      // Comments\\n      getThreads,\\n      getThreadsSince,\\n      getThread,\\n      createThread,\\n      deleteThread,\\n      editThreadMetadata,\\n      markThreadAsResolved,\\n      markThreadAsUnresolved,\\n      createComment,\\n      editComment,\\n      deleteComment,\\n      addReaction,\\n      removeReaction,\\n      prepareAttachment,\\n      uploadAttachment,\\n      getAttachmentUrl,\\n      // Notifications\\n      getNotificationSettings,\\n      updateNotificationSettings,\\n      markInboxNotificationAsRead\\n    },\\n    // Explictly make the internal field non-enumerable, to avoid aggressive\\n    // freezing when used with Immer\\n    kInternal,\\n    { enumerable: false }\\n  );\\n}\\nfunction makeClassicSubscribeFn(events) {\\n  function subscribeToLiveStructureDeeply(node, callback) {\\n    return events.storageBatch.subscribe((updates) => {\\n      const relatedUpdates = updates.filter(\\n        (update) => isSameNodeOrChildOf(update.node, node)\\n      );\\n      if (relatedUpdates.length > 0) {\\n        callback(relatedUpdates);\\n      }\\n    });\\n  }\\n  function subscribeToLiveStructureShallowly(node, callback) {\\n    return events.storageBatch.subscribe((updates) => {\\n      for (const update of updates) {\\n        if (update.node._id === node._id) {\\n          callback(update.node);\\n        }\\n      }\\n    });\\n  }\\n  function subscribe(first, second, options) {\\n    if (typeof first === \\\"string\\\" && isRoomEventName(first)) {\\n      if (typeof second !== \\\"function\\\") {\\n        throw new Error(\\\"Second argument must be a callback function\\\");\\n      }\\n      const callback = second;\\n      switch (first) {\\n        case \\\"event\\\":\\n          return events.customEvent.subscribe(\\n            callback\\n          );\\n        case \\\"my-presence\\\":\\n          return events.myPresence.subscribe(callback);\\n        case \\\"others\\\": {\\n          const cb = callback;\\n          return events.others.subscribe((event) => {\\n            const { others, ...internalEvent } = event;\\n            return cb(others, internalEvent);\\n          });\\n        }\\n        case \\\"error\\\":\\n          return events.error.subscribe(callback);\\n        case \\\"status\\\":\\n          return events.status.subscribe(callback);\\n        case \\\"lost-connection\\\":\\n          return events.lostConnection.subscribe(\\n            callback\\n          );\\n        case \\\"history\\\":\\n          return events.history.subscribe(callback);\\n        case \\\"storage-status\\\":\\n          return events.storageStatus.subscribe(\\n            callback\\n          );\\n        case \\\"comments\\\":\\n          return events.comments.subscribe(\\n            callback\\n          );\\n        default:\\n          return assertNever(\\n            first,\\n            `\\\"${String(first)}\\\" is not a valid event name`\\n          );\\n      }\\n    }\\n    if (second === void 0 || typeof first === \\\"function\\\") {\\n      if (typeof first === \\\"function\\\") {\\n        const storageCallback = first;\\n        return events.storageBatch.subscribe(storageCallback);\\n      } else {\\n        throw new Error(\\\"Please specify a listener callback\\\");\\n      }\\n    }\\n    if (isLiveNode(first)) {\\n      const node = first;\\n      if (_optionalChain([options, 'optionalAccess', _155 => _155.isDeep])) {\\n        const storageCallback = second;\\n        return subscribeToLiveStructureDeeply(node, storageCallback);\\n      } else {\\n        const nodeCallback = second;\\n        return subscribeToLiveStructureShallowly(node, nodeCallback);\\n      }\\n    }\\n    throw new Error(\\n      `${String(first)} is not a value that can be subscribed to.`\\n    );\\n  }\\n  return subscribe;\\n}\\nfunction isRoomEventName(value) {\\n  return value === \\\"my-presence\\\" || value === \\\"others\\\" || value === \\\"event\\\" || value === \\\"error\\\" || value === \\\"history\\\" || value === \\\"status\\\" || value === \\\"storage-status\\\" || value === \\\"lost-connection\\\" || value === \\\"connection\\\" || value === \\\"comments\\\";\\n}\\nfunction makeAuthDelegateForRoom(roomId, authManager) {\\n  return async () => {\\n    return authManager.getAuthValue({ requestedScope: \\\"room:read\\\", roomId });\\n  };\\n}\\nfunction makeCreateSocketDelegateForRoom(roomId, baseUrl, WebSocketPolyfill) {\\n  return (authValue) => {\\n    const ws = _nullishCoalesce(WebSocketPolyfill, () => ( (typeof WebSocket === \\\"undefined\\\" ? void 0 : WebSocket)));\\n    if (ws === void 0) {\\n      throw new StopRetrying(\\n        \\\"To use Liveblocks client in a non-DOM environment, you need to provide a WebSocket polyfill.\\\"\\n      );\\n    }\\n    const url2 = new URL(baseUrl);\\n    url2.protocol = url2.protocol === \\\"http:\\\" ? \\\"ws\\\" : \\\"wss\\\";\\n    url2.pathname = \\\"/v7\\\";\\n    url2.searchParams.set(\\\"roomId\\\", roomId);\\n    if (authValue.type === \\\"secret\\\") {\\n      url2.searchParams.set(\\\"tok\\\", authValue.token.raw);\\n    } else if (authValue.type === \\\"public\\\") {\\n      url2.searchParams.set(\\\"pubkey\\\", authValue.publicApiKey);\\n    } else {\\n      return assertNever(authValue, \\\"Unhandled case\\\");\\n    }\\n    url2.searchParams.set(\\\"version\\\", PKG_VERSION || \\\"dev\\\");\\n    return new ws(url2.toString());\\n  };\\n}\\n\\n// src/client.ts\\nvar MIN_THROTTLE = 16;\\nvar MAX_THROTTLE = 1e3;\\nvar DEFAULT_THROTTLE = 100;\\nvar MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT = 15e3;\\nvar MIN_LOST_CONNECTION_TIMEOUT = 200;\\nvar RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT = 1e3;\\nvar MAX_LOST_CONNECTION_TIMEOUT = 3e4;\\nvar DEFAULT_LOST_CONNECTION_TIMEOUT = 5e3;\\nvar RESOLVE_USERS_BATCH_DELAY = 50;\\nvar RESOLVE_ROOMS_INFO_BATCH_DELAY = 50;\\nfunction getBaseUrl(baseUrl) {\\n  if (typeof baseUrl === \\\"string\\\" && baseUrl.startsWith(\\\"http\\\")) {\\n    return baseUrl;\\n  } else {\\n    return DEFAULT_BASE_URL;\\n  }\\n}\\nfunction createClient(options) {\\n  const clientOptions = options;\\n  const throttleDelay = getThrottle(_nullishCoalesce(clientOptions.throttle, () => ( DEFAULT_THROTTLE)));\\n  const lostConnectionTimeout = getLostConnectionTimeout(\\n    _nullishCoalesce(clientOptions.lostConnectionTimeout, () => ( DEFAULT_LOST_CONNECTION_TIMEOUT))\\n  );\\n  const backgroundKeepAliveTimeout = getBackgroundKeepAliveTimeout(\\n    clientOptions.backgroundKeepAliveTimeout\\n  );\\n  const baseUrl = getBaseUrl(clientOptions.baseUrl);\\n  const authManager = createAuthManager(options);\\n  const roomsById = /* @__PURE__ */ new Map();\\n  function teardownRoom(room) {\\n    unlinkDevTools(room.id);\\n    roomsById.delete(room.id);\\n    room.destroy();\\n  }\\n  function leaseRoom(details) {\\n    const leave = () => {\\n      const self = leave;\\n      if (!details.unsubs.delete(self)) {\\n        warn(\\n          \\\"This leave function was already called. Calling it more than once has no effect.\\\"\\n        );\\n      } else {\\n        if (details.unsubs.size === 0) {\\n          teardownRoom(details.room);\\n        }\\n      }\\n    };\\n    details.unsubs.add(leave);\\n    return {\\n      room: details.room,\\n      leave\\n    };\\n  }\\n  function enterRoom(roomId, ...args) {\\n    const existing = roomsById.get(roomId);\\n    if (existing !== void 0) {\\n      return leaseRoom(existing);\\n    }\\n    const options2 = _nullishCoalesce(args[0], () => ( {}));\\n    const initialPresence = _nullishCoalesce((typeof options2.initialPresence === \\\"function\\\" ? options2.initialPresence(roomId) : options2.initialPresence), () => ( {}));\\n    const initialStorage = _nullishCoalesce((typeof options2.initialStorage === \\\"function\\\" ? options2.initialStorage(roomId) : options2.initialStorage), () => ( {}));\\n    const newRoom = createRoom(\\n      { initialPresence, initialStorage },\\n      {\\n        roomId,\\n        throttleDelay,\\n        lostConnectionTimeout,\\n        backgroundKeepAliveTimeout,\\n        polyfills: clientOptions.polyfills,\\n        delegates: _nullishCoalesce(clientOptions.mockedDelegates, () => ( {\\n          createSocket: makeCreateSocketDelegateForRoom(\\n            roomId,\\n            baseUrl,\\n            _optionalChain([clientOptions, 'access', _156 => _156.polyfills, 'optionalAccess', _157 => _157.WebSocket])\\n          ),\\n          authenticate: makeAuthDelegateForRoom(roomId, authManager)\\n        })),\\n        enableDebugLogging: clientOptions.enableDebugLogging,\\n        unstable_batchedUpdates: _optionalChain([options2, 'optionalAccess', _158 => _158.unstable_batchedUpdates]),\\n        baseUrl,\\n        unstable_fallbackToHTTP: !!clientOptions.unstable_fallbackToHTTP,\\n        unstable_streamData: !!clientOptions.unstable_streamData\\n      }\\n    );\\n    const newRoomDetails = {\\n      room: newRoom,\\n      unsubs: /* @__PURE__ */ new Set()\\n    };\\n    roomsById.set(roomId, newRoomDetails);\\n    setupDevTools(() => Array.from(roomsById.keys()));\\n    linkDevTools(roomId, newRoom);\\n    const shouldConnect = _nullishCoalesce(options2.autoConnect, () => ( true));\\n    if (shouldConnect) {\\n      if (typeof atob === \\\"undefined\\\") {\\n        if (_optionalChain([clientOptions, 'access', _159 => _159.polyfills, 'optionalAccess', _160 => _160.atob]) === void 0) {\\n          throw new Error(\\n            \\\"You need to polyfill atob to use the client in your environment. Please follow the instructions at https://liveblocks.io/docs/errors/liveblocks-client/atob-polyfill\\\"\\n          );\\n        }\\n        global.atob = clientOptions.polyfills.atob;\\n      }\\n      newRoom.connect();\\n    }\\n    return leaseRoom(newRoomDetails);\\n  }\\n  function getRoom(roomId) {\\n    const room = _optionalChain([roomsById, 'access', _161 => _161.get, 'call', _162 => _162(roomId), 'optionalAccess', _163 => _163.room]);\\n    return room ? room : null;\\n  }\\n  function logout() {\\n    authManager.reset();\\n    for (const { room } of roomsById.values()) {\\n      if (!isIdle(room.getStatus())) {\\n        room.reconnect();\\n      }\\n    }\\n  }\\n  const currentUserIdStore = createStore(null);\\n  const fetchPolyfill = _optionalChain([clientOptions, 'access', _164 => _164.polyfills, 'optionalAccess', _165 => _165.fetch]) || /* istanbul ignore next */\\n  _optionalChain([globalThis, 'access', _166 => _166.fetch, 'optionalAccess', _167 => _167.bind, 'call', _168 => _168(globalThis)]);\\n  const notificationsAPI = createNotificationsApi({\\n    baseUrl,\\n    fetchPolyfill,\\n    authManager,\\n    currentUserIdStore\\n  });\\n  const resolveUsers = clientOptions.resolveUsers;\\n  const warnIfNoResolveUsers = createDevelopmentWarning(\\n    () => !resolveUsers,\\n    \\\"Set the resolveUsers option in createClient to specify user info.\\\"\\n  );\\n  const batchedResolveUsers = new Batch(\\n    async (batchedUserIds) => {\\n      const userIds = batchedUserIds.flat();\\n      const users = await _optionalChain([resolveUsers, 'optionalCall', _169 => _169({ userIds })]);\\n      warnIfNoResolveUsers();\\n      return _nullishCoalesce(users, () => ( userIds.map(() => void 0)));\\n    },\\n    { delay: RESOLVE_USERS_BATCH_DELAY }\\n  );\\n  const usersStore = createBatchStore(batchedResolveUsers);\\n  function invalidateResolvedUsers(userIds) {\\n    usersStore.invalidate(userIds);\\n  }\\n  const resolveRoomsInfo = clientOptions.resolveRoomsInfo;\\n  const warnIfNoResolveRoomsInfo = createDevelopmentWarning(\\n    () => !resolveRoomsInfo,\\n    \\\"Set the resolveRoomsInfo option in createClient to specify room info.\\\"\\n  );\\n  const batchedResolveRoomsInfo = new Batch(\\n    async (batchedRoomIds) => {\\n      const roomIds = batchedRoomIds.flat();\\n      const roomsInfo = await _optionalChain([resolveRoomsInfo, 'optionalCall', _170 => _170({ roomIds })]);\\n      warnIfNoResolveRoomsInfo();\\n      return _nullishCoalesce(roomsInfo, () => ( roomIds.map(() => void 0)));\\n    },\\n    { delay: RESOLVE_ROOMS_INFO_BATCH_DELAY }\\n  );\\n  const roomsInfoStore = createBatchStore(batchedResolveRoomsInfo);\\n  function invalidateResolvedRoomsInfo(roomIds) {\\n    roomsInfoStore.invalidate(roomIds);\\n  }\\n  const mentionSuggestionsCache = /* @__PURE__ */ new Map();\\n  function invalidateResolvedMentionSuggestions() {\\n    mentionSuggestionsCache.clear();\\n  }\\n  const client = Object.defineProperty(\\n    {\\n      enterRoom,\\n      getRoom,\\n      logout,\\n      ...notificationsAPI,\\n      // Advanced resolvers APIs\\n      resolvers: {\\n        invalidateUsers: invalidateResolvedUsers,\\n        invalidateRoomsInfo: invalidateResolvedRoomsInfo,\\n        invalidateMentionSuggestions: invalidateResolvedMentionSuggestions\\n      },\\n      // Internal\\n      [kInternal]: {\\n        currentUserIdStore,\\n        mentionSuggestionsCache,\\n        resolveMentionSuggestions: clientOptions.resolveMentionSuggestions,\\n        usersStore,\\n        roomsInfoStore,\\n        getRoomIds() {\\n          return Array.from(roomsById.keys());\\n        },\\n        // \\\"All\\\" threads (= \\\"user\\\" threads)\\n        getUserThreads_experimental: notificationsAPI.getUserThreads_experimental,\\n        getUserThreadsSince_experimental: notificationsAPI.getUserThreadsSince_experimental,\\n        // Type-level helper only, it's effectively only an identity-function at runtime\\n        as: () => client\\n      }\\n    },\\n    kInternal,\\n    {\\n      enumerable: false\\n    }\\n  );\\n  return client;\\n}\\nfunction checkBounds(option, value, min, max, recommendedMin) {\\n  if (typeof value !== \\\"number\\\" || value < min || max !== void 0 && value > max) {\\n    throw new Error(\\n      max !== void 0 ? `${option} should be between ${_nullishCoalesce(recommendedMin, () => ( min))} and ${max}.` : `${option} should be at least ${_nullishCoalesce(recommendedMin, () => ( min))}.`\\n    );\\n  }\\n  return value;\\n}\\nfunction getBackgroundKeepAliveTimeout(value) {\\n  if (value === void 0) return void 0;\\n  return checkBounds(\\n    \\\"backgroundKeepAliveTimeout\\\",\\n    value,\\n    MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\\n  );\\n}\\nfunction getThrottle(value) {\\n  return checkBounds(\\\"throttle\\\", value, MIN_THROTTLE, MAX_THROTTLE);\\n}\\nfunction getLostConnectionTimeout(value) {\\n  return checkBounds(\\n    \\\"lostConnectionTimeout\\\",\\n    value,\\n    MIN_LOST_CONNECTION_TIMEOUT,\\n    MAX_LOST_CONNECTION_TIMEOUT,\\n    RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\\n  );\\n}\\nfunction createDevelopmentWarning(condition, ...args) {\\n  let hasWarned = false;\\n  if (process.env.NODE_ENV !== \\\"production\\\") {\\n    return () => {\\n      if (!hasWarned && (typeof condition === \\\"function\\\" ? condition() : condition)) {\\n        warn(...args);\\n        hasWarned = true;\\n      }\\n    };\\n  } else {\\n    return () => {\\n    };\\n  }\\n}\\n\\n// src/comments/comment-body.ts\\nfunction isCommentBodyParagraph(element) {\\n  return \\\"type\\\" in element && element.type === \\\"paragraph\\\";\\n}\\nfunction isCommentBodyText(element) {\\n  return !(\\\"type\\\" in element) && \\\"text\\\" in element && typeof element.text === \\\"string\\\";\\n}\\nfunction isCommentBodyMention(element) {\\n  return \\\"type\\\" in element && element.type === \\\"mention\\\";\\n}\\nfunction isCommentBodyLink(element) {\\n  return \\\"type\\\" in element && element.type === \\\"link\\\";\\n}\\nvar commentBodyElementsGuards = {\\n  paragraph: isCommentBodyParagraph,\\n  text: isCommentBodyText,\\n  link: isCommentBodyLink,\\n  mention: isCommentBodyMention\\n};\\nvar commentBodyElementsTypes = {\\n  paragraph: \\\"block\\\",\\n  text: \\\"inline\\\",\\n  link: \\\"inline\\\",\\n  mention: \\\"inline\\\"\\n};\\nfunction traverseCommentBody(body, elementOrVisitor, possiblyVisitor) {\\n  if (!body || !_optionalChain([body, 'optionalAccess', _171 => _171.content])) {\\n    return;\\n  }\\n  const element = typeof elementOrVisitor === \\\"string\\\" ? elementOrVisitor : void 0;\\n  const type = element ? commentBodyElementsTypes[element] : \\\"all\\\";\\n  const guard = element ? commentBodyElementsGuards[element] : () => true;\\n  const visitor = typeof elementOrVisitor === \\\"function\\\" ? elementOrVisitor : possiblyVisitor;\\n  for (const block of body.content) {\\n    if (type === \\\"all\\\" || type === \\\"block\\\") {\\n      if (guard(block)) {\\n        _optionalChain([visitor, 'optionalCall', _172 => _172(block)]);\\n      }\\n    }\\n    if (type === \\\"all\\\" || type === \\\"inline\\\") {\\n      for (const inline of block.children) {\\n        if (guard(inline)) {\\n          _optionalChain([visitor, 'optionalCall', _173 => _173(inline)]);\\n        }\\n      }\\n    }\\n  }\\n}\\nfunction getMentionedIdsFromCommentBody(body) {\\n  const mentionedIds = /* @__PURE__ */ new Set();\\n  traverseCommentBody(\\n    body,\\n    \\\"mention\\\",\\n    (mention) => mentionedIds.add(mention.id)\\n  );\\n  return Array.from(mentionedIds);\\n}\\nasync function resolveUsersInCommentBody(body, resolveUsers) {\\n  const resolvedUsers = /* @__PURE__ */ new Map();\\n  if (!resolveUsers) {\\n    return resolvedUsers;\\n  }\\n  const userIds = getMentionedIdsFromCommentBody(body);\\n  const users = await resolveUsers({\\n    userIds\\n  });\\n  for (const [index, userId] of userIds.entries()) {\\n    const user = _optionalChain([users, 'optionalAccess', _174 => _174[index]]);\\n    if (user) {\\n      resolvedUsers.set(userId, user);\\n    }\\n  }\\n  return resolvedUsers;\\n}\\nvar htmlEscapables = {\\n  \\\"&\\\": \\\"&amp;\\\",\\n  \\\"<\\\": \\\"&lt;\\\",\\n  \\\">\\\": \\\"&gt;\\\",\\n  '\\\"': \\\"&quot;\\\",\\n  \\\"'\\\": \\\"&#39;\\\"\\n};\\nvar htmlEscapablesRegex = new RegExp(\\n  Object.keys(htmlEscapables).map((entity) => `\\\\\\\\${entity}`).join(\\\"|\\\"),\\n  \\\"g\\\"\\n);\\nfunction htmlSafe(value) {\\n  return new HtmlSafeString([String(value)], []);\\n}\\nfunction joinHtml(strings) {\\n  if (strings.length <= 0) {\\n    return new HtmlSafeString([\\\"\\\"], []);\\n  }\\n  return new HtmlSafeString(\\n    [\\\"\\\", ...Array(strings.length - 1).fill(\\\"\\\"), \\\"\\\"],\\n    strings\\n  );\\n}\\nfunction escapeHtml(value) {\\n  if (value instanceof HtmlSafeString) {\\n    return value.toString();\\n  }\\n  if (Array.isArray(value)) {\\n    return joinHtml(value).toString();\\n  }\\n  return String(value).replace(\\n    htmlEscapablesRegex,\\n    (character) => htmlEscapables[character]\\n  );\\n}\\nvar HtmlSafeString = class {\\n  constructor(strings, values) {\\n    this._strings = strings;\\n    this._values = values;\\n  }\\n  toString() {\\n    return this._strings.reduce((result, str, i) => {\\n      return result + escapeHtml(nn(this._values[i - 1])) + str;\\n    });\\n  }\\n};\\nfunction html(strings, ...values) {\\n  return new HtmlSafeString(strings, values);\\n}\\nvar markdownEscapables = {\\n  _: \\\"\\\\\\\\_\\\",\\n  \\\"*\\\": \\\"\\\\\\\\*\\\",\\n  \\\"#\\\": \\\"\\\\\\\\#\\\",\\n  \\\"`\\\": \\\"\\\\\\\\`\\\",\\n  \\\"~\\\": \\\"\\\\\\\\~\\\",\\n  \\\"!\\\": \\\"\\\\\\\\!\\\",\\n  \\\"|\\\": \\\"\\\\\\\\|\\\",\\n  \\\"(\\\": \\\"\\\\\\\\(\\\",\\n  \\\")\\\": \\\"\\\\\\\\)\\\",\\n  \\\"{\\\": \\\"\\\\\\\\{\\\",\\n  \\\"}\\\": \\\"\\\\\\\\}\\\",\\n  \\\"[\\\": \\\"\\\\\\\\[\\\",\\n  \\\"]\\\": \\\"\\\\\\\\]\\\"\\n};\\nvar markdownEscapablesRegex = new RegExp(\\n  Object.keys(markdownEscapables).map((entity) => `\\\\\\\\${entity}`).join(\\\"|\\\"),\\n  \\\"g\\\"\\n);\\nfunction joinMarkdown(strings) {\\n  if (strings.length <= 0) {\\n    return new MarkdownSafeString([\\\"\\\"], []);\\n  }\\n  return new MarkdownSafeString(\\n    [\\\"\\\", ...Array(strings.length - 1).fill(\\\"\\\"), \\\"\\\"],\\n    strings\\n  );\\n}\\nfunction escapeMarkdown(value) {\\n  if (value instanceof MarkdownSafeString) {\\n    return value.toString();\\n  }\\n  if (Array.isArray(value)) {\\n    return joinMarkdown(value).toString();\\n  }\\n  return String(value).replace(\\n    markdownEscapablesRegex,\\n    (character) => markdownEscapables[character]\\n  );\\n}\\nvar MarkdownSafeString = class {\\n  constructor(strings, values) {\\n    this._strings = strings;\\n    this._values = values;\\n  }\\n  toString() {\\n    return this._strings.reduce((result, str, i) => {\\n      return result + escapeMarkdown(nn(this._values[i - 1])) + str;\\n    });\\n  }\\n};\\nfunction markdown(strings, ...values) {\\n  return new MarkdownSafeString(strings, values);\\n}\\nfunction toAbsoluteUrl(url2) {\\n  if (url2.startsWith(\\\"http://\\\") || url2.startsWith(\\\"https://\\\")) {\\n    return url2;\\n  } else if (url2.startsWith(\\\"www.\\\")) {\\n    return \\\"https://\\\" + url2;\\n  }\\n  return;\\n}\\nvar stringifyCommentBodyPlainElements = {\\n  paragraph: ({ children }) => children,\\n  text: ({ element }) => element.text,\\n  link: ({ element }) => _nullishCoalesce(element.text, () => ( element.url)),\\n  mention: ({ element, user }) => {\\n    return `@${_nullishCoalesce(_optionalChain([user, 'optionalAccess', _175 => _175.name]), () => ( element.id))}`;\\n  }\\n};\\nvar stringifyCommentBodyHtmlElements = {\\n  paragraph: ({ children }) => {\\n    return children ? html`<p>${htmlSafe(children)}</p>` : children;\\n  },\\n  text: ({ element }) => {\\n    let children = element.text;\\n    if (!children) {\\n      return children;\\n    }\\n    if (element.bold) {\\n      children = html`<strong>${children}</strong>`;\\n    }\\n    if (element.italic) {\\n      children = html`<em>${children}</em>`;\\n    }\\n    if (element.strikethrough) {\\n      children = html`<s>${children}</s>`;\\n    }\\n    if (element.code) {\\n      children = html`<code>${children}</code>`;\\n    }\\n    return children;\\n  },\\n  link: ({ element, href }) => {\\n    return html`<a href=\\\"${href}\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">${_nullishCoalesce(element.text, () => ( element.url))}</a>`;\\n  },\\n  mention: ({ element, user }) => {\\n    return html`<span data-mention>@${_nullishCoalesce(_optionalChain([user, 'optionalAccess', _176 => _176.name]), () => ( element.id))}</span>`;\\n  }\\n};\\nvar stringifyCommentBodyMarkdownElements = {\\n  paragraph: ({ children }) => {\\n    return children;\\n  },\\n  text: ({ element }) => {\\n    let children = element.text;\\n    if (!children) {\\n      return children;\\n    }\\n    if (element.bold) {\\n      children = markdown`**${children}**`;\\n    }\\n    if (element.italic) {\\n      children = markdown`_${children}_`;\\n    }\\n    if (element.strikethrough) {\\n      children = markdown`~~${children}~~`;\\n    }\\n    if (element.code) {\\n      children = markdown`\\\\`${children}\\\\``;\\n    }\\n    return children;\\n  },\\n  link: ({ element, href }) => {\\n    return markdown`[${_nullishCoalesce(element.text, () => ( element.url))}](${href})`;\\n  },\\n  mention: ({ element, user }) => {\\n    return markdown`@${_nullishCoalesce(_optionalChain([user, 'optionalAccess', _177 => _177.name]), () => ( element.id))}`;\\n  }\\n};\\nasync function stringifyCommentBody(body, options) {\\n  const format = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _178 => _178.format]), () => ( \\\"plain\\\"));\\n  const separator = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _179 => _179.separator]), () => ( (format === \\\"markdown\\\" ? \\\"\\\\n\\\\n\\\" : \\\"\\\\n\\\")));\\n  const elements = {\\n    ...format === \\\"html\\\" ? stringifyCommentBodyHtmlElements : format === \\\"markdown\\\" ? stringifyCommentBodyMarkdownElements : stringifyCommentBodyPlainElements,\\n    ..._optionalChain([options, 'optionalAccess', _180 => _180.elements])\\n  };\\n  const resolvedUsers = await resolveUsersInCommentBody(\\n    body,\\n    _optionalChain([options, 'optionalAccess', _181 => _181.resolveUsers])\\n  );\\n  const blocks = body.content.flatMap((block, blockIndex) => {\\n    switch (block.type) {\\n      case \\\"paragraph\\\": {\\n        const inlines = block.children.flatMap((inline, inlineIndex) => {\\n          if (isCommentBodyMention(inline)) {\\n            return inline.id ? [\\n              elements.mention(\\n                {\\n                  element: inline,\\n                  user: resolvedUsers.get(inline.id)\\n                },\\n                inlineIndex\\n              )\\n            ] : [];\\n          }\\n          if (isCommentBodyLink(inline)) {\\n            return [\\n              elements.link(\\n                {\\n                  element: inline,\\n                  href: _nullishCoalesce(toAbsoluteUrl(inline.url), () => ( inline.url))\\n                },\\n                inlineIndex\\n              )\\n            ];\\n          }\\n          if (isCommentBodyText(inline)) {\\n            return [elements.text({ element: inline }, inlineIndex)];\\n          }\\n          return [];\\n        });\\n        return [\\n          elements.paragraph(\\n            { element: block, children: inlines.join(\\\"\\\") },\\n            blockIndex\\n          )\\n        ];\\n      }\\n      default:\\n        return [];\\n    }\\n  });\\n  return blocks.join(separator);\\n}\\n\\n// src/crdts/utils.ts\\nfunction toPlainLson(lson) {\\n  if (lson instanceof LiveObject) {\\n    return {\\n      liveblocksType: \\\"LiveObject\\\",\\n      data: Object.fromEntries(\\n        Object.entries(lson.toObject()).flatMap(\\n          ([key, value]) => value !== void 0 ? [[key, toPlainLson(value)]] : []\\n        )\\n      )\\n    };\\n  } else if (lson instanceof LiveMap) {\\n    return {\\n      liveblocksType: \\\"LiveMap\\\",\\n      data: Object.fromEntries(\\n        [...lson].map(([key, value]) => [key, toPlainLson(value)])\\n      )\\n    };\\n  } else if (lson instanceof LiveList) {\\n    return {\\n      liveblocksType: \\\"LiveList\\\",\\n      data: [...lson].map((item) => toPlainLson(item))\\n    };\\n  } else {\\n    return lson;\\n  }\\n}\\n\\n// src/immutable.ts\\nfunction lsonObjectToJson(obj) {\\n  const result = {};\\n  for (const key in obj) {\\n    const val = obj[key];\\n    if (val !== void 0) {\\n      result[key] = lsonToJson(val);\\n    }\\n  }\\n  return result;\\n}\\nfunction liveObjectToJson(liveObject) {\\n  return lsonObjectToJson(liveObject.toObject());\\n}\\nfunction liveMapToJson(map) {\\n  const result = {};\\n  for (const [key, value] of map.entries()) {\\n    result[key] = lsonToJson(value);\\n  }\\n  return result;\\n}\\nfunction lsonListToJson(value) {\\n  return value.map(lsonToJson);\\n}\\nfunction liveListToJson(value) {\\n  return lsonListToJson(value.toArray());\\n}\\nfunction lsonToJson(value) {\\n  if (value instanceof LiveObject) {\\n    return liveObjectToJson(value);\\n  } else if (value instanceof LiveList) {\\n    return liveListToJson(value);\\n  } else if (value instanceof LiveMap) {\\n    return liveMapToJson(value);\\n  } else if (value instanceof LiveRegister) {\\n    return value.data;\\n  }\\n  if (Array.isArray(value)) {\\n    return lsonListToJson(value);\\n  } else if (isPlainObject(value)) {\\n    return lsonObjectToJson(value);\\n  }\\n  return value;\\n}\\nfunction deepLiveify(value) {\\n  if (Array.isArray(value)) {\\n    return new LiveList(value.map(deepLiveify));\\n  } else if (isPlainObject(value)) {\\n    const init = {};\\n    for (const key in value) {\\n      const val = value[key];\\n      if (val === void 0) {\\n        continue;\\n      }\\n      init[key] = deepLiveify(val);\\n    }\\n    return new LiveObject(init);\\n  } else {\\n    return value;\\n  }\\n}\\nfunction patchLiveList(liveList, prev, next) {\\n  let i = 0;\\n  let prevEnd = prev.length - 1;\\n  let nextEnd = next.length - 1;\\n  let prevNode = prev[0];\\n  let nextNode = next[0];\\n  outer: {\\n    while (prevNode === nextNode) {\\n      ++i;\\n      if (i > prevEnd || i > nextEnd) {\\n        break outer;\\n      }\\n      prevNode = prev[i];\\n      nextNode = next[i];\\n    }\\n    prevNode = prev[prevEnd];\\n    nextNode = next[nextEnd];\\n    while (prevNode === nextNode) {\\n      prevEnd--;\\n      nextEnd--;\\n      if (i > prevEnd || i > nextEnd) {\\n        break outer;\\n      }\\n      prevNode = prev[prevEnd];\\n      nextNode = next[nextEnd];\\n    }\\n  }\\n  if (i > prevEnd) {\\n    if (i <= nextEnd) {\\n      while (i <= nextEnd) {\\n        liveList.insert(deepLiveify(next[i]), i);\\n        i++;\\n      }\\n    }\\n  } else if (i > nextEnd) {\\n    let localI = i;\\n    while (localI <= prevEnd) {\\n      liveList.delete(i);\\n      localI++;\\n    }\\n  } else {\\n    while (i <= prevEnd && i <= nextEnd) {\\n      prevNode = prev[i];\\n      nextNode = next[i];\\n      const liveListNode = liveList.get(i);\\n      if (isLiveObject(liveListNode) && isPlainObject(prevNode) && isPlainObject(nextNode)) {\\n        patchLiveObject(liveListNode, prevNode, nextNode);\\n      } else {\\n        liveList.set(i, deepLiveify(nextNode));\\n      }\\n      i++;\\n    }\\n    while (i <= nextEnd) {\\n      liveList.insert(deepLiveify(next[i]), i);\\n      i++;\\n    }\\n    let localI = i;\\n    while (localI <= prevEnd) {\\n      liveList.delete(i);\\n      localI++;\\n    }\\n  }\\n}\\nfunction patchLiveObjectKey(liveObject, key, prev, next) {\\n  if (process.env.NODE_ENV !== \\\"production\\\") {\\n    const nonSerializableValue = findNonSerializableValue(next);\\n    if (nonSerializableValue) {\\n      error2(\\n        `New state path: '${nonSerializableValue.path}' value: '${String(\\n          nonSerializableValue.value\\n        )}' is not serializable.\\nOnly serializable value can be synced with Liveblocks.`\\n      );\\n      return;\\n    }\\n  }\\n  const value = liveObject.get(key);\\n  if (next === void 0) {\\n    liveObject.delete(key);\\n  } else if (value === void 0) {\\n    liveObject.set(key, deepLiveify(next));\\n  } else if (prev === next) {\\n    return;\\n  } else if (isLiveList(value) && Array.isArray(prev) && Array.isArray(next)) {\\n    patchLiveList(value, prev, next);\\n  } else if (isLiveObject(value) && isPlainObject(prev) && isPlainObject(next)) {\\n    patchLiveObject(value, prev, next);\\n  } else {\\n    liveObject.set(key, deepLiveify(next));\\n  }\\n}\\nfunction patchLiveObject(root, prev, next) {\\n  const updates = {};\\n  for (const key in next) {\\n    patchLiveObjectKey(root, key, prev[key], next[key]);\\n  }\\n  for (const key in prev) {\\n    if (next[key] === void 0) {\\n      root.delete(key);\\n    }\\n  }\\n  if (Object.keys(updates).length > 0) {\\n    root.update(updates);\\n  }\\n}\\nfunction getParentsPath(node) {\\n  const path = [];\\n  while (node.parent.type === \\\"HasParent\\\") {\\n    if (isLiveList(node.parent.node)) {\\n      path.push(node.parent.node._indexOfPosition(node.parent.key));\\n    } else {\\n      path.push(node.parent.key);\\n    }\\n    node = node.parent.node;\\n  }\\n  return path;\\n}\\nfunction legacy_patchImmutableObject(state, updates) {\\n  return updates.reduce(\\n    (state2, update) => legacy_patchImmutableObjectWithUpdate(state2, update),\\n    state\\n  );\\n}\\nfunction legacy_patchImmutableObjectWithUpdate(state, update) {\\n  const path = getParentsPath(update.node);\\n  return legacy_patchImmutableNode(state, path, update);\\n}\\nfunction legacy_patchImmutableNode(state, path, update) {\\n  const pathItem = path.pop();\\n  if (pathItem === void 0) {\\n    switch (update.type) {\\n      case \\\"LiveObject\\\": {\\n        if (!isJsonObject(state)) {\\n          throw new Error(\\n            \\\"Internal: received update on LiveObject but state was not an object\\\"\\n          );\\n        }\\n        const newState = Object.assign({}, state);\\n        for (const key in update.updates) {\\n          if (_optionalChain([update, 'access', _182 => _182.updates, 'access', _183 => _183[key], 'optionalAccess', _184 => _184.type]) === \\\"update\\\") {\\n            const val = update.node.get(key);\\n            if (val !== void 0) {\\n              newState[key] = lsonToJson(val);\\n            }\\n          } else if (_optionalChain([update, 'access', _185 => _185.updates, 'access', _186 => _186[key], 'optionalAccess', _187 => _187.type]) === \\\"delete\\\") {\\n            delete newState[key];\\n          }\\n        }\\n        return newState;\\n      }\\n      case \\\"LiveList\\\": {\\n        if (!Array.isArray(state)) {\\n          throw new Error(\\n            \\\"Internal: received update on LiveList but state was not an array\\\"\\n          );\\n        }\\n        let newState = state.map((x) => x);\\n        for (const listUpdate of update.updates) {\\n          if (listUpdate.type === \\\"set\\\") {\\n            newState = newState.map(\\n              (item, index) => index === listUpdate.index ? lsonToJson(listUpdate.item) : item\\n            );\\n          } else if (listUpdate.type === \\\"insert\\\") {\\n            if (listUpdate.index === newState.length) {\\n              newState.push(lsonToJson(listUpdate.item));\\n            } else {\\n              newState = [\\n                ...newState.slice(0, listUpdate.index),\\n                lsonToJson(listUpdate.item),\\n                ...newState.slice(listUpdate.index)\\n              ];\\n            }\\n          } else if (listUpdate.type === \\\"delete\\\") {\\n            newState.splice(listUpdate.index, 1);\\n          } else if (listUpdate.type === \\\"move\\\") {\\n            if (listUpdate.previousIndex > listUpdate.index) {\\n              newState = [\\n                ...newState.slice(0, listUpdate.index),\\n                lsonToJson(listUpdate.item),\\n                ...newState.slice(listUpdate.index, listUpdate.previousIndex),\\n                ...newState.slice(listUpdate.previousIndex + 1)\\n              ];\\n            } else {\\n              newState = [\\n                ...newState.slice(0, listUpdate.previousIndex),\\n                ...newState.slice(\\n                  listUpdate.previousIndex + 1,\\n                  listUpdate.index + 1\\n                ),\\n                lsonToJson(listUpdate.item),\\n                ...newState.slice(listUpdate.index + 1)\\n              ];\\n            }\\n          }\\n        }\\n        return newState;\\n      }\\n      case \\\"LiveMap\\\": {\\n        if (!isJsonObject(state)) {\\n          throw new Error(\\n            \\\"Internal: received update on LiveMap but state was not an object\\\"\\n          );\\n        }\\n        const newState = Object.assign({}, state);\\n        for (const key in update.updates) {\\n          if (_optionalChain([update, 'access', _188 => _188.updates, 'access', _189 => _189[key], 'optionalAccess', _190 => _190.type]) === \\\"update\\\") {\\n            const value = update.node.get(key);\\n            if (value !== void 0) {\\n              newState[key] = lsonToJson(value);\\n            }\\n          } else if (_optionalChain([update, 'access', _191 => _191.updates, 'access', _192 => _192[key], 'optionalAccess', _193 => _193.type]) === \\\"delete\\\") {\\n            delete newState[key];\\n          }\\n        }\\n        return newState;\\n      }\\n    }\\n  }\\n  if (Array.isArray(state)) {\\n    const newArray = [...state];\\n    newArray[pathItem] = legacy_patchImmutableNode(\\n      state[pathItem],\\n      path,\\n      update\\n    );\\n    return newArray;\\n  } else if (isJsonObject(state)) {\\n    const node = state[pathItem];\\n    if (node === void 0) {\\n      return state;\\n    } else {\\n      const stateAsObj = state;\\n      return {\\n        ...stateAsObj,\\n        [pathItem]: legacy_patchImmutableNode(node, path, update)\\n      };\\n    }\\n  } else {\\n    return state;\\n  }\\n}\\n\\n// src/lib/deprecation.ts\\nvar _emittedDeprecationWarnings = /* @__PURE__ */ new Set();\\nfunction deprecate(message, key = message) {\\n  if (process.env.NODE_ENV !== \\\"production\\\") {\\n    if (!_emittedDeprecationWarnings.has(key)) {\\n      _emittedDeprecationWarnings.add(key);\\n      errorWithTitle(\\\"Deprecation warning\\\", message);\\n    }\\n  }\\n}\\nfunction deprecateIf(condition, message, key = message) {\\n  if (process.env.NODE_ENV !== \\\"production\\\") {\\n    if (condition) {\\n      deprecate(message, key);\\n    }\\n  }\\n}\\nfunction throwUsageError(message) {\\n  if (process.env.NODE_ENV !== \\\"production\\\") {\\n    const usageError = new Error(message);\\n    usageError.name = \\\"Usage error\\\";\\n    errorWithTitle(\\\"Usage error\\\", message);\\n    throw usageError;\\n  }\\n}\\nfunction errorIf(condition, message) {\\n  if (process.env.NODE_ENV !== \\\"production\\\") {\\n    if (condition) {\\n      throwUsageError(message);\\n    }\\n  }\\n}\\n\\n// src/lib/Poller.ts\\nvar BACKOFF_DELAYS2 = [1e3, 2e3, 4e3, 8e3, 1e4];\\nfunction makePoller(callback, intervalMs, options) {\\n  const startTime = performance.now();\\n  const doc = typeof document !== \\\"undefined\\\" ? document : void 0;\\n  const win = typeof window !== \\\"undefined\\\" ? window : void 0;\\n  const maxStaleTimeMs = _nullishCoalesce(_optionalChain([options, 'optionalAccess', _194 => _194.maxStaleTimeMs]), () => ( Number.POSITIVE_INFINITY));\\n  const context = {\\n    inForeground: _optionalChain([doc, 'optionalAccess', _195 => _195.visibilityState]) !== \\\"hidden\\\",\\n    lastSuccessfulPollAt: startTime,\\n    count: 0,\\n    backoff: 0\\n  };\\n  function mayPoll() {\\n    return context.count > 0 && context.inForeground;\\n  }\\n  const fsm = new FSM({}).addState(\\\"@idle\\\").addState(\\\"@enabled\\\").addState(\\\"@polling\\\");\\n  fsm.addTransitions(\\\"@idle\\\", { START: \\\"@enabled\\\" });\\n  fsm.addTransitions(\\\"@enabled\\\", { STOP: \\\"@idle\\\", POLL: \\\"@polling\\\" });\\n  fsm.addTimedTransition(\\n    \\\"@enabled\\\",\\n    () => {\\n      const lastPoll = context.lastSuccessfulPollAt;\\n      const nextPoll = lastPoll + intervalMs;\\n      return Math.max(0, nextPoll - performance.now()) + context.backoff;\\n    },\\n    \\\"@polling\\\"\\n  );\\n  fsm.onEnterAsync(\\n    \\\"@polling\\\",\\n    async (_ctx, signal) => {\\n      await callback(signal);\\n      if (!signal.aborted) {\\n        context.lastSuccessfulPollAt = performance.now();\\n      }\\n    },\\n    // When OK\\n    () => {\\n      return {\\n        target: mayPoll() ? \\\"@enabled\\\" : \\\"@idle\\\",\\n        effect: () => {\\n          context.backoff = 0;\\n        }\\n      };\\n    },\\n    // When error\\n    () => {\\n      return {\\n        target: mayPoll() ? \\\"@enabled\\\" : \\\"@idle\\\",\\n        effect: () => {\\n          context.backoff = _nullishCoalesce(BACKOFF_DELAYS2.find((delay) => delay > context.backoff), () => ( BACKOFF_DELAYS2[BACKOFF_DELAYS2.length - 1]));\\n        }\\n      };\\n    },\\n    3e4\\n    // Abort the poll if the callback takes more than 30 seconds to complete\\n  );\\n  function startOrStop() {\\n    if (mayPoll()) {\\n      fsm.send({ type: \\\"START\\\" });\\n    } else {\\n      fsm.send({ type: \\\"STOP\\\" });\\n    }\\n  }\\n  function inc() {\\n    context.count++;\\n    startOrStop();\\n  }\\n  function dec() {\\n    context.count--;\\n    if (context.count < 0) {\\n      context.count = 0;\\n    }\\n    startOrStop();\\n  }\\n  function pollNowIfStale() {\\n    if (performance.now() - context.lastSuccessfulPollAt > maxStaleTimeMs) {\\n      fsm.send({ type: \\\"POLL\\\" });\\n    }\\n  }\\n  function setInForeground(inForeground) {\\n    context.inForeground = inForeground;\\n    startOrStop();\\n    pollNowIfStale();\\n  }\\n  function onVisibilityChange() {\\n    setInForeground(_optionalChain([doc, 'optionalAccess', _196 => _196.visibilityState]) !== \\\"hidden\\\");\\n  }\\n  _optionalChain([doc, 'optionalAccess', _197 => _197.addEventListener, 'call', _198 => _198(\\\"visibilitychange\\\", onVisibilityChange)]);\\n  _optionalChain([win, 'optionalAccess', _199 => _199.addEventListener, 'call', _200 => _200(\\\"online\\\", onVisibilityChange)]);\\n  fsm.start();\\n  return {\\n    inc,\\n    dec,\\n    pollNowIfStale,\\n    // Internal API, used by unit tests only to simulate visibility events\\n    setInForeground\\n  };\\n}\\n\\n// src/lib/shallow.ts\\nfunction shallowArray(xs, ys) {\\n  if (xs.length !== ys.length) {\\n    return false;\\n  }\\n  for (let i = 0; i < xs.length; i++) {\\n    if (!Object.is(xs[i], ys[i])) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\nfunction shallowObj(objA, objB) {\\n  if (!isPlainObject(objA) || !isPlainObject(objB)) {\\n    return false;\\n  }\\n  const keysA = Object.keys(objA);\\n  if (keysA.length !== Object.keys(objB).length) {\\n    return false;\\n  }\\n  return keysA.every(\\n    (key) => Object.prototype.hasOwnProperty.call(objB, key) && Object.is(objA[key], objB[key])\\n  );\\n}\\nfunction shallow(a, b) {\\n  if (Object.is(a, b)) {\\n    return true;\\n  }\\n  const isArrayA = Array.isArray(a);\\n  const isArrayB = Array.isArray(b);\\n  if (isArrayA || isArrayB) {\\n    if (!isArrayA || !isArrayB) {\\n      return false;\\n    }\\n    return shallowArray(a, b);\\n  }\\n  return shallowObj(a, b);\\n}\\n\\n// src/lib/SortedList.ts\\nfunction bisectRight(arr, x, lt) {\\n  let lo = 0;\\n  let hi = arr.length;\\n  while (lo < hi) {\\n    const mid = lo + (hi - lo >> 1);\\n    if (lt(x, arr[mid])) {\\n      hi = mid;\\n    } else {\\n      lo = mid + 1;\\n    }\\n  }\\n  return lo;\\n}\\nvar SortedList = class _SortedList {\\n  constructor(alreadySortedList, lt) {\\n    this._lt = lt;\\n    this._data = alreadySortedList;\\n  }\\n  static from(arr, lt) {\\n    const sorted = new _SortedList([], lt);\\n    for (const item of arr) {\\n      sorted.add(item);\\n    }\\n    return sorted;\\n  }\\n  static fromAlreadySorted(alreadySorted, lt) {\\n    return new _SortedList(alreadySorted, lt);\\n  }\\n  /**\\n   * Clones the sorted list to a new instance.\\n   */\\n  clone() {\\n    return new _SortedList(this._data.slice(), this._lt);\\n  }\\n  /**\\n   * Adds a new item to the sorted list, such that it remains sorted.\\n   */\\n  add(value) {\\n    const idx = bisectRight(this._data, value, this._lt);\\n    this._data.splice(idx, 0, value);\\n  }\\n  /**\\n   * Removes the given value from the sorted list, if it exists. The given\\n   * value must be `===` to one of the list items. Only the first entry will be\\n   * removed if the element exists in the sorted list multiple times.\\n   */\\n  remove(value) {\\n    const idx = this._data.indexOf(value);\\n    if (idx >= 0) {\\n      this._data.splice(idx, 1);\\n      return true;\\n    }\\n    return false;\\n  }\\n  get length() {\\n    return this._data.length;\\n  }\\n  *filter(predicate) {\\n    for (const item of this._data) {\\n      if (predicate(item)) {\\n        yield item;\\n      }\\n    }\\n  }\\n  [Symbol.iterator]() {\\n    return this._data[Symbol.iterator]();\\n  }\\n};\\n\\n// src/index.ts\\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\\nvar CommentsApiError = HttpError;\\nvar NotificationsApiError = HttpError;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nexports.ClientMsgCode = ClientMsgCode; exports.CommentsApiError = CommentsApiError; exports.CrdtType = CrdtType; exports.HttpError = HttpError; exports.LiveList = LiveList; exports.LiveMap = LiveMap; exports.LiveObject = LiveObject; exports.NotificationsApiError = NotificationsApiError; exports.OpCode = OpCode; exports.ServerMsgCode = ServerMsgCode; exports.SortedList = SortedList; exports.WebsocketCloseCodes = WebsocketCloseCodes; exports.ackOp = ackOp; exports.asPos = asPos; exports.assert = assert; exports.assertNever = assertNever; exports.autoRetry = autoRetry; exports.b64decode = b64decode; exports.chunk = chunk; exports.cloneLson = cloneLson; exports.compactObject = compactObject; exports.console = fancy_console_exports; exports.convertToCommentData = convertToCommentData; exports.convertToCommentUserReaction = convertToCommentUserReaction; exports.convertToInboxNotificationData = convertToInboxNotificationData; exports.convertToThreadData = convertToThreadData; exports.createClient = createClient; exports.createCommentId = createCommentId; exports.createInboxNotificationId = createInboxNotificationId; exports.createStore = createStore; exports.createThreadId = createThreadId; exports.deprecate = deprecate; exports.deprecateIf = deprecateIf; exports.detectDupes = detectDupes; exports.errorIf = errorIf; exports.freeze = freeze; exports.getMentionedIdsFromCommentBody = getMentionedIdsFromCommentBody; exports.isChildCrdt = isChildCrdt; exports.isJsonArray = isJsonArray; exports.isJsonObject = isJsonObject; exports.isJsonScalar = isJsonScalar; exports.isLiveNode = isLiveNode; exports.isPlainObject = isPlainObject; exports.isRootCrdt = isRootCrdt; exports.kInternal = kInternal; exports.legacy_patchImmutableObject = legacy_patchImmutableObject; exports.lsonToJson = lsonToJson; exports.makeEventSource = makeEventSource; exports.makePoller = makePoller; exports.makePosition = makePosition; exports.mapValues = mapValues; exports.memoizeOnSuccess = memoizeOnSuccess; exports.nanoid = nanoid; exports.nn = nn; exports.objectToQuery = objectToQuery; exports.patchLiveObjectKey = patchLiveObjectKey; exports.raise = raise; exports.shallow = shallow; exports.stringify = stringify; exports.stringifyCommentBody = stringifyCommentBody; exports.throwUsageError = throwUsageError; exports.toPlainLson = toPlainLson; exports.tryParseJson = tryParseJson; exports.url = url; exports.urljoin = urljoin; exports.wait = wait; exports.withTimeout = withTimeout;\\n//# sourceMappingURL=index.js.map\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_nullishCoalesce\",\"lhs\",\"rhsFn\",\"_optionalChain\",\"ops\",\"lastAccessLHS\",\"undefined\",\"value\",\"i\",\"length\",\"op\",\"fn\",\"args\",\"call\",\"detectDupes\",\"pkgName\",\"pkgVersion\",\"pkgFormat\",\"pkgId\",\"Symbol\",\"for\",\"pkgBuildInfo\",\"g\",\"msg\",\"join\",\"Error\",\"PKG_VERSION\",\"assertNever\",\"_value\",\"errmsg\",\"assert\",\"condition\",\"err\",\"name\",\"nn\",\"controlledPromise\",\"resolve\",\"reject\",\"promise\",\"Promise\",\"res\",\"rej\",\"Promise_withResolvers\",\"makeEventSource\",\"subscribe\",\"callback\",\"_observers\",\"add\",\"delete\",\"subscribeOnce\",\"_onetimeObservers\",\"waitUntil\",\"predicate\",\"unsub\",\"finally\",\"event\",\"_2\",\"notify\",\"forEach\",\"clear\",\"Set\",\"_buffer\",\"notifyOrBuffer\",\"push\",\"_forceClear\",\"count\",\"size\",\"pause\",\"unpause\",\"observable\",\"wrap\",\"method\",\"window\",\"console\",\"message\",\"badge\",\"wrapWithTitle\",\"title\",\"bold\",\"distance\",\"state1\",\"state2\",\"chunks1\",\"split\",\"chunks2\",\"minLen\",\"Math\",\"min\",\"shared\",\"patterns\",\"targetState\",\"levels\",\"parts\",\"result\",\"slice\",\"raise\",\"isPlainObject\",\"blob\",\"Object\",\"prototype\",\"toString\",\"tryParseJson\",\"rawMessage\",\"JSON\",\"parse\",\"e\",\"deepClone\",\"stringify\",\"b64decode\",\"b64value\",\"formattedValue\",\"replace\",\"decodeURIComponent\",\"decodedValue\",\"atob\",\"map\",\"c\",\"charCodeAt\",\"compact\",\"items\",\"filter\",\"item\",\"compactObject\",\"obj\",\"newObj\",\"keys\",\"k\",\"wait\",\"millis\",\"setTimeout\",\"withTimeout\",\"timerID\",\"timer$\",\"_\",\"race\",\"clearTimeout\",\"memoizeOnSuccess\",\"factoryFn\",\"cached\",\"catch\",\"shouldDisconnect\",\"code\",\"shouldRetryWithoutReauth\",\"toNewConnectionStatus\",\"machine\",\"state\",\"currentState\",\"context\",\"successCount\",\"nextBackoffDelay\",\"currentDelay\",\"delays\",\"find\",\"delay\",\"increaseBackoffDelay\",\"patch\",\"backoffDelay\",\"BACKOFF_DELAYS\",\"increaseBackoffDelayAggressively\",\"BACKOFF_DELAYS_SLOW\",\"resetSuccessCount\",\"log\",\"level\",\"logger\",\"error2\",\"warn\",\"logPrematureErrorOrCloseEvent\",\"ctx\",\"conn\",\"String\",\"type\",\"logCloseEvent\",\"details\",\"reason\",\"enableTracing\",\"log2\",\"toFixed\",\"getTime\",\"Date\",\"start\",\"id\",\"unsubs\",\"events\",\"didReceiveEvent\",\"willTransition\",\"from\",\"to\",\"didIgnoreEvent\",\"defineConnectivityEvents\",\"statusDidChange\",\"didConnect\",\"didDisconnect\",\"lastStatus\",\"unsubscribe\",\"didEnterState\",\"currStatus\",\"createConnectionStateMachine\",\"delegates\",\"options\",\"fireErrorEvent\",\"errcode\",\"LiveblocksError\",\"onLiveblocksError\",\"teardownSocket\",\"socket\",\"removeEventListener\",\"onSocketError\",\"onSocketClose\",\"onSocketMessage\",\"close\",\"onMessage\",\"addState\",\"FSM\",\"initialContext\",\"authValue\",\"RESET_DELAY\",\"addTransitions\",\"RECONNECT\",\"target\",\"effect\",\"DISCONNECT\",\"onEnter\",\"CONNECT\",\"NAVIGATOR_ONLINE\",\"assign\",\"addTimedTransition\",\"onEnterAsync\",\"authenticate\",\"AUTH_TIMEOUT\",\"okEvent\",\"data\",\"failedEvent\",\"StopRetrying\",\"send\",\"signal\",\"capturedPrematureEvent\",\"unconfirmedSocket\",\"connect$\",\"waitForActorId\",\"serverMsg\",\"_13\",\"didReceiveActor\",\"createSocket\",\"actor$\",\"addEventListener\",\"then\",\"SOCKET_CONNECT_TIMEOUT\",\"aborted\",\"failure\",\"sendHeartbeat\",\"_14\",\"_15\",\"_16\",\"maybeHeartbeat\",\"doc\",\"document\",\"_17\",\"visibilityState\",\"canZombie\",\"HEARTBEAT_INTERVAL\",\"NAVIGATOR_OFFLINE\",\"WINDOW_GOT_FOCUS\",\"ctx2\",\"PONG\",\"PONG_TIMEOUT\",\"EXPLICIT_SOCKET_ERROR\",\"_18\",\"_19\",\"readyState\",\"EXPLICIT_SOCKET_CLOSE\",\"logPermanentClose\",\"win\",\"root\",\"onNetworkOffline\",\"onNetworkBackOnline\",\"onVisibilityChange\",\"_20\",\"_21\",\"_22\",\"_23\",\"_24\",\"_25\",\"_26\",\"_27\",\"_28\",\"_29\",\"_30\",\"_31\",\"_32\",\"cleanups\",\"enableDebugLogging\",\"canComment\",\"scopes\",\"includes\",\"parseAuthToken\",\"rawTokenString\",\"tokenParts\",\"payload\",\"raw\",\"parsed\",\"createAuthManager\",\"authOptions\",\"hasCorrespondingScopes\",\"requestedScope\",\"getCachedToken\",\"requestOptions\",\"now\",\"ceil\",\"tokens\",\"token\",\"expiryTimes\",\"expiresAt\",\"splice\",\"roomId\",\"entries\",\"perms\",\"resource\",\"startsWith\",\"makeAuthRequest\",\"fetcher\",\"_36\",\"polyfills\",\"_37\",\"fetch\",\"authentication\",\"response\",\"fetchAuthEndpoint\",\"url\",\"room\",\"seenTokens\",\"has\",\"error\",\"prepareAuthentication\",\"requestPromises\",\"Map\",\"reset\",\"getAuthValue\",\"publicApiKey\",\"cachedToken\",\"currentPromise\",\"get\",\"set\",\"floor\",\"exp\",\"iat\",\"BUFFER\",\"authEndpoint\",\"endpoint\",\"body\",\"headers\",\"ok\",\"trim\",\"text\",\"status\",\"json\",\"er\",\"sendToPanel\",\"fullMsg\",\"source\",\"_38\",\"force\",\"_bridgeActive\",\"postMessage\",\"setupDevTools\",\"getAllRooms\",\"_devtoolsSetupHasRun\",\"onMessageFromPanel\",\"allowed\",\"clientVersion\",\"stopSyncStream\",\"unsubsByRoomId\",\"startSyncStream\",\"fullSync\",\"getStatus\",\"storageDidLoad\",\"partialSyncStorage\",\"storageBatch\",\"self\",\"me\",\"kInternal\",\"getSelf_forDevTools\",\"others\",\"getOthers_forDevTools\",\"ydoc\",\"update\",\"customEvent\",\"eventData\",\"loadedAt\",\"eventCounter\",\"key\",\"connectionId\",\"getStorageSnapshot\",\"storage\",\"toTreeNode\",\"fetchYDoc\",\"_41\",\"_42\",\"_43\",\"stopRoomChannelListener\",\"listener\",\"roomChannelListeners\",\"linkDevTools\",\"object\",\"Array\",\"isArray\",\"sortedObject\",\"sort\",\"reduce\",\"sortedObject2\",\"createBatchStore\",\"batch\",\"cache\",\"eventSource2\",\"input\",\"cacheKey\",\"isLoading\",\"error3\",\"getState\",\"invalidate\",\"inputs\",\"_cacheKeys\",\"createStore\",\"initialState\",\"dirty\",\"subscriber\",\"subscribers\",\"notifyImmediately\",\"oldState\",\"newState\",\"cb\",\"convertToCommentData\",\"editedAt\",\"createdAt\",\"reactions\",\"reaction\",\"deletedAt\",\"convertToThreadData\",\"updatedAt\",\"comments\",\"comment\",\"convertToCommentUserReaction\",\"convertToInboxNotificationData\",\"notifiedAt\",\"readAt\",\"activities\",\"activity\",\"convertToThreadDeleteInfo\",\"convertToInboxNotificationDeleteInfo\",\"autoRetry\",\"promiseFn\",\"maxTries\",\"backoff\",\"shouldStopRetrying\",\"DONT_RETRY_4XX\",\"fallbackBackoff\",\"attempt\",\"urljoin\",\"baseUrl\",\"path\",\"params\",\"url2\",\"URL\",\"URLSearchParams\",\"search\",\"strings\",\"values\",\"str\",\"encodeURIComponent\",\"getBearerTokenFromAuthValue\",\"createNotificationsApi\",\"authManager\",\"currentUserIdStore\",\"fetchPolyfill\",\"markInboxNotificationsAsRead\",\"inboxNotificationIds\",\"httpClient\",\"post\",\"HttpClient\",\"userId\",\"uid\",\"batchedMarkInboxNotificationsAsRead\",\"Batch\",\"batchedInboxNotificationIds\",\"flat\",\"getInboxNotifications\",\"cursor\",\"_46\",\"limit\",\"PAGE_SIZE\",\"inboxNotifications\",\"threads\",\"nextCursor\",\"meta\",\"requestedAt\",\"getInboxNotificationsSince\",\"since\",\"toISOString\",\"_47\",\"updated\",\"deleted\",\"deletedInboxNotifications\",\"deletedThreads\",\"getUnreadInboxNotificationsCount\",\"markAllInboxNotificationsAsRead\",\"markInboxNotificationAsRead\",\"inboxNotificationId\",\"deleteAllInboxNotifications\",\"deleteInboxNotification\",\"getUserThreads_experimental\",\"query\",\"_48\",\"objectToQuery\",\"getUserThreadsSince_experimental\",\"nthDigit\",\"n\",\"MIN_CODE\",\"NUM_DIGITS\",\"MAX_CODE\",\"fromCharCode\",\"makePosition\",\"x\",\"y\",\"_between\",\"substring\",\"ONE\",\"lastIndex\",\"pos\",\"ZERO_NINE\",\"lo\",\"hi\",\"index\",\"loLen\",\"hiLen\",\"loCode\",\"hiCode\",\"prefix\",\"ZERO\",\"repeat\",\"suffix\",\"nines\",\"isPos\",\"lastIdx\",\"last\",\"MIN_NON_ZERO_CODE\",\"asPos\",\"codes\",\"HasParent\",\"node\",\"freeze\",\"Orphaned\",\"oldKey\",\"oldPos\",\"isRootCrdt\",\"crdt\",\"isChildCrdt\",\"parentId\",\"parentKey\",\"compareNodePosition\",\"itemA\",\"itemB\",\"posA\",\"_parentPos\",\"posB\",\"makeUpdate\",\"liveList\",\"deltaUpdates\",\"updates\",\"setDelta\",\"LiveRegister\",\"deleteDelta\",\"deletedNode\",\"deletedItem\",\"insertDelta\",\"moveDelta\",\"previousIndex\",\"HACK_addIntentAndDeletedIdToOperation\",\"deletedId\",\"intent\",\"creationOpToLson\",\"LiveObject\",\"LiveMap\",\"LiveList\",\"isSameNodeOrChildOf\",\"parent\",\"deserialize\",\"parentToChildren\",\"pool\",\"_deserialize\",\"deserializeToLson\",\"isLiveStructure\",\"isLiveNode\",\"cloneLson\",\"clone\",\"liveNodeToLson\",\"lsonToLiveNode\",\"getTreesDiffOperations\",\"currentItems\",\"newItems\",\"currentCrdt\",\"mergeStorageUpdates\",\"first\",\"second\",\"concat\",\"isPlain\",\"findNonSerializableValue\",\"nestedValue\",\"nestedPath\",\"nonSerializableNestedValue\",\"chunk\",\"array\",\"chunks\",\"j\",\"createThreadId\",\"THREAD_ID_PREFIX\",\"nanoid\",\"createCommentId\",\"COMMENT_ID_PREFIX\",\"captureStackTrace\",\"traceRoot\",\"errorLike\",\"stack\",\"isJsonScalar\",\"isJsonArray\",\"isJsonObject\",\"filterList\",\"keyValuePairs\",\"keyValuePairsWithOperator\",\"indexedKeys\",\"entries2\",\"identifierRegex\",\"test\",\"isSimpleValue\",\"isValueWithOperator\",\"getFiltersFromKeyValuePairs\",\"getFiltersFromKeyValuePairsWithOperator\",\"nKeyValuePairs\",\"nKeyValuePairsWithOperator\",\"nestedEntries\",\"nestedKey\",\"operator\",\"merge\",\"newValue\",\"val\",\"makeIdFactory\",\"userToTreeNode\",\"user\",\"info\",\"presence\",\"isReadOnly\",\"canWrite\",\"installBackgroundTabSpy\",\"_117\",\"inBackgroundSince\",\"current\",\"_118\",\"_119\",\"_120\",\"_121\",\"splitFileIntoParts\",\"file\",\"end\",\"ATTACHMENT_PART_SIZE\",\"partNumber\",\"part\",\"createRoom\",\"config\",\"sendMessages\",\"messages\",\"serializedPayload\",\"nonce\",\"_130\",\"dynamicSessionInfo\",\"_131\",\"_132\",\"unstable_fallbackToHTTP\",\"MAX_SOCKET_MESSAGE_SIZE\",\"encode\",\"TextEncoder\",\"httpClient1\",\"rawPost\",\"resp\",\"managedSocket\",\"reconnect\",\"notifySelfChanged\",\"batchedUpdatesWrapper\",\"currSelf\",\"_lastSelf\",\"eventHub\",\"createOrUpdateRootFromMessage\",\"updateRoot\",\"_fromItems\",\"_133\",\"_134\",\"stackSizeBefore\",\"undoStack\",\"initialStorage\",\"nodes\",\"_serialize\",\"applyOps\",\"_addToRealUndoStack\",\"historyOps\",\"shift\",\"onHistoryChange\",\"addToUndoStack\",\"pausedHistory\",\"unshift\",\"storageUpdates\",\"othersUpdates\",\"doNotBatchUpdates\",\"myPresence\",\"updates2\",\"notifyStorageStatus\",\"getConnectionId\",\"actor\",\"rawOps\",\"isLocal\",\"createdNodeIds\",\"opId\",\"generateOpId\",\"reverse\",\"buffer\",\"presenceUpdates\",\"opStackTraces\",\"unacknowledgedOps\",\"applyOpResult\",\"applyOp\",\"modified\",\"nodeId\",\"_id\",\"_apply\",\"_setChildKey\",\"parentNode\",\"_attachChild\",\"onUpdatePresenceMessage\",\"targetActor\",\"oldUser\",\"getUser\",\"setOther\",\"newUser\",\"patchOther\",\"onUserLeftMessage\",\"removeConnection\",\"onRoomStateMessage\",\"idFactory\",\"connectionIds\",\"users\",\"setConnection\",\"Number\",\"canUndo\",\"canRedo\",\"redoStack\",\"history\",\"onUserJoinedMessage\",\"flushNowOrSoon\",\"parseServerMessages\",\"applyAndSendOps\",\"offlineOps\",\"storageOps\",\"storageOperations\",\"elapsedMillis\",\"lastFlushedAt\",\"throttleDelay\",\"messagesToFlush\",\"flushTimerID\",\"dispatchOps\",\"processInitialStorage\",\"_resolveStoragePromise\",\"_140\",\"streamStorage\",\"rawGet\",\"refreshStorage\",\"options2\",\"unstable_streamData\",\"some\",\"flush\",\"startLoadingStorage\",\"_getStorage$\",\"getStorage\",\"getStorageStatus\",\"storageStatus\",\"_lastStorageStatus\",\"isPresenceReady\",\"isStorageReady\",\"getAttachmentUrls\",\"attachmentIds\",\"urls\",\"httpClient2\",\"fetchNotificationsJson\",\"initialPresence\",\"uninstallBgTabSpy\",\"backgroundKeepAliveTimeout\",\"ManagedSocket\",\"staticSessionInfo\",\"ValueRef\",\"PatchableRef\",\"OthersRef\",\"provider\",\"onProviderUpdate\",\"clock\",\"opClock\",\"activeBatch\",\"batchUpdates\",\"unstable_batchedUpdates\",\"lastTokenKey\",\"_connectionLossTimerId\",\"_hasLostConnection\",\"handleServerMessage\",\"userJoinedUpdate\",\"othersPresenceUpdate\",\"u\",\"event2\",\"applyResult\",\"errorWithTitle\",\"traces\",\"opIds\",\"trace\",\"_137\",\"_138\",\"_139\",\"warnWithTitle\",\"onStatusDidChange\",\"newStatus\",\"tokenKey\",\"userInfo\",\"ui\",\"handleConnectionLossEvent\",\"lostConnection\",\"clearOthers\",\"lostConnectionTimeout\",\"onDidConnect\",\"onDidDisconnect\",\"getNode\",\"addNode\",\"deleteNode\",\"generateId\",\"dispatch\",\"stackTrace\",\"reverseOps\",\"assertStorageIsWritable\",\"_122\",\"_123\",\"_124\",\"_125\",\"_126\",\"globalThis\",\"_127\",\"_128\",\"bind\",\"_129\",\"DerivedRef\",\"staticSession\",\"dynamicSession\",\"selfAsTreeNode\",\"others_forDevTools\",\"other\",\"batchedGetAttachmentUrls\",\"batchedAttachmentIds\",\"attachmentUrls\",\"GET_ATTACHMENT_URLS_BATCH_DELAY\",\"attachmentUrlsStore\",\"defineProperty\",\"presenceBuffer\",\"_152\",\"_153\",\"_154\",\"nodeCount\",\"getProvider\",\"setProvider\",\"reportTextEditor\",\"rootKey\",\"createTextMention\",\"mentionId\",\"deleteTextMention\",\"rawDelete\",\"listTextVersions\",\"versions\",\"version\",\"listTextVersionsSince\",\"getTextVersion\",\"versionId\",\"createTextVersion\",\"simulate\",\"explicitClose\",\"_privateSendMachineEvent\",\"rawSend\",\"makeClassicSubscribeFn\",\"connect\",\"disconnect\",\"destroy\",\"updatePresence\",\"oldValues\",\"overrideValue\",\"_135\",\"addToHistory\",\"_136\",\"updateYDoc\",\"guid\",\"clientMsg\",\"broadcastEvent\",\"shouldQueueEventIfNotReady\",\"returnValue\",\"currentBatch\",\"undo\",\"pop\",\"redo\",\"pauseHistory\",\"resume\",\"resumeHistory\",\"vector\",\"m\",\"waitUntilPresenceReady\",\"unsub1\",\"unsub2\",\"waitUntilStorageReady\",\"getSelf\",\"getPresence\",\"getOthers\",\"getThreads\",\"_144\",\"_145\",\"getThreadsSince\",\"_141\",\"_142\",\"_143\",\"getThread\",\"threadId\",\"thread\",\"inboxNotification\",\"createThread\",\"metadata\",\"commentId\",\"deleteThread\",\"editThreadMetadata\",\"markThreadAsResolved\",\"markThreadAsUnresolved\",\"createComment\",\"editComment\",\"deleteComment\",\"addReaction\",\"emoji\",\"removeReaction\",\"prepareAttachment\",\"COMMENT_ATTACHMENT_ID_PREFIX\",\"mimeType\",\"uploadAttachment\",\"attachment\",\"abortSignal\",\"abortError\",\"DOMException\",\"_146\",\"handleRetryError\",\"_147\",\"HttpError\",\"putBlob\",\"fileSize\",\"RETRY_ATTEMPTS\",\"RETRY_DELAYS\",\"uploadId\",\"uploadedParts\",\"createMultiPartUpload\",\"_148\",\"batches\",\"ATTACHMENT_PART_BATCH_SIZE\",\"parts2\",\"uploadedPartsPromises\",\"all\",\"_149\",\"sortedUploadedParts\",\"a\",\"b\",\"_150\",\"error4\",\"getAttachmentUrl\",\"attachmentId\",\"getNotificationSettings\",\"_151\",\"updateNotificationSettings\",\"settings\",\"enumerable\",\"subscribeToLiveStructureDeeply\",\"relatedUpdates\",\"subscribeToLiveStructureShallowly\",\"internalEvent\",\"_155\",\"isDeep\",\"makeAuthDelegateForRoom\",\"makeCreateSocketDelegateForRoom\",\"WebSocketPolyfill\",\"ws\",\"WebSocket\",\"protocol\",\"pathname\",\"searchParams\",\"getBaseUrl\",\"DEFAULT_BASE_URL\",\"checkBounds\",\"option\",\"max\",\"recommendedMin\",\"getBackgroundKeepAliveTimeout\",\"MIN_BACKGROUND_KEEP_ALIVE_TIMEOUT\",\"createDevelopmentWarning\",\"hasWarned\",\"isCommentBodyText\",\"element\",\"isCommentBodyMention\",\"isCommentBodyLink\",\"traverseCommentBody\",\"elementOrVisitor\",\"possiblyVisitor\",\"_171\",\"content\",\"commentBodyElementsTypes\",\"guard\",\"commentBodyElementsGuards\",\"visitor\",\"block\",\"_172\",\"inline\",\"children\",\"_173\",\"getMentionedIdsFromCommentBody\",\"mentionedIds\",\"mention\",\"resolveUsersInCommentBody\",\"resolveUsers\",\"resolvedUsers\",\"userIds\",\"_174\",\"joinHtml\",\"HtmlSafeString\",\"fill\",\"escapeHtml\",\"htmlEscapablesRegex\",\"character\",\"htmlEscapables\",\"html\",\"joinMarkdown\",\"MarkdownSafeString\",\"escapeMarkdown\",\"markdownEscapablesRegex\",\"markdownEscapables\",\"markdown\",\"toAbsoluteUrl\",\"toPlainLson\",\"lson\",\"liveblocksType\",\"fromEntries\",\"toObject\",\"flatMap\",\"lsonObjectToJson\",\"lsonToJson\",\"toArray\",\"deepLiveify\",\"init\",\"patchLiveObjectKey\",\"liveObject\",\"prev\",\"next\",\"nonSerializableValue\",\"prevEnd\",\"nextEnd\",\"prevNode\",\"nextNode\",\"insert\",\"localI\",\"liveListNode\",\"patchLiveObject\",\"legacy_patchImmutableNode\",\"pathItem\",\"_182\",\"_183\",\"_184\",\"_185\",\"_186\",\"_187\",\"listUpdate\",\"_188\",\"_189\",\"_190\",\"_191\",\"_192\",\"_193\",\"newArray\",\"deprecate\",\"_emittedDeprecationWarnings\",\"throwUsageError\",\"usageError\",\"shallowObj\",\"objA\",\"objB\",\"keysA\",\"every\",\"hasOwnProperty\",\"is\",\"__defProp\",\"fancy_console_exports\",\"__export\",\"SafeContext\",\"constructor\",\"curr\",\"allowPatching\",\"patchableContext\",\"pair\",\"nextId\",\"states\",\"iterator\",\"done\",\"currentStateOrNull\",\"runningState\",\"enter\",\"stop\",\"exit\",\"enterFns\",\"cleanupStack\",\"knownEventTypes\",\"allowedTransitions\",\"currentContext\",\"willExitState\",\"nameOrPattern\",\"enterFn\",\"onOK\",\"onError\",\"maxTimeout\",\"abortController\",\"AbortController\",\"timeoutId\",\"transition\",\"abort\",\"getStatesMatching\",\"matches\",\"endsWith\",\"mapping\",\"srcState\",\"target_\",\"targetFn\",\"stateOrPattern\",\"after2\",\"ms\",\"timeoutID\",\"getTargetFn\",\"eventName\",\"_3\",\"_4\",\"_5\",\"_6\",\"_7\",\"_8\",\"_9\",\"_10\",\"_11\",\"enterPatterns\",\"pattern\",\"cleanupFn\",\"_12\",\"nextTarget\",\"nextState\",\"effects\",\"up\",\"down\",\"effectsToRun\",\"ServerMsgCode\",\"ServerMsgCode2\",\"WebsocketCloseCodes\",\"WebsocketCloseCodes2\",\"e2\",\"cleanup\",\"_33\",\"_34\",\"_35\",\"eventSource\",\"_39\",\"_40\",\"BatchCall\",\"queue\",\"DEFAULT_SIZE\",\"clearDelayTimeout\",\"delayTimeoutId\",\"schedule\",\"calls\",\"results\",\"_44\",\"existingCall\",\"call2\",\"authCallback\",\"_baseUrl\",\"_fetchPolyfill\",\"_authCallback\",\"rawFetch\",\"_45\",\"Authorization\",\"errorBody\",\"e3\",\"statusText\",\"e4\",\"OpCode\",\"OpCode2\",\"NoParent\",\"AbstractCrdt\",\"_parent\",\"_getParentKeyOrThrow\",\"__pool\",\"__id\",\"_isLocal\",\"_detachChild\",\"_setParentLink\",\"newParentNode\",\"newParentKey\",\"_attach\",\"_detach\",\"_cachedImmutable\",\"_cachedTreeNode\",\"_cachedTreeNodeKey\",\"_toTreeNode\",\"toImmutable\",\"_toImmutable\",\"CrdtType\",\"CrdtType2\",\"t\",\"crypto\",\"getRandomValues\",\"Uint8Array\",\"t2\",\"toUpperCase\",\"_data\",\"_parentToChildren\",\"register\",\"_LiveRegister\",\"_toOps\",\"_49\",\"_50\",\"_op\",\"_crdt\",\"_items\",\"_implicitlyDeletedItems\",\"WeakSet\",\"_unacknowledgedSets\",\"position\",\"newPosition\",\"list\",\"_LiveList\",\"id2\",\"child\",\"_insertAndSort\",\"_51\",\"_52\",\"parentKey2\",\"childOps\",\"childOpId\",\"_sortItems\",\"_indexOfPosition\",\"findIndex\",\"_applySetRemote\",\"_pool\",\"indexOfItemWithSamePosition\",\"itemWithSamePosition\",\"delta\",\"deleteDelta2\",\"_detachItemAssociatedToSetOperation\",\"_applySetAck\",\"deletedDelta\",\"unacknowledgedOpId\",\"existingItem\",\"_parentKey\",\"prevIndex\",\"indexOf\",\"newIndex\",\"orphan\",\"recreatedItemIndex\",\"newItem\",\"_createAttachItemAndSort\",\"_applyRemoteInsert\",\"existingItemIndex\",\"_shiftItemPosition\",\"_applyInsertAck\",\"itemIndexAtPosition\",\"oldPositionIndex\",\"_applyInsertUndoRedo\",\"_53\",\"_54\",\"_55\",\"newKey\",\"before2\",\"_56\",\"_57\",\"_58\",\"_59\",\"_60\",\"_61\",\"_applySetUndoRedo\",\"_62\",\"_63\",\"_64\",\"indexOfItemWithSameKey\",\"indexToDelete\",\"previousNode\",\"_applySetChildKeyRemote\",\"_65\",\"_66\",\"_67\",\"_applySetChildKeyAck\",\"previousKey\",\"_68\",\"_69\",\"_70\",\"_71\",\"_72\",\"_73\",\"_applySetChildKeyUndoRedo\",\"_74\",\"_75\",\"_76\",\"_77\",\"_78\",\"_79\",\"_80\",\"_81\",\"_82\",\"move\",\"targetIndex\",\"_83\",\"_84\",\"_85\",\"beforePosition\",\"afterPosition\",\"previousPosition\",\"_86\",\"_87\",\"_88\",\"childRecordId\",\"_89\",\"_90\",\"_91\",\"updateDelta\",\"childId\",\"_92\",\"_93\",\"_94\",\"existingId\",\"entry\",\"callbackfn\",\"searchElement\",\"fromIndex\",\"lastIndexOf\",\"LiveListIterator\",\"shiftedPosition\",\"_95\",\"_96\",\"_97\",\"_innerIterator\",\"unacknowledgedSet\",\"mappedEntries\",\"_map\",\"_98\",\"_99\",\"_LiveMap\",\"lastUpdateOpId\",\"previousValue\",\"thisId\",\"storageUpdate\",\"_100\",\"_101\",\"_102\",\"oldValue\",\"_103\",\"_104\",\"_105\",\"innerIterator\",\"iteratorValue\",\"key2\",\"_buildRootAndParentToChildren\",\"tuple\",\"_LiveObject\",\"_propToLastUpdate\",\"o\",\"_106\",\"_107\",\"liveObj\",\"_deserializeChildren\",\"_applyUpdate\",\"_applyDeleteObjectKey\",\"isModified\",\"reverseUpdate\",\"_108\",\"_109\",\"_110\",\"_111\",\"_112\",\"_113\",\"_114\",\"_115\",\"_116\",\"updatedProps\",\"reverseUpdateOp\",\"newAttachChildOps\",\"createCrdtOp\",\"filters\",\"ClientMsgCode\",\"ClientMsgCode2\",\"ImmutableRef\",\"_ev\",\"_cache\",\"_connections\",\"_presences\",\"_users\",\"_getUser\",\"cachedUser\",\"computedUser\",\"_invalidateUser\",\"metaUserId\",\"metaUserInfo\",\"oldPresence\",\"newPresence\",\"oldData\",\"newData\",\"initialValue\",\"transformFn\",\"_refs\",\"ref\",\"didInvalidate\",\"_transform\",\"paragraph\",\"isCommentBodyParagraph\",\"link\",\"RegExp\",\"entity\",\"_strings\",\"_values\",\"stringifyCommentBodyPlainElements\",\"_175\",\"stringifyCommentBodyHtmlElements\",\"italic\",\"strikethrough\",\"href\",\"_176\",\"stringifyCommentBodyMarkdownElements\",\"_177\",\"BACKOFF_DELAYS2\",\"alreadySortedList\",\"lt\",\"_lt\",\"arr\",\"sorted\",\"_SortedList\",\"fromAlreadySorted\",\"alreadySorted\",\"mid\",\"remove\",\"idx\",\"SortedList\",\"PKG_NAME\",\"PKG_FORMAT\",\"CommentsApiError\",\"NotificationsApiError\",\"ackOp\",\"createClient\",\"leaseRoom\",\"leave\",\"roomsById\",\"throttle\",\"DEFAULT_THROTTLE\",\"MIN_THROTTLE\",\"MAX_THROTTLE\",\"DEFAULT_LOST_CONNECTION_TIMEOUT\",\"MIN_LOST_CONNECTION_TIMEOUT\",\"MAX_LOST_CONNECTION_TIMEOUT\",\"RECOMMENDED_MIN_LOST_CONNECTION_TIMEOUT\",\"_164\",\"_165\",\"_166\",\"_167\",\"_168\",\"notificationsAPI\",\"warnIfNoResolveUsers\",\"batchedResolveUsers\",\"batchedUserIds\",\"_169\",\"RESOLVE_USERS_BATCH_DELAY\",\"usersStore\",\"resolveRoomsInfo\",\"warnIfNoResolveRoomsInfo\",\"batchedResolveRoomsInfo\",\"batchedRoomIds\",\"roomIds\",\"roomsInfo\",\"_170\",\"RESOLVE_ROOMS_INFO_BATCH_DELAY\",\"roomsInfoStore\",\"mentionSuggestionsCache\",\"client\",\"enterRoom\",\"existing\",\"newRoom\",\"mockedDelegates\",\"_156\",\"_157\",\"_158\",\"newRoomDetails\",\"shouldConnect\",\"autoConnect\",\"_159\",\"_160\",\"getRoom\",\"_161\",\"_162\",\"_163\",\"logout\",\"resolvers\",\"invalidateUsers\",\"invalidateResolvedUsers\",\"invalidateRoomsInfo\",\"invalidateResolvedRoomsInfo\",\"invalidateMentionSuggestions\",\"invalidateResolvedMentionSuggestions\",\"resolveMentionSuggestions\",\"getRoomIds\",\"as\",\"createInboxNotificationId\",\"INBOX_NOTIFICATION_ID_PREFIX\",\"deprecateIf\",\"errorIf\",\"legacy_patchImmutableObject\",\"makePoller\",\"intervalMs\",\"startOrStop\",\"inForeground\",\"fsm\",\"pollNowIfStale\",\"performance\",\"lastSuccessfulPollAt\",\"maxStaleTimeMs\",\"setInForeground\",\"_196\",\"startTime\",\"_194\",\"POSITIVE_INFINITY\",\"_195\",\"START\",\"STOP\",\"POLL\",\"_ctx\",\"_197\",\"_198\",\"_199\",\"_200\",\"inc\",\"dec\",\"mapValues\",\"mapFn\",\"shallow\",\"isArrayA\",\"isArrayB\",\"stringifyCommentBody\",\"format\",\"_178\",\"separator\",\"_179\",\"elements\",\"_180\",\"_181\",\"blocks\",\"blockIndex\",\"inlines\",\"inlineIndex\"]\n}\n"]